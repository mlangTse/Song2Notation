{"ast":null,"code":"import { Font, FontStyle, FontWeight } from './font.js';\nimport { Modifier, ModifierPosition } from './modifier.js';\nimport { Renderer } from './renderer.js';\nimport { Stem } from './stem.js';\nimport { Tables } from './tables.js';\nimport { isStaveNote, isStemmableNote } from './typeguard.js';\nimport { RuntimeError } from './util.js';\nclass StringNumber extends Modifier {\n  static get CATEGORY() {\n    return \"StringNumber\";\n  }\n  static get metrics() {\n    var _a;\n    return (_a = Tables.currentMusicFont().getMetrics().stringNumber) !== null && _a !== void 0 ? _a : {\n      verticalPadding: 0,\n      stemPadding: 0,\n      leftPadding: 0,\n      rightPadding: 0\n    };\n  }\n  static format(nums, state) {\n    const left_shift = state.left_shift;\n    const right_shift = state.right_shift;\n    const num_spacing = 1;\n    if (!nums || nums.length === 0) return false;\n    const nums_list = [];\n    let prev_note = null;\n    let extraXSpaceForDisplacedNotehead = 0;\n    let shift_right = 0;\n    const modLines = 0;\n    for (let i = 0; i < nums.length; ++i) {\n      const num = nums[i];\n      const note = num.getNote();\n      const pos = num.getPosition();\n      if (!isStaveNote(note)) {\n        throw new RuntimeError('NoStaveNote');\n      }\n      const index = num.checkIndex();\n      const props = note.getKeyProps()[index];\n      const mc = note.getModifierContext();\n      const verticalSpaceNeeded = num.radius * 2 / Tables.STAVE_LINE_DISTANCE + 0.5;\n      if (mc) {\n        if (pos === ModifierPosition.ABOVE) {\n          num.text_line = mc.getState().top_text_line;\n          state.top_text_line += verticalSpaceNeeded;\n        } else if (pos === ModifierPosition.BELOW) {\n          num.text_line = mc.getState().text_line;\n          state.text_line += verticalSpaceNeeded;\n        }\n      }\n      if (note !== prev_note) {\n        for (let n = 0; n < note.keys.length; ++n) {\n          if (pos === Modifier.Position.LEFT) {\n            extraXSpaceForDisplacedNotehead = Math.max(note.getLeftDisplacedHeadPx(), extraXSpaceForDisplacedNotehead);\n          }\n          if (right_shift === 0) {\n            shift_right = Math.max(note.getRightDisplacedHeadPx(), shift_right);\n          }\n        }\n        prev_note = note;\n      }\n      const glyphLine = modLines === 0 ? props.line : modLines;\n      nums_list.push({\n        pos,\n        note,\n        num,\n        line: glyphLine,\n        shiftL: extraXSpaceForDisplacedNotehead,\n        shiftR: shift_right\n      });\n    }\n    nums_list.sort((a, b) => b.line - a.line);\n    let num_shiftR = 0;\n    let x_widthL = 0;\n    let x_widthR = 0;\n    let last_line = null;\n    let last_note = null;\n    for (let i = 0; i < nums_list.length; ++i) {\n      const note = nums_list[i].note;\n      const pos = nums_list[i].pos;\n      const num = nums_list[i].num;\n      const line = nums_list[i].line;\n      const shiftR = nums_list[i].shiftR;\n      if (line !== last_line || note !== last_note) {\n        num_shiftR = right_shift + shiftR;\n      }\n      const num_width = num.getWidth() + num_spacing;\n      let num_x_shift = 0;\n      if (pos === Modifier.Position.LEFT) {\n        num.setXShift(left_shift + extraXSpaceForDisplacedNotehead);\n        num_x_shift = num_width;\n        x_widthL = Math.max(num_x_shift, x_widthL);\n      } else if (pos === Modifier.Position.RIGHT) {\n        num.setXShift(num_shiftR);\n        num_x_shift += num_width;\n        x_widthR = num_x_shift > x_widthR ? num_x_shift : x_widthR;\n      }\n      last_line = line;\n      last_note = note;\n    }\n    state.left_shift += x_widthL;\n    state.right_shift += x_widthR;\n    return true;\n  }\n  constructor(number) {\n    super();\n    this.string_number = number;\n    this.position = Modifier.Position.ABOVE;\n    this.x_shift = 0;\n    this.y_shift = 0;\n    this.text_line = 0;\n    this.stem_offset = 0;\n    this.x_offset = 0;\n    this.y_offset = 0;\n    this.dashed = true;\n    this.leg = Renderer.LineEndType.NONE;\n    this.radius = 8;\n    this.drawCircle = true;\n    this.setWidth(this.radius * 2 + 4);\n    this.resetFont();\n  }\n  setLineEndType(leg) {\n    if (leg >= Renderer.LineEndType.NONE && leg <= Renderer.LineEndType.DOWN) {\n      this.leg = leg;\n    }\n    return this;\n  }\n  setStringNumber(number) {\n    this.string_number = number;\n    return this;\n  }\n  setOffsetX(x) {\n    this.x_offset = x;\n    return this;\n  }\n  setOffsetY(y) {\n    this.y_offset = y;\n    return this;\n  }\n  setLastNote(note) {\n    this.last_note = note;\n    return this;\n  }\n  setDashed(dashed) {\n    this.dashed = dashed;\n    return this;\n  }\n  setDrawCircle(drawCircle) {\n    this.drawCircle = drawCircle;\n    return this;\n  }\n  draw() {\n    const ctx = this.checkContext();\n    const note = this.checkAttachedNote();\n    this.setRendered();\n    const start = note.getModifierStartXY(this.position, this.index);\n    const stemDirection = note.hasStem() ? note.getStemDirection() : Stem.UP;\n    let dot_x = start.x + this.x_shift + this.x_offset;\n    let stem_ext = {};\n    if (note.hasStem()) {\n      stem_ext = note.checkStem().getExtents();\n    }\n    let dot_y = start.y + this.y_shift + this.y_offset;\n    switch (this.position) {\n      case Modifier.Position.ABOVE:\n        {\n          const ys = note.getYs();\n          dot_y = ys.reduce((a, b) => a < b ? a : b);\n          if (note.hasStem() && stemDirection == Stem.UP) {\n            dot_y = stem_ext.topY + StringNumber.metrics.stemPadding;\n          }\n          dot_y -= this.radius + StringNumber.metrics.verticalPadding + this.text_line * Tables.STAVE_LINE_DISTANCE;\n        }\n        break;\n      case Modifier.Position.BELOW:\n        {\n          const ys = note.getYs();\n          dot_y = ys.reduce((a, b) => a > b ? a : b);\n          if (note.hasStem() && stemDirection == Stem.DOWN) {\n            dot_y = stem_ext.topY - StringNumber.metrics.stemPadding;\n          }\n          dot_y += this.radius + StringNumber.metrics.verticalPadding + this.text_line * Tables.STAVE_LINE_DISTANCE;\n        }\n        break;\n      case Modifier.Position.LEFT:\n        dot_x -= this.radius / 2 + StringNumber.metrics.leftPadding;\n        break;\n      case Modifier.Position.RIGHT:\n        dot_x += this.radius / 2 + StringNumber.metrics.rightPadding;\n        break;\n      default:\n        throw new RuntimeError('InvalidPosition', `The position ${this.position} is invalid`);\n    }\n    ctx.save();\n    if (this.drawCircle) {\n      ctx.beginPath();\n      ctx.arc(dot_x, dot_y, this.radius, 0, Math.PI * 2, false);\n      ctx.setLineWidth(1.5);\n      ctx.stroke();\n    }\n    ctx.setFont(this.textFont);\n    const x = dot_x - ctx.measureText(this.string_number).width / 2;\n    ctx.fillText('' + this.string_number, x, dot_y + 4.5);\n    const lastNote = this.last_note;\n    if (isStemmableNote(lastNote)) {\n      const end = lastNote.getStemX() - note.getX() + 5;\n      ctx.setStrokeStyle('#000000');\n      ctx.setLineCap('round');\n      ctx.setLineWidth(0.6);\n      if (this.dashed) {\n        Renderer.drawDashedLine(ctx, dot_x + 10, dot_y, dot_x + end, dot_y, [3, 3]);\n      } else {\n        Renderer.drawDashedLine(ctx, dot_x + 10, dot_y, dot_x + end, dot_y, [3, 0]);\n      }\n      let len;\n      let pattern;\n      switch (this.leg) {\n        case Renderer.LineEndType.UP:\n          len = -10;\n          pattern = this.dashed ? [3, 3] : [3, 0];\n          Renderer.drawDashedLine(ctx, dot_x + end, dot_y, dot_x + end, dot_y + len, pattern);\n          break;\n        case Renderer.LineEndType.DOWN:\n          len = 10;\n          pattern = this.dashed ? [3, 3] : [3, 0];\n          Renderer.drawDashedLine(ctx, dot_x + end, dot_y, dot_x + end, dot_y + len, pattern);\n          break;\n        default:\n          break;\n      }\n    }\n    ctx.restore();\n  }\n}\nStringNumber.TEXT_FONT = {\n  family: Font.SANS_SERIF,\n  size: Font.SIZE,\n  weight: FontWeight.BOLD,\n  style: FontStyle.NORMAL\n};\nexport { StringNumber };","map":{"version":3,"names":["Font","FontStyle","FontWeight","Modifier","ModifierPosition","Renderer","Stem","Tables","isStaveNote","isStemmableNote","RuntimeError","StringNumber","CATEGORY","metrics","_a","currentMusicFont","getMetrics","stringNumber","verticalPadding","stemPadding","leftPadding","rightPadding","format","nums","state","left_shift","right_shift","num_spacing","length","nums_list","prev_note","extraXSpaceForDisplacedNotehead","shift_right","modLines","i","num","note","getNote","pos","getPosition","index","checkIndex","props","getKeyProps","mc","getModifierContext","verticalSpaceNeeded","radius","STAVE_LINE_DISTANCE","ABOVE","text_line","getState","top_text_line","BELOW","n","keys","Position","LEFT","Math","max","getLeftDisplacedHeadPx","getRightDisplacedHeadPx","glyphLine","line","push","shiftL","shiftR","sort","a","b","num_shiftR","x_widthL","x_widthR","last_line","last_note","num_width","getWidth","num_x_shift","setXShift","RIGHT","constructor","number","string_number","position","x_shift","y_shift","stem_offset","x_offset","y_offset","dashed","leg","LineEndType","NONE","drawCircle","setWidth","resetFont","setLineEndType","DOWN","setStringNumber","setOffsetX","x","setOffsetY","y","setLastNote","setDashed","setDrawCircle","draw","ctx","checkContext","checkAttachedNote","setRendered","start","getModifierStartXY","stemDirection","hasStem","getStemDirection","UP","dot_x","stem_ext","checkStem","getExtents","dot_y","ys","getYs","reduce","topY","save","beginPath","arc","PI","setLineWidth","stroke","setFont","textFont","measureText","width","fillText","lastNote","end","getStemX","getX","setStrokeStyle","setLineCap","drawDashedLine","len","pattern","restore","TEXT_FONT","family","SANS_SERIF","size","SIZE","weight","BOLD","style","NORMAL"],"sources":["/Users/lang/Documents/code/Song2Notation/frontend/node_modules/vexflow/build/esm/src/stringnumber.js"],"sourcesContent":["import { Font, FontStyle, FontWeight } from './font.js';\nimport { Modifier, ModifierPosition } from './modifier.js';\nimport { Renderer } from './renderer.js';\nimport { Stem } from './stem.js';\nimport { Tables } from './tables.js';\nimport { isStaveNote, isStemmableNote } from './typeguard.js';\nimport { RuntimeError } from './util.js';\nclass StringNumber extends Modifier {\n    static get CATEGORY() {\n        return \"StringNumber\";\n    }\n    static get metrics() {\n        var _a;\n        return ((_a = Tables.currentMusicFont().getMetrics().stringNumber) !== null && _a !== void 0 ? _a : {\n            verticalPadding: 0,\n            stemPadding: 0,\n            leftPadding: 0,\n            rightPadding: 0,\n        });\n    }\n    static format(nums, state) {\n        const left_shift = state.left_shift;\n        const right_shift = state.right_shift;\n        const num_spacing = 1;\n        if (!nums || nums.length === 0)\n            return false;\n        const nums_list = [];\n        let prev_note = null;\n        let extraXSpaceForDisplacedNotehead = 0;\n        let shift_right = 0;\n        const modLines = 0;\n        for (let i = 0; i < nums.length; ++i) {\n            const num = nums[i];\n            const note = num.getNote();\n            const pos = num.getPosition();\n            if (!isStaveNote(note)) {\n                throw new RuntimeError('NoStaveNote');\n            }\n            const index = num.checkIndex();\n            const props = note.getKeyProps()[index];\n            const mc = note.getModifierContext();\n            const verticalSpaceNeeded = (num.radius * 2) / Tables.STAVE_LINE_DISTANCE + 0.5;\n            if (mc) {\n                if (pos === ModifierPosition.ABOVE) {\n                    num.text_line = mc.getState().top_text_line;\n                    state.top_text_line += verticalSpaceNeeded;\n                }\n                else if (pos === ModifierPosition.BELOW) {\n                    num.text_line = mc.getState().text_line;\n                    state.text_line += verticalSpaceNeeded;\n                }\n            }\n            if (note !== prev_note) {\n                for (let n = 0; n < note.keys.length; ++n) {\n                    if (pos === Modifier.Position.LEFT) {\n                        extraXSpaceForDisplacedNotehead = Math.max(note.getLeftDisplacedHeadPx(), extraXSpaceForDisplacedNotehead);\n                    }\n                    if (right_shift === 0) {\n                        shift_right = Math.max(note.getRightDisplacedHeadPx(), shift_right);\n                    }\n                }\n                prev_note = note;\n            }\n            const glyphLine = modLines === 0 ? props.line : modLines;\n            nums_list.push({\n                pos,\n                note,\n                num,\n                line: glyphLine,\n                shiftL: extraXSpaceForDisplacedNotehead,\n                shiftR: shift_right,\n            });\n        }\n        nums_list.sort((a, b) => b.line - a.line);\n        let num_shiftR = 0;\n        let x_widthL = 0;\n        let x_widthR = 0;\n        let last_line = null;\n        let last_note = null;\n        for (let i = 0; i < nums_list.length; ++i) {\n            const note = nums_list[i].note;\n            const pos = nums_list[i].pos;\n            const num = nums_list[i].num;\n            const line = nums_list[i].line;\n            const shiftR = nums_list[i].shiftR;\n            if (line !== last_line || note !== last_note) {\n                num_shiftR = right_shift + shiftR;\n            }\n            const num_width = num.getWidth() + num_spacing;\n            let num_x_shift = 0;\n            if (pos === Modifier.Position.LEFT) {\n                num.setXShift(left_shift + extraXSpaceForDisplacedNotehead);\n                num_x_shift = num_width;\n                x_widthL = Math.max(num_x_shift, x_widthL);\n            }\n            else if (pos === Modifier.Position.RIGHT) {\n                num.setXShift(num_shiftR);\n                num_x_shift += num_width;\n                x_widthR = num_x_shift > x_widthR ? num_x_shift : x_widthR;\n            }\n            last_line = line;\n            last_note = note;\n        }\n        state.left_shift += x_widthL;\n        state.right_shift += x_widthR;\n        return true;\n    }\n    constructor(number) {\n        super();\n        this.string_number = number;\n        this.position = Modifier.Position.ABOVE;\n        this.x_shift = 0;\n        this.y_shift = 0;\n        this.text_line = 0;\n        this.stem_offset = 0;\n        this.x_offset = 0;\n        this.y_offset = 0;\n        this.dashed = true;\n        this.leg = Renderer.LineEndType.NONE;\n        this.radius = 8;\n        this.drawCircle = true;\n        this.setWidth(this.radius * 2 + 4);\n        this.resetFont();\n    }\n    setLineEndType(leg) {\n        if (leg >= Renderer.LineEndType.NONE && leg <= Renderer.LineEndType.DOWN) {\n            this.leg = leg;\n        }\n        return this;\n    }\n    setStringNumber(number) {\n        this.string_number = number;\n        return this;\n    }\n    setOffsetX(x) {\n        this.x_offset = x;\n        return this;\n    }\n    setOffsetY(y) {\n        this.y_offset = y;\n        return this;\n    }\n    setLastNote(note) {\n        this.last_note = note;\n        return this;\n    }\n    setDashed(dashed) {\n        this.dashed = dashed;\n        return this;\n    }\n    setDrawCircle(drawCircle) {\n        this.drawCircle = drawCircle;\n        return this;\n    }\n    draw() {\n        const ctx = this.checkContext();\n        const note = this.checkAttachedNote();\n        this.setRendered();\n        const start = note.getModifierStartXY(this.position, this.index);\n        const stemDirection = note.hasStem() ? note.getStemDirection() : Stem.UP;\n        let dot_x = start.x + this.x_shift + this.x_offset;\n        let stem_ext = {};\n        if (note.hasStem()) {\n            stem_ext = note.checkStem().getExtents();\n        }\n        let dot_y = start.y + this.y_shift + this.y_offset;\n        switch (this.position) {\n            case Modifier.Position.ABOVE:\n                {\n                    const ys = note.getYs();\n                    dot_y = ys.reduce((a, b) => (a < b ? a : b));\n                    if (note.hasStem() && stemDirection == Stem.UP) {\n                        dot_y = stem_ext.topY + StringNumber.metrics.stemPadding;\n                    }\n                    dot_y -= this.radius + StringNumber.metrics.verticalPadding + this.text_line * Tables.STAVE_LINE_DISTANCE;\n                }\n                break;\n            case Modifier.Position.BELOW:\n                {\n                    const ys = note.getYs();\n                    dot_y = ys.reduce((a, b) => (a > b ? a : b));\n                    if (note.hasStem() && stemDirection == Stem.DOWN) {\n                        dot_y = stem_ext.topY - StringNumber.metrics.stemPadding;\n                    }\n                    dot_y += this.radius + StringNumber.metrics.verticalPadding + this.text_line * Tables.STAVE_LINE_DISTANCE;\n                }\n                break;\n            case Modifier.Position.LEFT:\n                dot_x -= this.radius / 2 + StringNumber.metrics.leftPadding;\n                break;\n            case Modifier.Position.RIGHT:\n                dot_x += this.radius / 2 + StringNumber.metrics.rightPadding;\n                break;\n            default:\n                throw new RuntimeError('InvalidPosition', `The position ${this.position} is invalid`);\n        }\n        ctx.save();\n        if (this.drawCircle) {\n            ctx.beginPath();\n            ctx.arc(dot_x, dot_y, this.radius, 0, Math.PI * 2, false);\n            ctx.setLineWidth(1.5);\n            ctx.stroke();\n        }\n        ctx.setFont(this.textFont);\n        const x = dot_x - ctx.measureText(this.string_number).width / 2;\n        ctx.fillText('' + this.string_number, x, dot_y + 4.5);\n        const lastNote = this.last_note;\n        if (isStemmableNote(lastNote)) {\n            const end = lastNote.getStemX() - note.getX() + 5;\n            ctx.setStrokeStyle('#000000');\n            ctx.setLineCap('round');\n            ctx.setLineWidth(0.6);\n            if (this.dashed) {\n                Renderer.drawDashedLine(ctx, dot_x + 10, dot_y, dot_x + end, dot_y, [3, 3]);\n            }\n            else {\n                Renderer.drawDashedLine(ctx, dot_x + 10, dot_y, dot_x + end, dot_y, [3, 0]);\n            }\n            let len;\n            let pattern;\n            switch (this.leg) {\n                case Renderer.LineEndType.UP:\n                    len = -10;\n                    pattern = this.dashed ? [3, 3] : [3, 0];\n                    Renderer.drawDashedLine(ctx, dot_x + end, dot_y, dot_x + end, dot_y + len, pattern);\n                    break;\n                case Renderer.LineEndType.DOWN:\n                    len = 10;\n                    pattern = this.dashed ? [3, 3] : [3, 0];\n                    Renderer.drawDashedLine(ctx, dot_x + end, dot_y, dot_x + end, dot_y + len, pattern);\n                    break;\n                default:\n                    break;\n            }\n        }\n        ctx.restore();\n    }\n}\nStringNumber.TEXT_FONT = {\n    family: Font.SANS_SERIF,\n    size: Font.SIZE,\n    weight: FontWeight.BOLD,\n    style: FontStyle.NORMAL,\n};\nexport { StringNumber };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}