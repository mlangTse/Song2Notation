{"ast":null,"code":"import { Glyph } from './glyph.js';\nimport { Modifier } from './modifier.js';\nimport { Stem } from './stem.js';\nimport { Tables } from './tables.js';\nimport { isTabNote } from './typeguard.js';\nimport { defined, log, RuntimeError } from './util.js';\nfunction L() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  if (Ornament.DEBUG) log('Vex.Flow.Ornament', args);\n}\nclass Ornament extends Modifier {\n  static get CATEGORY() {\n    return \"Ornament\";\n  }\n  static get minPadding() {\n    const musicFont = Tables.currentMusicFont();\n    return musicFont.lookupMetric('noteHead.minPadding');\n  }\n  static format(ornaments, state) {\n    if (!ornaments || ornaments.length === 0) return false;\n    let width = 0;\n    let right_shift = state.right_shift;\n    let left_shift = state.left_shift;\n    let yOffset = 0;\n    for (let i = 0; i < ornaments.length; ++i) {\n      const ornament = ornaments[i];\n      const increment = 2;\n      if (Ornament.ornamentRelease.indexOf(ornament.type) >= 0) {\n        ornament.x_shift += right_shift + 2;\n      }\n      if (Ornament.ornamentAttack.indexOf(ornament.type) >= 0) {\n        ornament.x_shift -= left_shift + 2;\n      }\n      if (ornament.reportedWidth && ornament.x_shift < 0) {\n        left_shift += ornament.reportedWidth;\n      } else if (ornament.reportedWidth && ornament.x_shift >= 0) {\n        right_shift += ornament.reportedWidth + Ornament.minPadding;\n      } else {\n        width = Math.max(ornament.getWidth(), width);\n      }\n      if (Ornament.ornamentArticulation.indexOf(ornament.type) >= 0) {\n        const ornamentNote = defined(ornament.note, 'NoAttachedNote');\n        if (ornamentNote.getLineNumber() >= 3 || ornament.getPosition() === Modifier.Position.ABOVE) {\n          state.top_text_line += increment;\n          ornament.y_shift += yOffset;\n          yOffset -= ornament.glyph.bbox.getH();\n        } else {\n          state.text_line += increment;\n          ornament.y_shift += yOffset;\n          yOffset += ornament.glyph.bbox.getH();\n        }\n      } else {\n        if (ornament.getPosition() === Modifier.Position.ABOVE) {\n          ornament.setTextLine(state.top_text_line);\n          state.top_text_line += increment;\n        } else {\n          ornament.setTextLine(state.text_line);\n          state.text_line += increment;\n        }\n      }\n    }\n    state.left_shift = left_shift + width / 2;\n    state.right_shift = right_shift + width / 2;\n    return true;\n  }\n  static get ornamentNoteTransition() {\n    return ['flip', 'jazzTurn', 'smear'];\n  }\n  static get ornamentAttack() {\n    return ['scoop'];\n  }\n  static get ornamentAlignWithNoteHead() {\n    return ['doit', 'fall', 'fallLong', 'doitLong', 'bend', 'plungerClosed', 'plungerOpen', 'scoop'];\n  }\n  static get ornamentRelease() {\n    return ['doit', 'fall', 'fallLong', 'doitLong', 'jazzTurn', 'smear', 'flip'];\n  }\n  static get ornamentArticulation() {\n    return ['bend', 'plungerClosed', 'plungerOpen'];\n  }\n  getMetrics() {\n    const ornamentMetrics = Tables.currentMusicFont().getMetrics().ornament;\n    if (!ornamentMetrics) throw new RuntimeError('BadMetrics', `ornament missing`);\n    return ornamentMetrics[this.ornament.code];\n  }\n  constructor(type) {\n    super();\n    this.type = type;\n    this.delayed = false;\n    this.render_options = {\n      font_scale: Tables.NOTATION_FONT_SCALE,\n      accidentalLowerPadding: 3,\n      accidentalUpperPadding: 3\n    };\n    this.ornament = Tables.ornamentCodes(this.type);\n    const metrics = this.getMetrics();\n    this.adjustForStemDirection = false;\n    this.reportedWidth = metrics && metrics.reportedWidth ? metrics.reportedWidth : 0;\n    this.stemUpYOffset = metrics && metrics.stemUpYOffset ? metrics.stemUpYOffset : 0;\n    this.ornamentAlignWithNoteHead = Ornament.ornamentAlignWithNoteHead.indexOf(this.type) >= 0;\n    if (!this.ornament) {\n      throw new RuntimeError('ArgumentError', `Ornament not found: '${this.type}'`);\n    }\n    this.x_shift = metrics ? metrics.xOffset : 0;\n    this.y_shift = metrics ? metrics.yOffset : 0;\n    this.glyph = new Glyph(this.ornament.code, this.render_options.font_scale, {\n      category: `ornament.${this.ornament.code}`\n    });\n    if (Ornament.ornamentNoteTransition.indexOf(this.type) >= 0) {\n      this.delayed = true;\n    }\n    if (!metrics) {\n      this.glyph.setOrigin(0.5, 1.0);\n    }\n  }\n  setDelayed(delayed) {\n    this.delayed = delayed;\n    return this;\n  }\n  setUpperAccidental(accid) {\n    const scale = this.render_options.font_scale / 1.3;\n    this.accidentalUpper = new Glyph(Tables.accidentalCodes(accid).code, scale);\n    this.accidentalUpper.setOrigin(0.5, 1.0);\n    return this;\n  }\n  setLowerAccidental(accid) {\n    const scale = this.render_options.font_scale / 1.3;\n    this.accidentalLower = new Glyph(Tables.accidentalCodes(accid).code, scale);\n    this.accidentalLower.setOrigin(0.5, 1.0);\n    return this;\n  }\n  draw() {\n    const ctx = this.checkContext();\n    const note = this.checkAttachedNote();\n    this.setRendered();\n    const stemDir = note.getStemDirection();\n    const stave = note.checkStave();\n    this.applyStyle();\n    ctx.openGroup('ornament', this.getAttribute('id'));\n    const stemExtents = note.checkStem().getExtents();\n    let y = stemDir === Stem.DOWN ? stemExtents.baseY : stemExtents.topY;\n    if (isTabNote(note)) {\n      if (note.hasStem()) {\n        if (stemDir === Stem.DOWN) {\n          y = stave.getYForTopText(this.text_line);\n        }\n      } else {\n        y = stave.getYForTopText(this.text_line);\n      }\n    }\n    const isPlacedOnNoteheadSide = stemDir === Stem.DOWN;\n    const spacing = stave.getSpacingBetweenLines();\n    let lineSpacing = 1;\n    if (!isPlacedOnNoteheadSide && note.hasBeam()) {\n      lineSpacing += 0.5;\n    }\n    const totalSpacing = spacing * (this.text_line + lineSpacing);\n    const glyphYBetweenLines = y - totalSpacing;\n    const start = note.getModifierStartXY(this.position, this.index);\n    let glyphX = start.x;\n    let glyphY = this.ornamentAlignWithNoteHead ? start.y : Math.min(stave.getYForTopText(this.text_line), glyphYBetweenLines);\n    glyphY += this.y_shift;\n    if (this.delayed) {\n      let delayXShift = 0;\n      const startX = glyphX - stave.getNoteStartX();\n      if (this.delayXShift !== undefined) {\n        delayXShift = this.delayXShift;\n      } else {\n        delayXShift += this.glyph.getMetrics().width / 2;\n        const tickables = note.getVoice().getTickables();\n        const index = tickables.indexOf(note);\n        const nextContext = index + 1 < tickables.length ? tickables[index + 1].checkTickContext() : undefined;\n        if (nextContext) {\n          delayXShift += (nextContext.getX() - startX) * 0.5;\n        } else {\n          delayXShift += (stave.getX() + stave.getWidth() - glyphX) * 0.5;\n        }\n        this.delayXShift = delayXShift;\n      }\n      glyphX += delayXShift;\n    }\n    L('Rendering ornament: ', this.ornament, glyphX, glyphY);\n    if (this.accidentalLower) {\n      this.accidentalLower.render(ctx, glyphX, glyphY);\n      glyphY -= this.accidentalLower.getMetrics().height;\n      glyphY -= this.render_options.accidentalLowerPadding;\n    }\n    if (this.stemUpYOffset && note.hasStem() && note.getStemDirection() === 1) {\n      glyphY += this.stemUpYOffset;\n    }\n    if (note.getLineNumber() < 5 && Ornament.ornamentNoteTransition.indexOf(this.type) >= 0) {\n      glyphY = note.checkStave().getBoundingBox().getY() + 40;\n    }\n    this.glyph.render(ctx, glyphX + this.x_shift, glyphY);\n    if (this.accidentalUpper) {\n      glyphY -= this.glyph.getMetrics().height + this.render_options.accidentalUpperPadding;\n      this.accidentalUpper.render(ctx, glyphX, glyphY);\n    }\n    ctx.closeGroup();\n    this.restoreStyle();\n  }\n}\nOrnament.DEBUG = false;\nexport { Ornament };","map":{"version":3,"names":["Glyph","Modifier","Stem","Tables","isTabNote","defined","log","RuntimeError","L","_len","arguments","length","args","Array","_key","Ornament","DEBUG","CATEGORY","minPadding","musicFont","currentMusicFont","lookupMetric","format","ornaments","state","width","right_shift","left_shift","yOffset","i","ornament","increment","ornamentRelease","indexOf","type","x_shift","ornamentAttack","reportedWidth","Math","max","getWidth","ornamentArticulation","ornamentNote","note","getLineNumber","getPosition","Position","ABOVE","top_text_line","y_shift","glyph","bbox","getH","text_line","setTextLine","ornamentNoteTransition","ornamentAlignWithNoteHead","getMetrics","ornamentMetrics","code","constructor","delayed","render_options","font_scale","NOTATION_FONT_SCALE","accidentalLowerPadding","accidentalUpperPadding","ornamentCodes","metrics","adjustForStemDirection","stemUpYOffset","xOffset","category","setOrigin","setDelayed","setUpperAccidental","accid","scale","accidentalUpper","accidentalCodes","setLowerAccidental","accidentalLower","draw","ctx","checkContext","checkAttachedNote","setRendered","stemDir","getStemDirection","stave","checkStave","applyStyle","openGroup","getAttribute","stemExtents","checkStem","getExtents","y","DOWN","baseY","topY","hasStem","getYForTopText","isPlacedOnNoteheadSide","spacing","getSpacingBetweenLines","lineSpacing","hasBeam","totalSpacing","glyphYBetweenLines","start","getModifierStartXY","position","index","glyphX","x","glyphY","min","delayXShift","startX","getNoteStartX","undefined","tickables","getVoice","getTickables","nextContext","checkTickContext","getX","render","height","getBoundingBox","getY","closeGroup","restoreStyle"],"sources":["/Users/lang/Documents/code/Song2Notation/frontend/node_modules/vexflow/build/esm/src/ornament.js"],"sourcesContent":["import { Glyph } from './glyph.js';\nimport { Modifier } from './modifier.js';\nimport { Stem } from './stem.js';\nimport { Tables } from './tables.js';\nimport { isTabNote } from './typeguard.js';\nimport { defined, log, RuntimeError } from './util.js';\nfunction L(...args) {\n    if (Ornament.DEBUG)\n        log('Vex.Flow.Ornament', args);\n}\nclass Ornament extends Modifier {\n    static get CATEGORY() {\n        return \"Ornament\";\n    }\n    static get minPadding() {\n        const musicFont = Tables.currentMusicFont();\n        return musicFont.lookupMetric('noteHead.minPadding');\n    }\n    static format(ornaments, state) {\n        if (!ornaments || ornaments.length === 0)\n            return false;\n        let width = 0;\n        let right_shift = state.right_shift;\n        let left_shift = state.left_shift;\n        let yOffset = 0;\n        for (let i = 0; i < ornaments.length; ++i) {\n            const ornament = ornaments[i];\n            const increment = 2;\n            if (Ornament.ornamentRelease.indexOf(ornament.type) >= 0) {\n                ornament.x_shift += right_shift + 2;\n            }\n            if (Ornament.ornamentAttack.indexOf(ornament.type) >= 0) {\n                ornament.x_shift -= left_shift + 2;\n            }\n            if (ornament.reportedWidth && ornament.x_shift < 0) {\n                left_shift += ornament.reportedWidth;\n            }\n            else if (ornament.reportedWidth && ornament.x_shift >= 0) {\n                right_shift += ornament.reportedWidth + Ornament.minPadding;\n            }\n            else {\n                width = Math.max(ornament.getWidth(), width);\n            }\n            if (Ornament.ornamentArticulation.indexOf(ornament.type) >= 0) {\n                const ornamentNote = defined(ornament.note, 'NoAttachedNote');\n                if (ornamentNote.getLineNumber() >= 3 || ornament.getPosition() === Modifier.Position.ABOVE) {\n                    state.top_text_line += increment;\n                    ornament.y_shift += yOffset;\n                    yOffset -= ornament.glyph.bbox.getH();\n                }\n                else {\n                    state.text_line += increment;\n                    ornament.y_shift += yOffset;\n                    yOffset += ornament.glyph.bbox.getH();\n                }\n            }\n            else {\n                if (ornament.getPosition() === Modifier.Position.ABOVE) {\n                    ornament.setTextLine(state.top_text_line);\n                    state.top_text_line += increment;\n                }\n                else {\n                    ornament.setTextLine(state.text_line);\n                    state.text_line += increment;\n                }\n            }\n        }\n        state.left_shift = left_shift + width / 2;\n        state.right_shift = right_shift + width / 2;\n        return true;\n    }\n    static get ornamentNoteTransition() {\n        return ['flip', 'jazzTurn', 'smear'];\n    }\n    static get ornamentAttack() {\n        return ['scoop'];\n    }\n    static get ornamentAlignWithNoteHead() {\n        return ['doit', 'fall', 'fallLong', 'doitLong', 'bend', 'plungerClosed', 'plungerOpen', 'scoop'];\n    }\n    static get ornamentRelease() {\n        return ['doit', 'fall', 'fallLong', 'doitLong', 'jazzTurn', 'smear', 'flip'];\n    }\n    static get ornamentArticulation() {\n        return ['bend', 'plungerClosed', 'plungerOpen'];\n    }\n    getMetrics() {\n        const ornamentMetrics = Tables.currentMusicFont().getMetrics().ornament;\n        if (!ornamentMetrics)\n            throw new RuntimeError('BadMetrics', `ornament missing`);\n        return ornamentMetrics[this.ornament.code];\n    }\n    constructor(type) {\n        super();\n        this.type = type;\n        this.delayed = false;\n        this.render_options = {\n            font_scale: Tables.NOTATION_FONT_SCALE,\n            accidentalLowerPadding: 3,\n            accidentalUpperPadding: 3,\n        };\n        this.ornament = Tables.ornamentCodes(this.type);\n        const metrics = this.getMetrics();\n        this.adjustForStemDirection = false;\n        this.reportedWidth = metrics && metrics.reportedWidth ? metrics.reportedWidth : 0;\n        this.stemUpYOffset = metrics && metrics.stemUpYOffset ? metrics.stemUpYOffset : 0;\n        this.ornamentAlignWithNoteHead = Ornament.ornamentAlignWithNoteHead.indexOf(this.type) >= 0;\n        if (!this.ornament) {\n            throw new RuntimeError('ArgumentError', `Ornament not found: '${this.type}'`);\n        }\n        this.x_shift = metrics ? metrics.xOffset : 0;\n        this.y_shift = metrics ? metrics.yOffset : 0;\n        this.glyph = new Glyph(this.ornament.code, this.render_options.font_scale, {\n            category: `ornament.${this.ornament.code}`,\n        });\n        if (Ornament.ornamentNoteTransition.indexOf(this.type) >= 0) {\n            this.delayed = true;\n        }\n        if (!metrics) {\n            this.glyph.setOrigin(0.5, 1.0);\n        }\n    }\n    setDelayed(delayed) {\n        this.delayed = delayed;\n        return this;\n    }\n    setUpperAccidental(accid) {\n        const scale = this.render_options.font_scale / 1.3;\n        this.accidentalUpper = new Glyph(Tables.accidentalCodes(accid).code, scale);\n        this.accidentalUpper.setOrigin(0.5, 1.0);\n        return this;\n    }\n    setLowerAccidental(accid) {\n        const scale = this.render_options.font_scale / 1.3;\n        this.accidentalLower = new Glyph(Tables.accidentalCodes(accid).code, scale);\n        this.accidentalLower.setOrigin(0.5, 1.0);\n        return this;\n    }\n    draw() {\n        const ctx = this.checkContext();\n        const note = this.checkAttachedNote();\n        this.setRendered();\n        const stemDir = note.getStemDirection();\n        const stave = note.checkStave();\n        this.applyStyle();\n        ctx.openGroup('ornament', this.getAttribute('id'));\n        const stemExtents = note.checkStem().getExtents();\n        let y = stemDir === Stem.DOWN ? stemExtents.baseY : stemExtents.topY;\n        if (isTabNote(note)) {\n            if (note.hasStem()) {\n                if (stemDir === Stem.DOWN) {\n                    y = stave.getYForTopText(this.text_line);\n                }\n            }\n            else {\n                y = stave.getYForTopText(this.text_line);\n            }\n        }\n        const isPlacedOnNoteheadSide = stemDir === Stem.DOWN;\n        const spacing = stave.getSpacingBetweenLines();\n        let lineSpacing = 1;\n        if (!isPlacedOnNoteheadSide && note.hasBeam()) {\n            lineSpacing += 0.5;\n        }\n        const totalSpacing = spacing * (this.text_line + lineSpacing);\n        const glyphYBetweenLines = y - totalSpacing;\n        const start = note.getModifierStartXY(this.position, this.index);\n        let glyphX = start.x;\n        let glyphY = this.ornamentAlignWithNoteHead\n            ? start.y\n            : Math.min(stave.getYForTopText(this.text_line), glyphYBetweenLines);\n        glyphY += this.y_shift;\n        if (this.delayed) {\n            let delayXShift = 0;\n            const startX = glyphX - stave.getNoteStartX();\n            if (this.delayXShift !== undefined) {\n                delayXShift = this.delayXShift;\n            }\n            else {\n                delayXShift += this.glyph.getMetrics().width / 2;\n                const tickables = note.getVoice().getTickables();\n                const index = tickables.indexOf(note);\n                const nextContext = index + 1 < tickables.length ? tickables[index + 1].checkTickContext() : undefined;\n                if (nextContext) {\n                    delayXShift += (nextContext.getX() - startX) * 0.5;\n                }\n                else {\n                    delayXShift += (stave.getX() + stave.getWidth() - glyphX) * 0.5;\n                }\n                this.delayXShift = delayXShift;\n            }\n            glyphX += delayXShift;\n        }\n        L('Rendering ornament: ', this.ornament, glyphX, glyphY);\n        if (this.accidentalLower) {\n            this.accidentalLower.render(ctx, glyphX, glyphY);\n            glyphY -= this.accidentalLower.getMetrics().height;\n            glyphY -= this.render_options.accidentalLowerPadding;\n        }\n        if (this.stemUpYOffset && note.hasStem() && note.getStemDirection() === 1) {\n            glyphY += this.stemUpYOffset;\n        }\n        if (note.getLineNumber() < 5 && Ornament.ornamentNoteTransition.indexOf(this.type) >= 0) {\n            glyphY = note.checkStave().getBoundingBox().getY() + 40;\n        }\n        this.glyph.render(ctx, glyphX + this.x_shift, glyphY);\n        if (this.accidentalUpper) {\n            glyphY -= this.glyph.getMetrics().height + this.render_options.accidentalUpperPadding;\n            this.accidentalUpper.render(ctx, glyphX, glyphY);\n        }\n        ctx.closeGroup();\n        this.restoreStyle();\n    }\n}\nOrnament.DEBUG = false;\nexport { Ornament };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}