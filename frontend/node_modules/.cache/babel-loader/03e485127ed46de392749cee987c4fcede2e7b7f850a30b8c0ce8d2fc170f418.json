{"ast":null,"code":"import { Modifier } from './modifier.js';\nimport { isGraceNote, isStaveNote, isTabNote } from './typeguard.js';\nimport { RuntimeError } from './util.js';\nexport class Dot extends Modifier {\n  static get CATEGORY() {\n    return \"Dot\";\n  }\n  static getDots(note) {\n    return note.getModifiersByType(Dot.CATEGORY);\n  }\n  static buildAndAttach(notes, options) {\n    for (const note of notes) {\n      if (options === null || options === void 0 ? void 0 : options.all) {\n        for (let i = 0; i < note.keys.length; i++) {\n          const dot = new Dot();\n          dot.setDotShiftY(note.glyphProps.dot_shiftY);\n          note.addModifier(dot, i);\n        }\n      } else if ((options === null || options === void 0 ? void 0 : options.index) != undefined) {\n        const dot = new Dot();\n        dot.setDotShiftY(note.glyphProps.dot_shiftY);\n        note.addModifier(dot, options === null || options === void 0 ? void 0 : options.index);\n      } else {\n        const dot = new Dot();\n        dot.setDotShiftY(note.glyphProps.dot_shiftY);\n        note.addModifier(dot, 0);\n      }\n    }\n  }\n  static format(dots, state) {\n    const right_shift = state.right_shift;\n    const dot_spacing = 1;\n    if (!dots || dots.length === 0) return false;\n    const dot_list = [];\n    const max_shift_map = {};\n    for (let i = 0; i < dots.length; ++i) {\n      const dot = dots[i];\n      const note = dot.getNote();\n      let props;\n      let shift;\n      if (isStaveNote(note)) {\n        const index = dot.checkIndex();\n        props = note.getKeyProps()[index];\n        shift = note.getFirstDotPx();\n      } else if (isTabNote(note)) {\n        props = {\n          line: 0.5\n        };\n        shift = right_shift;\n      } else {\n        throw new RuntimeError('Internal', 'Unexpected instance.');\n      }\n      const note_id = note.getAttribute('id');\n      dot_list.push({\n        line: props.line,\n        note,\n        note_id,\n        dot\n      });\n      max_shift_map[note_id] = Math.max(max_shift_map[note_id] || shift, shift);\n    }\n    dot_list.sort((a, b) => b.line - a.line);\n    let dot_shift = right_shift;\n    let x_width = 0;\n    let last_line = null;\n    let last_note = null;\n    let prev_dotted_space = null;\n    let half_shiftY = 0;\n    for (let i = 0; i < dot_list.length; ++i) {\n      const {\n        dot,\n        note,\n        note_id,\n        line\n      } = dot_list[i];\n      if (line !== last_line || note !== last_note) {\n        dot_shift = max_shift_map[note_id];\n      }\n      if (!note.isRest() && line !== last_line) {\n        if (Math.abs(line % 1) === 0.5) {\n          half_shiftY = 0;\n        } else {\n          half_shiftY = 0.5;\n          if (last_note != null && !last_note.isRest() && last_line != null && last_line - line === 0.5) {\n            half_shiftY = -0.5;\n          } else if (line + half_shiftY === prev_dotted_space) {\n            half_shiftY = -0.5;\n          }\n        }\n      }\n      if (note.isRest()) {\n        dot.dot_shiftY += -half_shiftY;\n      } else {\n        dot.dot_shiftY = -half_shiftY;\n      }\n      prev_dotted_space = line + half_shiftY;\n      dot.setXShift(dot_shift);\n      dot_shift += dot.getWidth() + dot_spacing;\n      x_width = dot_shift > x_width ? dot_shift : x_width;\n      last_line = line;\n      last_note = note;\n    }\n    state.right_shift += x_width;\n    return true;\n  }\n  constructor() {\n    super();\n    this.position = Modifier.Position.RIGHT;\n    this.radius = 2;\n    this.setWidth(5);\n    this.dot_shiftY = 0;\n  }\n  setNote(note) {\n    this.note = note;\n    if (isGraceNote(note)) {\n      this.radius *= 0.5;\n      this.setWidth(3);\n    }\n    return this;\n  }\n  setDotShiftY(y) {\n    this.dot_shiftY = y;\n    return this;\n  }\n  draw() {\n    const ctx = this.checkContext();\n    const note = this.checkAttachedNote();\n    this.setRendered();\n    const stave = note.checkStave();\n    const lineSpace = stave.getSpacingBetweenLines();\n    const start = note.getModifierStartXY(this.position, this.index, {\n      forceFlagRight: true\n    });\n    if (isTabNote(note)) {\n      start.y = note.getStemExtents().baseY;\n    }\n    const x = start.x + this.x_shift + this.width - this.radius;\n    const y = start.y + this.y_shift + this.dot_shiftY * lineSpace;\n    ctx.beginPath();\n    ctx.arc(x, y, this.radius, 0, Math.PI * 2, false);\n    ctx.fill();\n  }\n}","map":{"version":3,"names":["Modifier","isGraceNote","isStaveNote","isTabNote","RuntimeError","Dot","CATEGORY","getDots","note","getModifiersByType","buildAndAttach","notes","options","all","i","keys","length","dot","setDotShiftY","glyphProps","dot_shiftY","addModifier","index","undefined","format","dots","state","right_shift","dot_spacing","dot_list","max_shift_map","getNote","props","shift","checkIndex","getKeyProps","getFirstDotPx","line","note_id","getAttribute","push","Math","max","sort","a","b","dot_shift","x_width","last_line","last_note","prev_dotted_space","half_shiftY","isRest","abs","setXShift","getWidth","constructor","position","Position","RIGHT","radius","setWidth","setNote","y","draw","ctx","checkContext","checkAttachedNote","setRendered","stave","checkStave","lineSpace","getSpacingBetweenLines","start","getModifierStartXY","forceFlagRight","getStemExtents","baseY","x","x_shift","width","y_shift","beginPath","arc","PI","fill"],"sources":["/Users/lang/Documents/code/Song2Notation/frontend/node_modules/vexflow/build/esm/src/dot.js"],"sourcesContent":["import { Modifier } from './modifier.js';\nimport { isGraceNote, isStaveNote, isTabNote } from './typeguard.js';\nimport { RuntimeError } from './util.js';\nexport class Dot extends Modifier {\n    static get CATEGORY() {\n        return \"Dot\";\n    }\n    static getDots(note) {\n        return note.getModifiersByType(Dot.CATEGORY);\n    }\n    static buildAndAttach(notes, options) {\n        for (const note of notes) {\n            if (options === null || options === void 0 ? void 0 : options.all) {\n                for (let i = 0; i < note.keys.length; i++) {\n                    const dot = new Dot();\n                    dot.setDotShiftY(note.glyphProps.dot_shiftY);\n                    note.addModifier(dot, i);\n                }\n            }\n            else if ((options === null || options === void 0 ? void 0 : options.index) != undefined) {\n                const dot = new Dot();\n                dot.setDotShiftY(note.glyphProps.dot_shiftY);\n                note.addModifier(dot, options === null || options === void 0 ? void 0 : options.index);\n            }\n            else {\n                const dot = new Dot();\n                dot.setDotShiftY(note.glyphProps.dot_shiftY);\n                note.addModifier(dot, 0);\n            }\n        }\n    }\n    static format(dots, state) {\n        const right_shift = state.right_shift;\n        const dot_spacing = 1;\n        if (!dots || dots.length === 0)\n            return false;\n        const dot_list = [];\n        const max_shift_map = {};\n        for (let i = 0; i < dots.length; ++i) {\n            const dot = dots[i];\n            const note = dot.getNote();\n            let props;\n            let shift;\n            if (isStaveNote(note)) {\n                const index = dot.checkIndex();\n                props = note.getKeyProps()[index];\n                shift = note.getFirstDotPx();\n            }\n            else if (isTabNote(note)) {\n                props = { line: 0.5 };\n                shift = right_shift;\n            }\n            else {\n                throw new RuntimeError('Internal', 'Unexpected instance.');\n            }\n            const note_id = note.getAttribute('id');\n            dot_list.push({ line: props.line, note, note_id, dot });\n            max_shift_map[note_id] = Math.max(max_shift_map[note_id] || shift, shift);\n        }\n        dot_list.sort((a, b) => b.line - a.line);\n        let dot_shift = right_shift;\n        let x_width = 0;\n        let last_line = null;\n        let last_note = null;\n        let prev_dotted_space = null;\n        let half_shiftY = 0;\n        for (let i = 0; i < dot_list.length; ++i) {\n            const { dot, note, note_id, line } = dot_list[i];\n            if (line !== last_line || note !== last_note) {\n                dot_shift = max_shift_map[note_id];\n            }\n            if (!note.isRest() && line !== last_line) {\n                if (Math.abs(line % 1) === 0.5) {\n                    half_shiftY = 0;\n                }\n                else {\n                    half_shiftY = 0.5;\n                    if (last_note != null && !last_note.isRest() && last_line != null && last_line - line === 0.5) {\n                        half_shiftY = -0.5;\n                    }\n                    else if (line + half_shiftY === prev_dotted_space) {\n                        half_shiftY = -0.5;\n                    }\n                }\n            }\n            if (note.isRest()) {\n                dot.dot_shiftY += -half_shiftY;\n            }\n            else {\n                dot.dot_shiftY = -half_shiftY;\n            }\n            prev_dotted_space = line + half_shiftY;\n            dot.setXShift(dot_shift);\n            dot_shift += dot.getWidth() + dot_spacing;\n            x_width = dot_shift > x_width ? dot_shift : x_width;\n            last_line = line;\n            last_note = note;\n        }\n        state.right_shift += x_width;\n        return true;\n    }\n    constructor() {\n        super();\n        this.position = Modifier.Position.RIGHT;\n        this.radius = 2;\n        this.setWidth(5);\n        this.dot_shiftY = 0;\n    }\n    setNote(note) {\n        this.note = note;\n        if (isGraceNote(note)) {\n            this.radius *= 0.5;\n            this.setWidth(3);\n        }\n        return this;\n    }\n    setDotShiftY(y) {\n        this.dot_shiftY = y;\n        return this;\n    }\n    draw() {\n        const ctx = this.checkContext();\n        const note = this.checkAttachedNote();\n        this.setRendered();\n        const stave = note.checkStave();\n        const lineSpace = stave.getSpacingBetweenLines();\n        const start = note.getModifierStartXY(this.position, this.index, { forceFlagRight: true });\n        if (isTabNote(note)) {\n            start.y = note.getStemExtents().baseY;\n        }\n        const x = start.x + this.x_shift + this.width - this.radius;\n        const y = start.y + this.y_shift + this.dot_shiftY * lineSpace;\n        ctx.beginPath();\n        ctx.arc(x, y, this.radius, 0, Math.PI * 2, false);\n        ctx.fill();\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}