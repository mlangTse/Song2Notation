{"ast":null,"code":"import { Font, FontStyle, FontWeight } from './font.js';\nimport { Modifier, ModifierPosition } from './modifier.js';\nimport { Tables } from './tables.js';\nimport { TextFormatter } from './textformatter.js';\nimport { RuntimeError } from './util.js';\nclass FretHandFinger extends Modifier {\n  static get CATEGORY() {\n    return \"FretHandFinger\";\n  }\n  static format(nums, state) {\n    const {\n      left_shift,\n      right_shift\n    } = state;\n    const num_spacing = 1;\n    if (!nums || nums.length === 0) return false;\n    const nums_list = [];\n    let prev_note = null;\n    let shiftLeft = 0;\n    let shiftRight = 0;\n    for (let i = 0; i < nums.length; ++i) {\n      const num = nums[i];\n      const note = num.getNote();\n      const pos = num.getPosition();\n      const index = num.checkIndex();\n      const props = note.getKeyProps()[index];\n      const textFormatter = TextFormatter.create(num.textFont);\n      const textHeight = textFormatter.maxHeight;\n      if (num.position === ModifierPosition.ABOVE) {\n        state.top_text_line += textHeight / Tables.STAVE_LINE_DISTANCE + 0.5;\n      }\n      if (num.position === ModifierPosition.BELOW) {\n        state.text_line += textHeight / Tables.STAVE_LINE_DISTANCE + 0.5;\n      }\n      if (note !== prev_note) {\n        for (let n = 0; n < note.keys.length; ++n) {\n          if (left_shift === 0) {\n            shiftLeft = Math.max(note.getLeftDisplacedHeadPx(), shiftLeft);\n          }\n          if (right_shift === 0) {\n            shiftRight = Math.max(note.getRightDisplacedHeadPx(), shiftRight);\n          }\n        }\n        prev_note = note;\n      }\n      nums_list.push({\n        note,\n        num,\n        pos,\n        line: props.line,\n        shiftL: shiftLeft,\n        shiftR: shiftRight\n      });\n    }\n    nums_list.sort((a, b) => b.line - a.line);\n    let numShiftL = 0;\n    let numShiftR = 0;\n    let xWidthL = 0;\n    let xWidthR = 0;\n    let lastLine = null;\n    let lastNote = null;\n    for (let i = 0; i < nums_list.length; ++i) {\n      let num_shift = 0;\n      const {\n        note,\n        pos,\n        num,\n        line,\n        shiftL,\n        shiftR\n      } = nums_list[i];\n      if (line !== lastLine || note !== lastNote) {\n        numShiftL = left_shift + shiftL;\n        numShiftR = right_shift + shiftR;\n      }\n      const numWidth = num.getWidth() + num_spacing;\n      if (pos === Modifier.Position.LEFT) {\n        num.setXShift(left_shift + numShiftL);\n        num_shift = left_shift + numWidth;\n        xWidthL = num_shift > xWidthL ? num_shift : xWidthL;\n      } else if (pos === Modifier.Position.RIGHT) {\n        num.setXShift(numShiftR);\n        num_shift = shiftRight + numWidth;\n        xWidthR = num_shift > xWidthR ? num_shift : xWidthR;\n      }\n      lastLine = line;\n      lastNote = note;\n    }\n    state.left_shift += xWidthL;\n    state.right_shift += xWidthR;\n    return true;\n  }\n  static easyScoreHook() {\n    let {\n      fingerings\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let note = arguments.length > 1 ? arguments[1] : undefined;\n    let builder = arguments.length > 2 ? arguments[2] : undefined;\n    fingerings === null || fingerings === void 0 ? void 0 : fingerings.split(',').map(fingeringString => {\n      const split = fingeringString.trim().split('.');\n      const params = {\n        number: split[0]\n      };\n      if (split[1]) params.position = split[1];\n      return builder.getFactory().Fingering(params);\n    }).map((fingering, index) => note.addModifier(fingering, index));\n  }\n  constructor(finger) {\n    super();\n    this.finger = finger;\n    this.width = 7;\n    this.position = Modifier.Position.LEFT;\n    this.x_shift = 0;\n    this.y_shift = 0;\n    this.x_offset = 0;\n    this.y_offset = 0;\n    this.resetFont();\n  }\n  setFretHandFinger(finger) {\n    this.finger = finger;\n    return this;\n  }\n  getFretHandFinger() {\n    return this.finger;\n  }\n  setOffsetX(x) {\n    this.x_offset = x;\n    return this;\n  }\n  setOffsetY(y) {\n    this.y_offset = y;\n    return this;\n  }\n  draw() {\n    const ctx = this.checkContext();\n    const note = this.checkAttachedNote();\n    this.setRendered();\n    const start = note.getModifierStartXY(this.position, this.index);\n    let dot_x = start.x + this.x_shift + this.x_offset;\n    let dot_y = start.y + this.y_shift + this.y_offset + 5;\n    switch (this.position) {\n      case Modifier.Position.ABOVE:\n        dot_x -= 4;\n        dot_y -= 12;\n        break;\n      case Modifier.Position.BELOW:\n        dot_x -= 2;\n        dot_y += 10;\n        break;\n      case Modifier.Position.LEFT:\n        dot_x -= this.width;\n        break;\n      case Modifier.Position.RIGHT:\n        dot_x += 1;\n        break;\n      default:\n        throw new RuntimeError('InvalidPosition', `The position ${this.position} does not exist`);\n    }\n    ctx.save();\n    ctx.setFont(this.textFont);\n    ctx.fillText('' + this.finger, dot_x, dot_y);\n    ctx.restore();\n  }\n}\nFretHandFinger.TEXT_FONT = {\n  family: Font.SANS_SERIF,\n  size: 9,\n  weight: FontWeight.BOLD,\n  style: FontStyle.NORMAL\n};\nexport { FretHandFinger };","map":{"version":3,"names":["Font","FontStyle","FontWeight","Modifier","ModifierPosition","Tables","TextFormatter","RuntimeError","FretHandFinger","CATEGORY","format","nums","state","left_shift","right_shift","num_spacing","length","nums_list","prev_note","shiftLeft","shiftRight","i","num","note","getNote","pos","getPosition","index","checkIndex","props","getKeyProps","textFormatter","create","textFont","textHeight","maxHeight","position","ABOVE","top_text_line","STAVE_LINE_DISTANCE","BELOW","text_line","n","keys","Math","max","getLeftDisplacedHeadPx","getRightDisplacedHeadPx","push","line","shiftL","shiftR","sort","a","b","numShiftL","numShiftR","xWidthL","xWidthR","lastLine","lastNote","num_shift","numWidth","getWidth","Position","LEFT","setXShift","RIGHT","easyScoreHook","fingerings","arguments","undefined","builder","split","map","fingeringString","trim","params","number","getFactory","Fingering","fingering","addModifier","constructor","finger","width","x_shift","y_shift","x_offset","y_offset","resetFont","setFretHandFinger","getFretHandFinger","setOffsetX","x","setOffsetY","y","draw","ctx","checkContext","checkAttachedNote","setRendered","start","getModifierStartXY","dot_x","dot_y","save","setFont","fillText","restore","TEXT_FONT","family","SANS_SERIF","size","weight","BOLD","style","NORMAL"],"sources":["/Users/lang/Documents/code/Song2Notation/frontend/node_modules/vexflow/build/esm/src/frethandfinger.js"],"sourcesContent":["import { Font, FontStyle, FontWeight } from './font.js';\nimport { Modifier, ModifierPosition } from './modifier.js';\nimport { Tables } from './tables.js';\nimport { TextFormatter } from './textformatter.js';\nimport { RuntimeError } from './util.js';\nclass FretHandFinger extends Modifier {\n    static get CATEGORY() {\n        return \"FretHandFinger\";\n    }\n    static format(nums, state) {\n        const { left_shift, right_shift } = state;\n        const num_spacing = 1;\n        if (!nums || nums.length === 0)\n            return false;\n        const nums_list = [];\n        let prev_note = null;\n        let shiftLeft = 0;\n        let shiftRight = 0;\n        for (let i = 0; i < nums.length; ++i) {\n            const num = nums[i];\n            const note = num.getNote();\n            const pos = num.getPosition();\n            const index = num.checkIndex();\n            const props = note.getKeyProps()[index];\n            const textFormatter = TextFormatter.create(num.textFont);\n            const textHeight = textFormatter.maxHeight;\n            if (num.position === ModifierPosition.ABOVE) {\n                state.top_text_line += textHeight / Tables.STAVE_LINE_DISTANCE + 0.5;\n            }\n            if (num.position === ModifierPosition.BELOW) {\n                state.text_line += textHeight / Tables.STAVE_LINE_DISTANCE + 0.5;\n            }\n            if (note !== prev_note) {\n                for (let n = 0; n < note.keys.length; ++n) {\n                    if (left_shift === 0) {\n                        shiftLeft = Math.max(note.getLeftDisplacedHeadPx(), shiftLeft);\n                    }\n                    if (right_shift === 0) {\n                        shiftRight = Math.max(note.getRightDisplacedHeadPx(), shiftRight);\n                    }\n                }\n                prev_note = note;\n            }\n            nums_list.push({\n                note,\n                num,\n                pos,\n                line: props.line,\n                shiftL: shiftLeft,\n                shiftR: shiftRight,\n            });\n        }\n        nums_list.sort((a, b) => b.line - a.line);\n        let numShiftL = 0;\n        let numShiftR = 0;\n        let xWidthL = 0;\n        let xWidthR = 0;\n        let lastLine = null;\n        let lastNote = null;\n        for (let i = 0; i < nums_list.length; ++i) {\n            let num_shift = 0;\n            const { note, pos, num, line, shiftL, shiftR } = nums_list[i];\n            if (line !== lastLine || note !== lastNote) {\n                numShiftL = left_shift + shiftL;\n                numShiftR = right_shift + shiftR;\n            }\n            const numWidth = num.getWidth() + num_spacing;\n            if (pos === Modifier.Position.LEFT) {\n                num.setXShift(left_shift + numShiftL);\n                num_shift = left_shift + numWidth;\n                xWidthL = num_shift > xWidthL ? num_shift : xWidthL;\n            }\n            else if (pos === Modifier.Position.RIGHT) {\n                num.setXShift(numShiftR);\n                num_shift = shiftRight + numWidth;\n                xWidthR = num_shift > xWidthR ? num_shift : xWidthR;\n            }\n            lastLine = line;\n            lastNote = note;\n        }\n        state.left_shift += xWidthL;\n        state.right_shift += xWidthR;\n        return true;\n    }\n    static easyScoreHook({ fingerings } = {}, note, builder) {\n        fingerings === null || fingerings === void 0 ? void 0 : fingerings.split(',').map((fingeringString) => {\n            const split = fingeringString.trim().split('.');\n            const params = { number: split[0] };\n            if (split[1])\n                params.position = split[1];\n            return builder.getFactory().Fingering(params);\n        }).map((fingering, index) => note.addModifier(fingering, index));\n    }\n    constructor(finger) {\n        super();\n        this.finger = finger;\n        this.width = 7;\n        this.position = Modifier.Position.LEFT;\n        this.x_shift = 0;\n        this.y_shift = 0;\n        this.x_offset = 0;\n        this.y_offset = 0;\n        this.resetFont();\n    }\n    setFretHandFinger(finger) {\n        this.finger = finger;\n        return this;\n    }\n    getFretHandFinger() {\n        return this.finger;\n    }\n    setOffsetX(x) {\n        this.x_offset = x;\n        return this;\n    }\n    setOffsetY(y) {\n        this.y_offset = y;\n        return this;\n    }\n    draw() {\n        const ctx = this.checkContext();\n        const note = this.checkAttachedNote();\n        this.setRendered();\n        const start = note.getModifierStartXY(this.position, this.index);\n        let dot_x = start.x + this.x_shift + this.x_offset;\n        let dot_y = start.y + this.y_shift + this.y_offset + 5;\n        switch (this.position) {\n            case Modifier.Position.ABOVE:\n                dot_x -= 4;\n                dot_y -= 12;\n                break;\n            case Modifier.Position.BELOW:\n                dot_x -= 2;\n                dot_y += 10;\n                break;\n            case Modifier.Position.LEFT:\n                dot_x -= this.width;\n                break;\n            case Modifier.Position.RIGHT:\n                dot_x += 1;\n                break;\n            default:\n                throw new RuntimeError('InvalidPosition', `The position ${this.position} does not exist`);\n        }\n        ctx.save();\n        ctx.setFont(this.textFont);\n        ctx.fillText('' + this.finger, dot_x, dot_y);\n        ctx.restore();\n    }\n}\nFretHandFinger.TEXT_FONT = {\n    family: Font.SANS_SERIF,\n    size: 9,\n    weight: FontWeight.BOLD,\n    style: FontStyle.NORMAL,\n};\nexport { FretHandFinger };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}