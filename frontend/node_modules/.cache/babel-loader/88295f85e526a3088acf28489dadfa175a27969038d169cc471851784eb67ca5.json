{"ast":null,"code":"import { log, RuntimeError } from './util.js';\nfunction L() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  if (Parser.DEBUG) log('Vex.Flow.Parser', args);\n}\nconst NO_ERROR_POS = -1;\nfunction flattenMatches(r) {\n  if ('matchedString' in r) return r.matchedString;\n  if ('results' in r) return flattenMatches(r.results);\n  const results = r;\n  if (results.length === 1) return flattenMatches(results[0]);\n  if (results.length === 0) return null;\n  return results.map(flattenMatches);\n}\nclass Parser {\n  constructor(grammar) {\n    this.grammar = grammar;\n    this.line = '';\n    this.pos = 0;\n    this.errorPos = NO_ERROR_POS;\n  }\n  parse(line) {\n    this.line = line;\n    this.pos = 0;\n    this.errorPos = NO_ERROR_POS;\n    const result = this.expect(this.grammar.begin());\n    result.errorPos = this.errorPos;\n    return result;\n  }\n  matchFail(returnPos) {\n    if (this.errorPos === NO_ERROR_POS) this.errorPos = this.pos;\n    this.pos = returnPos;\n  }\n  matchSuccess() {\n    this.errorPos = NO_ERROR_POS;\n  }\n  matchToken(token) {\n    let noSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const regexp = noSpace ? new RegExp('^((' + token + '))') : new RegExp('^((' + token + ')\\\\s*)');\n    const workingLine = this.line.slice(this.pos);\n    const result = workingLine.match(regexp);\n    if (result !== null) {\n      return {\n        success: true,\n        matchedString: result[2],\n        incrementPos: result[1].length,\n        pos: this.pos\n      };\n    } else {\n      return {\n        success: false,\n        pos: this.pos\n      };\n    }\n  }\n  expectOne(rule) {\n    let maybe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const results = [];\n    const pos = this.pos;\n    let allMatches = true;\n    let oneMatch = false;\n    maybe = maybe === true || rule.maybe === true;\n    if (rule.expect) {\n      for (const next of rule.expect) {\n        const localPos = this.pos;\n        const result = this.expect(next);\n        if (result.success) {\n          results.push(result);\n          oneMatch = true;\n          if (rule.or) break;\n        } else {\n          allMatches = false;\n          if (!rule.or) {\n            this.pos = localPos;\n            break;\n          }\n        }\n      }\n    }\n    const gotOne = rule.or && oneMatch || allMatches;\n    const success = gotOne || maybe === true;\n    const numMatches = gotOne ? 1 : 0;\n    if (maybe && !gotOne) this.pos = pos;\n    if (success) {\n      this.matchSuccess();\n    } else {\n      this.matchFail(pos);\n    }\n    return {\n      success,\n      results,\n      numMatches\n    };\n  }\n  expectOneOrMore(rule) {\n    let maybe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const results = [];\n    const pos = this.pos;\n    let numMatches = 0;\n    let more = true;\n    do {\n      const result = this.expectOne(rule);\n      if (result.success && result.results) {\n        numMatches++;\n        results.push(result.results);\n      } else {\n        more = false;\n      }\n    } while (more);\n    const success = numMatches > 0 || maybe === true;\n    if (maybe && !(numMatches > 0)) this.pos = pos;\n    if (success) {\n      this.matchSuccess();\n    } else {\n      this.matchFail(pos);\n    }\n    return {\n      success,\n      results,\n      numMatches\n    };\n  }\n  expectZeroOrMore(rule) {\n    return this.expectOneOrMore(rule, true);\n  }\n  expect(ruleFunc) {\n    L('Evaluating rule function:', ruleFunc);\n    if (!ruleFunc) {\n      throw new RuntimeError('Invalid rule function');\n    }\n    let result;\n    const rule = ruleFunc.bind(this.grammar)();\n    if (rule.token) {\n      result = this.matchToken(rule.token, rule.noSpace === true);\n      if (result.success) {\n        this.pos += result.incrementPos;\n      }\n    } else if (rule.expect) {\n      if (rule.oneOrMore) {\n        result = this.expectOneOrMore(rule);\n      } else if (rule.zeroOrMore) {\n        result = this.expectZeroOrMore(rule);\n      } else {\n        result = this.expectOne(rule);\n      }\n    } else {\n      L(rule);\n      throw new RuntimeError('Bad grammar! No `token` or `expect` property ' + rule);\n    }\n    const matches = [];\n    result.matches = matches;\n    if (result.results) {\n      result.results.forEach(r => matches.push(flattenMatches(r)));\n    }\n    if (rule.run && result.success) {\n      rule.run({\n        matches\n      });\n    }\n    return result;\n  }\n}\nParser.DEBUG = false;\nexport { Parser };","map":{"version":3,"names":["log","RuntimeError","L","_len","arguments","length","args","Array","_key","Parser","DEBUG","NO_ERROR_POS","flattenMatches","r","matchedString","results","map","constructor","grammar","line","pos","errorPos","parse","result","expect","begin","matchFail","returnPos","matchSuccess","matchToken","token","noSpace","undefined","regexp","RegExp","workingLine","slice","match","success","incrementPos","expectOne","rule","maybe","allMatches","oneMatch","next","localPos","push","or","gotOne","numMatches","expectOneOrMore","more","expectZeroOrMore","ruleFunc","bind","oneOrMore","zeroOrMore","matches","forEach","run"],"sources":["/Users/lang/Documents/code/Song2Notation/frontend/node_modules/vexflow/build/esm/src/parser.js"],"sourcesContent":["import { log, RuntimeError } from './util.js';\nfunction L(...args) {\n    if (Parser.DEBUG)\n        log('Vex.Flow.Parser', args);\n}\nconst NO_ERROR_POS = -1;\nfunction flattenMatches(r) {\n    if ('matchedString' in r)\n        return r.matchedString;\n    if ('results' in r)\n        return flattenMatches(r.results);\n    const results = r;\n    if (results.length === 1)\n        return flattenMatches(results[0]);\n    if (results.length === 0)\n        return null;\n    return results.map(flattenMatches);\n}\nclass Parser {\n    constructor(grammar) {\n        this.grammar = grammar;\n        this.line = '';\n        this.pos = 0;\n        this.errorPos = NO_ERROR_POS;\n    }\n    parse(line) {\n        this.line = line;\n        this.pos = 0;\n        this.errorPos = NO_ERROR_POS;\n        const result = this.expect(this.grammar.begin());\n        result.errorPos = this.errorPos;\n        return result;\n    }\n    matchFail(returnPos) {\n        if (this.errorPos === NO_ERROR_POS)\n            this.errorPos = this.pos;\n        this.pos = returnPos;\n    }\n    matchSuccess() {\n        this.errorPos = NO_ERROR_POS;\n    }\n    matchToken(token, noSpace = false) {\n        const regexp = noSpace ? new RegExp('^((' + token + '))') : new RegExp('^((' + token + ')\\\\s*)');\n        const workingLine = this.line.slice(this.pos);\n        const result = workingLine.match(regexp);\n        if (result !== null) {\n            return {\n                success: true,\n                matchedString: result[2],\n                incrementPos: result[1].length,\n                pos: this.pos,\n            };\n        }\n        else {\n            return { success: false, pos: this.pos };\n        }\n    }\n    expectOne(rule, maybe = false) {\n        const results = [];\n        const pos = this.pos;\n        let allMatches = true;\n        let oneMatch = false;\n        maybe = maybe === true || rule.maybe === true;\n        if (rule.expect) {\n            for (const next of rule.expect) {\n                const localPos = this.pos;\n                const result = this.expect(next);\n                if (result.success) {\n                    results.push(result);\n                    oneMatch = true;\n                    if (rule.or)\n                        break;\n                }\n                else {\n                    allMatches = false;\n                    if (!rule.or) {\n                        this.pos = localPos;\n                        break;\n                    }\n                }\n            }\n        }\n        const gotOne = (rule.or && oneMatch) || allMatches;\n        const success = gotOne || maybe === true;\n        const numMatches = gotOne ? 1 : 0;\n        if (maybe && !gotOne)\n            this.pos = pos;\n        if (success) {\n            this.matchSuccess();\n        }\n        else {\n            this.matchFail(pos);\n        }\n        return { success, results, numMatches };\n    }\n    expectOneOrMore(rule, maybe = false) {\n        const results = [];\n        const pos = this.pos;\n        let numMatches = 0;\n        let more = true;\n        do {\n            const result = this.expectOne(rule);\n            if (result.success && result.results) {\n                numMatches++;\n                results.push(result.results);\n            }\n            else {\n                more = false;\n            }\n        } while (more);\n        const success = numMatches > 0 || maybe === true;\n        if (maybe && !(numMatches > 0))\n            this.pos = pos;\n        if (success) {\n            this.matchSuccess();\n        }\n        else {\n            this.matchFail(pos);\n        }\n        return { success, results, numMatches };\n    }\n    expectZeroOrMore(rule) {\n        return this.expectOneOrMore(rule, true);\n    }\n    expect(ruleFunc) {\n        L('Evaluating rule function:', ruleFunc);\n        if (!ruleFunc) {\n            throw new RuntimeError('Invalid rule function');\n        }\n        let result;\n        const rule = ruleFunc.bind(this.grammar)();\n        if (rule.token) {\n            result = this.matchToken(rule.token, rule.noSpace === true);\n            if (result.success) {\n                this.pos += result.incrementPos;\n            }\n        }\n        else if (rule.expect) {\n            if (rule.oneOrMore) {\n                result = this.expectOneOrMore(rule);\n            }\n            else if (rule.zeroOrMore) {\n                result = this.expectZeroOrMore(rule);\n            }\n            else {\n                result = this.expectOne(rule);\n            }\n        }\n        else {\n            L(rule);\n            throw new RuntimeError('Bad grammar! No `token` or `expect` property ' + rule);\n        }\n        const matches = [];\n        result.matches = matches;\n        if (result.results) {\n            result.results.forEach((r) => matches.push(flattenMatches(r)));\n        }\n        if (rule.run && result.success) {\n            rule.run({ matches });\n        }\n        return result;\n    }\n}\nParser.DEBUG = false;\nexport { Parser };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}