{"ast":null,"code":"import { Font } from './font.js';\nimport { Glyph } from './glyph.js';\nimport { Modifier } from './modifier.js';\nimport { Stem } from './stem.js';\nimport { StemmableNote } from './stemmablenote.js';\nimport { Tables } from './tables.js';\nimport { isDot } from './typeguard.js';\nimport { defined, RuntimeError } from './util.js';\nfunction getUnusedStringGroups(num_lines, strings_used) {\n  const stem_through = [];\n  let group = [];\n  for (let string = 1; string <= num_lines; string++) {\n    const is_used = strings_used.indexOf(string) > -1;\n    if (!is_used) {\n      group.push(string);\n    } else {\n      stem_through.push(group);\n      group = [];\n    }\n  }\n  if (group.length > 0) stem_through.push(group);\n  return stem_through;\n}\nfunction getPartialStemLines(stem_y, unused_strings, stave, stem_direction) {\n  const up_stem = stem_direction !== 1;\n  const down_stem = stem_direction !== -1;\n  const line_spacing = stave.getSpacingBetweenLines();\n  const total_lines = stave.getNumLines();\n  const stem_lines = [];\n  unused_strings.forEach(strings => {\n    const containsLastString = strings.indexOf(total_lines) > -1;\n    const containsFirstString = strings.indexOf(1) > -1;\n    if (up_stem && containsFirstString || down_stem && containsLastString) {\n      return;\n    }\n    if (strings.length === 1) {\n      strings.push(strings[0]);\n    }\n    const line_ys = [];\n    strings.forEach((string, index, strings) => {\n      const isTopBound = string === 1;\n      const isBottomBound = string === total_lines;\n      let y = stave.getYForLine(string - 1);\n      if (index === 0 && !isTopBound) {\n        y -= line_spacing / 2 - 1;\n      } else if (index === strings.length - 1 && !isBottomBound) {\n        y += line_spacing / 2 - 1;\n      }\n      line_ys.push(y);\n      if (stem_direction === 1 && isTopBound) {\n        line_ys.push(stem_y - 2);\n      } else if (stem_direction === -1 && isBottomBound) {\n        line_ys.push(stem_y + 2);\n      }\n    });\n    stem_lines.push(line_ys.sort((a, b) => a - b));\n  });\n  return stem_lines;\n}\nexport class TabNote extends StemmableNote {\n  static get CATEGORY() {\n    return \"TabNote\";\n  }\n  constructor(noteStruct) {\n    let draw_stem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    super(noteStruct);\n    this.glyphPropsArr = [];\n    this.greatestString = () => {\n      return this.positions.map(x => x.str).reduce((a, b) => a > b ? a : b);\n    };\n    this.leastString = () => {\n      return this.positions.map(x => x.str).reduce((a, b) => a < b ? a : b);\n    };\n    this.ghost = false;\n    this.positions = noteStruct.positions || [];\n    this.render_options = Object.assign(Object.assign({}, this.render_options), {\n      glyph_font_scale: Tables.TABLATURE_FONT_SCALE,\n      draw_stem,\n      draw_dots: draw_stem,\n      draw_stem_through_stave: false,\n      y_shift: 0,\n      scale: 1.0,\n      font: `${Font.SIZE}pt ${Font.SANS_SERIF}`\n    });\n    this.glyphProps = Tables.getGlyphProps(this.duration, this.noteType);\n    defined(this.glyphProps, 'BadArguments', `No glyph found for duration '${this.duration}' and type '${this.noteType}'`);\n    this.buildStem();\n    if (noteStruct.stem_direction) {\n      this.setStemDirection(noteStruct.stem_direction);\n    } else {\n      this.setStemDirection(Stem.UP);\n    }\n    this.ghost = false;\n    this.updateWidth();\n  }\n  reset() {\n    super.reset();\n    if (this.stave) this.setStave(this.stave);\n    return this;\n  }\n  setGhost(ghost) {\n    this.ghost = ghost;\n    this.updateWidth();\n    return this;\n  }\n  hasStem() {\n    if (this.render_options.draw_stem) return true;\n    return false;\n  }\n  getStemExtension() {\n    const glyphProps = this.getGlyphProps();\n    if (this.stem_extension_override != null) {\n      return this.stem_extension_override;\n    }\n    if (glyphProps) {\n      return this.getStemDirection() === Stem.UP ? glyphProps.tabnote_stem_up_extension : glyphProps.tabnote_stem_down_extension;\n    }\n    return 0;\n  }\n  updateWidth() {\n    this.glyphPropsArr = [];\n    this.width = 0;\n    for (let i = 0; i < this.positions.length; ++i) {\n      let fret = this.positions[i].fret;\n      if (this.ghost) fret = '(' + fret + ')';\n      const glyphProps = Tables.tabToGlyphProps(fret.toString(), this.render_options.scale);\n      this.glyphPropsArr.push(glyphProps);\n      this.width = Math.max(glyphProps.getWidth(), this.width);\n    }\n    this.glyphProps.getWidth = () => this.width;\n  }\n  setStave(stave) {\n    super.setStave(stave);\n    const ctx = stave.getContext();\n    this.setContext(ctx);\n    if (ctx) {\n      this.width = 0;\n      for (let i = 0; i < this.glyphPropsArr.length; ++i) {\n        const glyphProps = this.glyphPropsArr[i];\n        const text = '' + glyphProps.text;\n        if (text.toUpperCase() !== 'X') {\n          ctx.save();\n          ctx.setFont(this.render_options.font);\n          glyphProps.width = ctx.measureText(text).width;\n          ctx.restore();\n          glyphProps.getWidth = () => glyphProps.width;\n        }\n        this.width = Math.max(glyphProps.getWidth(), this.width);\n      }\n      this.glyphProps.getWidth = () => this.width;\n    }\n    const ys = this.positions.map(_ref => {\n      let {\n        str: line\n      } = _ref;\n      return stave.getYForLine(Number(line) - 1);\n    });\n    this.setYs(ys);\n    if (this.stem) {\n      this.stem.setYBounds(this.getStemY(), this.getStemY());\n    }\n    return this;\n  }\n  getPositions() {\n    return this.positions;\n  }\n  getModifierStartXY(position, index) {\n    if (!this.preFormatted) {\n      throw new RuntimeError('UnformattedNote', \"Can't call GetModifierStartXY on an unformatted note\");\n    }\n    if (this.ys.length === 0) {\n      throw new RuntimeError('NoYValues', 'No Y-Values calculated for this note.');\n    }\n    let x = 0;\n    if (position === Modifier.Position.LEFT) {\n      x = -1 * 2;\n    } else if (position === Modifier.Position.RIGHT) {\n      x = this.width + 2;\n    } else if (position === Modifier.Position.BELOW || position === Modifier.Position.ABOVE) {\n      const note_glyph_width = this.glyphProps.getWidth();\n      x = note_glyph_width / 2;\n    }\n    return {\n      x: this.getAbsoluteX() + x,\n      y: this.ys[index]\n    };\n  }\n  getLineForRest() {\n    return Number(this.positions[0].str);\n  }\n  preFormat() {\n    if (this.preFormatted) return;\n    if (this.modifierContext) this.modifierContext.preFormat();\n    this.preFormatted = true;\n  }\n  getStemX() {\n    return this.getCenterGlyphX();\n  }\n  getStemY() {\n    const num_lines = this.checkStave().getNumLines();\n    const stemUpLine = -0.5;\n    const stemDownLine = num_lines - 0.5;\n    const stemStartLine = Stem.UP === this.stem_direction ? stemUpLine : stemDownLine;\n    return this.checkStave().getYForLine(stemStartLine);\n  }\n  getStemExtents() {\n    return this.checkStem().getExtents();\n  }\n  drawFlag() {\n    var _a;\n    const {\n      beam,\n      glyphProps,\n      render_options: {\n        draw_stem\n      }\n    } = this;\n    const context = this.checkContext();\n    const shouldDrawFlag = beam == undefined && draw_stem;\n    if (glyphProps.flag && shouldDrawFlag) {\n      const flag_x = this.getStemX();\n      const flag_y = this.getStemDirection() === Stem.DOWN ? this.getStemY() - this.checkStem().getHeight() - (this.glyphProps ? this.glyphProps.stem_down_extension : 0) : this.getStemY() - this.checkStem().getHeight() + (this.glyphProps ? this.glyphProps.stem_up_extension : 0);\n      (_a = this.flag) === null || _a === void 0 ? void 0 : _a.render(context, flag_x, flag_y);\n    }\n  }\n  drawModifiers() {\n    this.modifiers.forEach(modifier => {\n      if (isDot(modifier) && !this.render_options.draw_dots) {\n        return;\n      }\n      modifier.setContext(this.getContext());\n      modifier.drawWithStyle();\n    });\n  }\n  drawStemThrough() {\n    const stemX = this.getStemX();\n    const stemY = this.getStemY();\n    const ctx = this.checkContext();\n    const drawStem = this.render_options.draw_stem;\n    const stemThrough = this.render_options.draw_stem_through_stave;\n    if (drawStem && stemThrough) {\n      const numLines = this.checkStave().getNumLines();\n      const stringsUsed = this.positions.map(position => Number(position.str));\n      const unusedStrings = getUnusedStringGroups(numLines, stringsUsed);\n      const stemLines = getPartialStemLines(stemY, unusedStrings, this.checkStave(), this.getStemDirection());\n      ctx.save();\n      ctx.setLineWidth(Stem.WIDTH);\n      stemLines.forEach(bounds => {\n        if (bounds.length === 0) return;\n        ctx.beginPath();\n        ctx.moveTo(stemX, bounds[0]);\n        ctx.lineTo(stemX, bounds[bounds.length - 1]);\n        ctx.stroke();\n        ctx.closePath();\n      });\n      ctx.restore();\n    }\n  }\n  drawPositions() {\n    var _a;\n    const ctx = this.checkContext();\n    const x = this.getAbsoluteX();\n    const ys = this.ys;\n    for (let i = 0; i < this.positions.length; ++i) {\n      const y = ys[i] + this.render_options.y_shift;\n      const glyphProps = this.glyphPropsArr[i];\n      const note_glyph_width = this.glyphProps.getWidth();\n      const tab_x = x + note_glyph_width / 2 - glyphProps.getWidth() / 2;\n      ctx.clearRect(tab_x - 2, y - 3, glyphProps.getWidth() + 4, 6);\n      if (glyphProps.code) {\n        Glyph.renderGlyph(ctx, tab_x, y, this.render_options.glyph_font_scale * this.render_options.scale, glyphProps.code);\n      } else {\n        ctx.save();\n        ctx.setFont(this.render_options.font);\n        const text = (_a = glyphProps.text) !== null && _a !== void 0 ? _a : '';\n        ctx.fillText(text, tab_x, y + 5 * this.render_options.scale);\n        ctx.restore();\n      }\n    }\n  }\n  draw() {\n    const ctx = this.checkContext();\n    if (this.ys.length === 0) {\n      throw new RuntimeError('NoYValues', \"Can't draw note without Y values.\");\n    }\n    this.setRendered();\n    const render_stem = this.beam == undefined && this.render_options.draw_stem;\n    this.applyStyle();\n    ctx.openGroup('tabnote', this.getAttribute('id'), {\n      pointerBBox: true\n    });\n    this.drawPositions();\n    this.drawStemThrough();\n    if (this.stem && render_stem) {\n      const stem_x = this.getStemX();\n      this.stem.setNoteHeadXBounds(stem_x, stem_x);\n      this.stem.setContext(ctx).draw();\n    }\n    this.drawFlag();\n    this.drawModifiers();\n    ctx.closeGroup();\n    this.restoreStyle();\n  }\n}","map":{"version":3,"names":["Font","Glyph","Modifier","Stem","StemmableNote","Tables","isDot","defined","RuntimeError","getUnusedStringGroups","num_lines","strings_used","stem_through","group","string","is_used","indexOf","push","length","getPartialStemLines","stem_y","unused_strings","stave","stem_direction","up_stem","down_stem","line_spacing","getSpacingBetweenLines","total_lines","getNumLines","stem_lines","forEach","strings","containsLastString","containsFirstString","line_ys","index","isTopBound","isBottomBound","y","getYForLine","sort","a","b","TabNote","CATEGORY","constructor","noteStruct","draw_stem","arguments","undefined","glyphPropsArr","greatestString","positions","map","x","str","reduce","leastString","ghost","render_options","Object","assign","glyph_font_scale","TABLATURE_FONT_SCALE","draw_dots","draw_stem_through_stave","y_shift","scale","font","SIZE","SANS_SERIF","glyphProps","getGlyphProps","duration","noteType","buildStem","setStemDirection","UP","updateWidth","reset","setStave","setGhost","hasStem","getStemExtension","stem_extension_override","getStemDirection","tabnote_stem_up_extension","tabnote_stem_down_extension","width","i","fret","tabToGlyphProps","toString","Math","max","getWidth","ctx","getContext","setContext","text","toUpperCase","save","setFont","measureText","restore","ys","_ref","line","Number","setYs","stem","setYBounds","getStemY","getPositions","getModifierStartXY","position","preFormatted","Position","LEFT","RIGHT","BELOW","ABOVE","note_glyph_width","getAbsoluteX","getLineForRest","preFormat","modifierContext","getStemX","getCenterGlyphX","checkStave","stemUpLine","stemDownLine","stemStartLine","getStemExtents","checkStem","getExtents","drawFlag","_a","beam","context","checkContext","shouldDrawFlag","flag","flag_x","flag_y","DOWN","getHeight","stem_down_extension","stem_up_extension","render","drawModifiers","modifiers","modifier","drawWithStyle","drawStemThrough","stemX","stemY","drawStem","stemThrough","numLines","stringsUsed","unusedStrings","stemLines","setLineWidth","WIDTH","bounds","beginPath","moveTo","lineTo","stroke","closePath","drawPositions","tab_x","clearRect","code","renderGlyph","fillText","draw","setRendered","render_stem","applyStyle","openGroup","getAttribute","pointerBBox","stem_x","setNoteHeadXBounds","closeGroup","restoreStyle"],"sources":["/Users/lang/Documents/code/Song2Notation/frontend/node_modules/vexflow/build/esm/src/tabnote.js"],"sourcesContent":["import { Font } from './font.js';\nimport { Glyph } from './glyph.js';\nimport { Modifier } from './modifier.js';\nimport { Stem } from './stem.js';\nimport { StemmableNote } from './stemmablenote.js';\nimport { Tables } from './tables.js';\nimport { isDot } from './typeguard.js';\nimport { defined, RuntimeError } from './util.js';\nfunction getUnusedStringGroups(num_lines, strings_used) {\n    const stem_through = [];\n    let group = [];\n    for (let string = 1; string <= num_lines; string++) {\n        const is_used = strings_used.indexOf(string) > -1;\n        if (!is_used) {\n            group.push(string);\n        }\n        else {\n            stem_through.push(group);\n            group = [];\n        }\n    }\n    if (group.length > 0)\n        stem_through.push(group);\n    return stem_through;\n}\nfunction getPartialStemLines(stem_y, unused_strings, stave, stem_direction) {\n    const up_stem = stem_direction !== 1;\n    const down_stem = stem_direction !== -1;\n    const line_spacing = stave.getSpacingBetweenLines();\n    const total_lines = stave.getNumLines();\n    const stem_lines = [];\n    unused_strings.forEach((strings) => {\n        const containsLastString = strings.indexOf(total_lines) > -1;\n        const containsFirstString = strings.indexOf(1) > -1;\n        if ((up_stem && containsFirstString) || (down_stem && containsLastString)) {\n            return;\n        }\n        if (strings.length === 1) {\n            strings.push(strings[0]);\n        }\n        const line_ys = [];\n        strings.forEach((string, index, strings) => {\n            const isTopBound = string === 1;\n            const isBottomBound = string === total_lines;\n            let y = stave.getYForLine(string - 1);\n            if (index === 0 && !isTopBound) {\n                y -= line_spacing / 2 - 1;\n            }\n            else if (index === strings.length - 1 && !isBottomBound) {\n                y += line_spacing / 2 - 1;\n            }\n            line_ys.push(y);\n            if (stem_direction === 1 && isTopBound) {\n                line_ys.push(stem_y - 2);\n            }\n            else if (stem_direction === -1 && isBottomBound) {\n                line_ys.push(stem_y + 2);\n            }\n        });\n        stem_lines.push(line_ys.sort((a, b) => a - b));\n    });\n    return stem_lines;\n}\nexport class TabNote extends StemmableNote {\n    static get CATEGORY() {\n        return \"TabNote\";\n    }\n    constructor(noteStruct, draw_stem = false) {\n        super(noteStruct);\n        this.glyphPropsArr = [];\n        this.greatestString = () => {\n            return this.positions.map((x) => x.str).reduce((a, b) => (a > b ? a : b));\n        };\n        this.leastString = () => {\n            return this.positions.map((x) => x.str).reduce((a, b) => (a < b ? a : b));\n        };\n        this.ghost = false;\n        this.positions = noteStruct.positions || [];\n        this.render_options = Object.assign(Object.assign({}, this.render_options), { glyph_font_scale: Tables.TABLATURE_FONT_SCALE, draw_stem, draw_dots: draw_stem, draw_stem_through_stave: false, y_shift: 0, scale: 1.0, font: `${Font.SIZE}pt ${Font.SANS_SERIF}` });\n        this.glyphProps = Tables.getGlyphProps(this.duration, this.noteType);\n        defined(this.glyphProps, 'BadArguments', `No glyph found for duration '${this.duration}' and type '${this.noteType}'`);\n        this.buildStem();\n        if (noteStruct.stem_direction) {\n            this.setStemDirection(noteStruct.stem_direction);\n        }\n        else {\n            this.setStemDirection(Stem.UP);\n        }\n        this.ghost = false;\n        this.updateWidth();\n    }\n    reset() {\n        super.reset();\n        if (this.stave)\n            this.setStave(this.stave);\n        return this;\n    }\n    setGhost(ghost) {\n        this.ghost = ghost;\n        this.updateWidth();\n        return this;\n    }\n    hasStem() {\n        if (this.render_options.draw_stem)\n            return true;\n        return false;\n    }\n    getStemExtension() {\n        const glyphProps = this.getGlyphProps();\n        if (this.stem_extension_override != null) {\n            return this.stem_extension_override;\n        }\n        if (glyphProps) {\n            return this.getStemDirection() === Stem.UP\n                ? glyphProps.tabnote_stem_up_extension\n                : glyphProps.tabnote_stem_down_extension;\n        }\n        return 0;\n    }\n    updateWidth() {\n        this.glyphPropsArr = [];\n        this.width = 0;\n        for (let i = 0; i < this.positions.length; ++i) {\n            let fret = this.positions[i].fret;\n            if (this.ghost)\n                fret = '(' + fret + ')';\n            const glyphProps = Tables.tabToGlyphProps(fret.toString(), this.render_options.scale);\n            this.glyphPropsArr.push(glyphProps);\n            this.width = Math.max(glyphProps.getWidth(), this.width);\n        }\n        this.glyphProps.getWidth = () => this.width;\n    }\n    setStave(stave) {\n        super.setStave(stave);\n        const ctx = stave.getContext();\n        this.setContext(ctx);\n        if (ctx) {\n            this.width = 0;\n            for (let i = 0; i < this.glyphPropsArr.length; ++i) {\n                const glyphProps = this.glyphPropsArr[i];\n                const text = '' + glyphProps.text;\n                if (text.toUpperCase() !== 'X') {\n                    ctx.save();\n                    ctx.setFont(this.render_options.font);\n                    glyphProps.width = ctx.measureText(text).width;\n                    ctx.restore();\n                    glyphProps.getWidth = () => glyphProps.width;\n                }\n                this.width = Math.max(glyphProps.getWidth(), this.width);\n            }\n            this.glyphProps.getWidth = () => this.width;\n        }\n        const ys = this.positions.map(({ str: line }) => stave.getYForLine(Number(line) - 1));\n        this.setYs(ys);\n        if (this.stem) {\n            this.stem.setYBounds(this.getStemY(), this.getStemY());\n        }\n        return this;\n    }\n    getPositions() {\n        return this.positions;\n    }\n    getModifierStartXY(position, index) {\n        if (!this.preFormatted) {\n            throw new RuntimeError('UnformattedNote', \"Can't call GetModifierStartXY on an unformatted note\");\n        }\n        if (this.ys.length === 0) {\n            throw new RuntimeError('NoYValues', 'No Y-Values calculated for this note.');\n        }\n        let x = 0;\n        if (position === Modifier.Position.LEFT) {\n            x = -1 * 2;\n        }\n        else if (position === Modifier.Position.RIGHT) {\n            x = this.width + 2;\n        }\n        else if (position === Modifier.Position.BELOW || position === Modifier.Position.ABOVE) {\n            const note_glyph_width = this.glyphProps.getWidth();\n            x = note_glyph_width / 2;\n        }\n        return {\n            x: this.getAbsoluteX() + x,\n            y: this.ys[index],\n        };\n    }\n    getLineForRest() {\n        return Number(this.positions[0].str);\n    }\n    preFormat() {\n        if (this.preFormatted)\n            return;\n        if (this.modifierContext)\n            this.modifierContext.preFormat();\n        this.preFormatted = true;\n    }\n    getStemX() {\n        return this.getCenterGlyphX();\n    }\n    getStemY() {\n        const num_lines = this.checkStave().getNumLines();\n        const stemUpLine = -0.5;\n        const stemDownLine = num_lines - 0.5;\n        const stemStartLine = Stem.UP === this.stem_direction ? stemUpLine : stemDownLine;\n        return this.checkStave().getYForLine(stemStartLine);\n    }\n    getStemExtents() {\n        return this.checkStem().getExtents();\n    }\n    drawFlag() {\n        var _a;\n        const { beam, glyphProps, render_options: { draw_stem }, } = this;\n        const context = this.checkContext();\n        const shouldDrawFlag = beam == undefined && draw_stem;\n        if (glyphProps.flag && shouldDrawFlag) {\n            const flag_x = this.getStemX();\n            const flag_y = this.getStemDirection() === Stem.DOWN\n                ?\n                    this.getStemY() - this.checkStem().getHeight() - (this.glyphProps ? this.glyphProps.stem_down_extension : 0)\n                :\n                    this.getStemY() - this.checkStem().getHeight() + (this.glyphProps ? this.glyphProps.stem_up_extension : 0);\n            (_a = this.flag) === null || _a === void 0 ? void 0 : _a.render(context, flag_x, flag_y);\n        }\n    }\n    drawModifiers() {\n        this.modifiers.forEach((modifier) => {\n            if (isDot(modifier) && !this.render_options.draw_dots) {\n                return;\n            }\n            modifier.setContext(this.getContext());\n            modifier.drawWithStyle();\n        });\n    }\n    drawStemThrough() {\n        const stemX = this.getStemX();\n        const stemY = this.getStemY();\n        const ctx = this.checkContext();\n        const drawStem = this.render_options.draw_stem;\n        const stemThrough = this.render_options.draw_stem_through_stave;\n        if (drawStem && stemThrough) {\n            const numLines = this.checkStave().getNumLines();\n            const stringsUsed = this.positions.map((position) => Number(position.str));\n            const unusedStrings = getUnusedStringGroups(numLines, stringsUsed);\n            const stemLines = getPartialStemLines(stemY, unusedStrings, this.checkStave(), this.getStemDirection());\n            ctx.save();\n            ctx.setLineWidth(Stem.WIDTH);\n            stemLines.forEach((bounds) => {\n                if (bounds.length === 0)\n                    return;\n                ctx.beginPath();\n                ctx.moveTo(stemX, bounds[0]);\n                ctx.lineTo(stemX, bounds[bounds.length - 1]);\n                ctx.stroke();\n                ctx.closePath();\n            });\n            ctx.restore();\n        }\n    }\n    drawPositions() {\n        var _a;\n        const ctx = this.checkContext();\n        const x = this.getAbsoluteX();\n        const ys = this.ys;\n        for (let i = 0; i < this.positions.length; ++i) {\n            const y = ys[i] + this.render_options.y_shift;\n            const glyphProps = this.glyphPropsArr[i];\n            const note_glyph_width = this.glyphProps.getWidth();\n            const tab_x = x + note_glyph_width / 2 - glyphProps.getWidth() / 2;\n            ctx.clearRect(tab_x - 2, y - 3, glyphProps.getWidth() + 4, 6);\n            if (glyphProps.code) {\n                Glyph.renderGlyph(ctx, tab_x, y, this.render_options.glyph_font_scale * this.render_options.scale, glyphProps.code);\n            }\n            else {\n                ctx.save();\n                ctx.setFont(this.render_options.font);\n                const text = (_a = glyphProps.text) !== null && _a !== void 0 ? _a : '';\n                ctx.fillText(text, tab_x, y + 5 * this.render_options.scale);\n                ctx.restore();\n            }\n        }\n    }\n    draw() {\n        const ctx = this.checkContext();\n        if (this.ys.length === 0) {\n            throw new RuntimeError('NoYValues', \"Can't draw note without Y values.\");\n        }\n        this.setRendered();\n        const render_stem = this.beam == undefined && this.render_options.draw_stem;\n        this.applyStyle();\n        ctx.openGroup('tabnote', this.getAttribute('id'), { pointerBBox: true });\n        this.drawPositions();\n        this.drawStemThrough();\n        if (this.stem && render_stem) {\n            const stem_x = this.getStemX();\n            this.stem.setNoteHeadXBounds(stem_x, stem_x);\n            this.stem.setContext(ctx).draw();\n        }\n        this.drawFlag();\n        this.drawModifiers();\n        ctx.closeGroup();\n        this.restoreStyle();\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}