{"ast":null,"code":"import { Fraction } from './fraction.js';\nimport { Glyph } from './glyph.js';\nimport { Modifier } from './modifier.js';\nimport { Music } from './music.js';\nimport { Tables } from './tables.js';\nimport { isAccidental, isGraceNote, isGraceNoteGroup, isStaveNote } from './typeguard.js';\nimport { defined, log } from './util.js';\nfunction L() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  if (Accidental.DEBUG) log('Vex.Flow.Accidental', args);\n}\nclass Accidental extends Modifier {\n  static get CATEGORY() {\n    return \"Accidental\";\n  }\n  static format(accidentals, state) {\n    var _this = this;\n    if (!accidentals || accidentals.length === 0) return;\n    const musicFont = Tables.currentMusicFont();\n    const noteheadAccidentalPadding = musicFont.lookupMetric('accidental.noteheadAccidentalPadding');\n    const leftShift = state.left_shift + noteheadAccidentalPadding;\n    const accidentalSpacing = musicFont.lookupMetric('accidental.accidentalSpacing');\n    const additionalPadding = musicFont.lookupMetric('accidental.leftPadding');\n    const accidentalLinePositionsAndSpaceNeeds = [];\n    let prevNote = undefined;\n    let extraXSpaceNeededForLeftDisplacedNotehead = 0;\n    for (let i = 0; i < accidentals.length; ++i) {\n      const acc = accidentals[i];\n      const note = acc.getNote();\n      const stave = note.getStave();\n      const index = acc.checkIndex();\n      const props = note.getKeyProps()[index];\n      if (note !== prevNote) {\n        for (let n = 0; n < note.keys.length; ++n) {\n          extraXSpaceNeededForLeftDisplacedNotehead = Math.max(note.getLeftDisplacedHeadPx() - note.getXShift(), extraXSpaceNeededForLeftDisplacedNotehead);\n        }\n        prevNote = note;\n      }\n      if (stave) {\n        const lineSpace = stave.getSpacingBetweenLines();\n        const y = stave.getYForLine(props.line);\n        const accLine = Math.round(y / lineSpace * 2) / 2;\n        accidentalLinePositionsAndSpaceNeeds.push({\n          y,\n          line: accLine,\n          extraXSpaceNeeded: extraXSpaceNeededForLeftDisplacedNotehead,\n          acc,\n          spacingBetweenStaveLines: lineSpace\n        });\n      } else {\n        accidentalLinePositionsAndSpaceNeeds.push({\n          line: props.line,\n          extraXSpaceNeeded: extraXSpaceNeededForLeftDisplacedNotehead,\n          acc\n        });\n      }\n    }\n    accidentalLinePositionsAndSpaceNeeds.sort((a, b) => b.line - a.line);\n    const staveLineAccidentalLayoutMetrics = [];\n    let maxExtraXSpaceNeeded = 0;\n    for (let i = 0; i < accidentalLinePositionsAndSpaceNeeds.length; i++) {\n      const accidentalLinePositionAndSpaceNeeds = accidentalLinePositionsAndSpaceNeeds[i];\n      const priorLineMetric = staveLineAccidentalLayoutMetrics[staveLineAccidentalLayoutMetrics.length - 1];\n      let currentLineMetric;\n      if (!priorLineMetric || (priorLineMetric === null || priorLineMetric === void 0 ? void 0 : priorLineMetric.line) !== accidentalLinePositionAndSpaceNeeds.line) {\n        currentLineMetric = {\n          line: accidentalLinePositionAndSpaceNeeds.line,\n          flatLine: true,\n          dblSharpLine: true,\n          numAcc: 0,\n          width: 0,\n          column: 0\n        };\n        staveLineAccidentalLayoutMetrics.push(currentLineMetric);\n      } else {\n        currentLineMetric = priorLineMetric;\n      }\n      if (accidentalLinePositionAndSpaceNeeds.acc.type !== 'b' && accidentalLinePositionAndSpaceNeeds.acc.type !== 'bb') {\n        currentLineMetric.flatLine = false;\n      }\n      if (accidentalLinePositionAndSpaceNeeds.acc.type !== '##') {\n        currentLineMetric.dblSharpLine = false;\n      }\n      currentLineMetric.numAcc++;\n      currentLineMetric.width += accidentalLinePositionAndSpaceNeeds.acc.getWidth() + accidentalSpacing;\n      maxExtraXSpaceNeeded = Math.max(accidentalLinePositionAndSpaceNeeds.extraXSpaceNeeded, maxExtraXSpaceNeeded);\n    }\n    let totalColumns = 0;\n    for (let i = 0; i < staveLineAccidentalLayoutMetrics.length; i++) {\n      let noFurtherConflicts = false;\n      const groupStart = i;\n      let groupEnd = i;\n      while (groupEnd + 1 < staveLineAccidentalLayoutMetrics.length && !noFurtherConflicts) {\n        if (this.checkCollision(staveLineAccidentalLayoutMetrics[groupEnd], staveLineAccidentalLayoutMetrics[groupEnd + 1])) {\n          groupEnd++;\n        } else {\n          noFurtherConflicts = true;\n        }\n      }\n      const getGroupLine = index => staveLineAccidentalLayoutMetrics[groupStart + index];\n      const getGroupLines = indexes => indexes.map(getGroupLine);\n      const lineDifference = (indexA, indexB) => {\n        const [a, b] = getGroupLines([indexA, indexB]).map(item => item.line);\n        return a - b;\n      };\n      const notColliding = function () {\n        for (var _len2 = arguments.length, indexPairs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          indexPairs[_key2] = arguments[_key2];\n        }\n        return indexPairs.map(getGroupLines).every(_ref => {\n          let [line1, line2] = _ref;\n          return !_this.checkCollision(line1, line2);\n        });\n      };\n      const groupLength = groupEnd - groupStart + 1;\n      let endCase = this.checkCollision(staveLineAccidentalLayoutMetrics[groupStart], staveLineAccidentalLayoutMetrics[groupEnd]) ? 'a' : 'b';\n      switch (groupLength) {\n        case 3:\n          if (endCase === 'a' && lineDifference(1, 2) === 0.5 && lineDifference(0, 1) !== 0.5) {\n            endCase = 'second_on_bottom';\n          }\n          break;\n        case 4:\n          if (notColliding([0, 2], [1, 3])) {\n            endCase = 'spaced_out_tetrachord';\n          }\n          break;\n        case 5:\n          if (endCase === 'b' && notColliding([1, 3])) {\n            endCase = 'spaced_out_pentachord';\n            if (notColliding([0, 2], [2, 4])) {\n              endCase = 'very_spaced_out_pentachord';\n            }\n          }\n          break;\n        case 6:\n          if (notColliding([0, 3], [1, 4], [2, 5])) {\n            endCase = 'spaced_out_hexachord';\n          }\n          if (notColliding([0, 2], [2, 4], [1, 3], [3, 5])) {\n            endCase = 'very_spaced_out_hexachord';\n          }\n          break;\n        default:\n          break;\n      }\n      let groupMember;\n      let column;\n      if (groupLength >= 7) {\n        let patternLength = 2;\n        let collisionDetected = true;\n        while (collisionDetected === true) {\n          collisionDetected = false;\n          for (let line = 0; line + patternLength < staveLineAccidentalLayoutMetrics.length; line++) {\n            if (this.checkCollision(staveLineAccidentalLayoutMetrics[line], staveLineAccidentalLayoutMetrics[line + patternLength])) {\n              collisionDetected = true;\n              patternLength++;\n              break;\n            }\n          }\n        }\n        for (groupMember = i; groupMember <= groupEnd; groupMember++) {\n          column = (groupMember - i) % patternLength + 1;\n          staveLineAccidentalLayoutMetrics[groupMember].column = column;\n          totalColumns = totalColumns > column ? totalColumns : column;\n        }\n      } else {\n        for (groupMember = i; groupMember <= groupEnd; groupMember++) {\n          column = Tables.accidentalColumnsTable[groupLength][endCase][groupMember - i];\n          staveLineAccidentalLayoutMetrics[groupMember].column = column;\n          totalColumns = totalColumns > column ? totalColumns : column;\n        }\n      }\n      i = groupEnd;\n    }\n    const columnWidths = [];\n    const columnXOffsets = [];\n    for (let i = 0; i <= totalColumns; i++) {\n      columnWidths[i] = 0;\n      columnXOffsets[i] = 0;\n    }\n    columnWidths[0] = leftShift + maxExtraXSpaceNeeded;\n    columnXOffsets[0] = leftShift;\n    staveLineAccidentalLayoutMetrics.forEach(line => {\n      if (line.width > columnWidths[line.column]) columnWidths[line.column] = line.width;\n    });\n    for (let i = 1; i < columnWidths.length; i++) {\n      columnXOffsets[i] = columnWidths[i] + columnXOffsets[i - 1];\n    }\n    const totalShift = columnXOffsets[columnXOffsets.length - 1];\n    let accCount = 0;\n    staveLineAccidentalLayoutMetrics.forEach(line => {\n      let lineWidth = 0;\n      const lastAccOnLine = accCount + line.numAcc;\n      for (accCount; accCount < lastAccOnLine; accCount++) {\n        const xShift = columnXOffsets[line.column - 1] + lineWidth + maxExtraXSpaceNeeded;\n        accidentalLinePositionsAndSpaceNeeds[accCount].acc.setXShift(xShift);\n        lineWidth += accidentalLinePositionsAndSpaceNeeds[accCount].acc.getWidth() + accidentalSpacing;\n        L('Line, accCount, shift: ', line.line, accCount, xShift);\n      }\n    });\n    state.left_shift = totalShift + additionalPadding;\n  }\n  static checkCollision(line1, line2) {\n    let clearance = line2.line - line1.line;\n    let clearanceRequired = 3;\n    if (clearance > 0) {\n      clearanceRequired = line2.flatLine || line2.dblSharpLine ? 2.5 : 3.0;\n      if (line1.dblSharpLine) clearance -= 0.5;\n    } else {\n      clearanceRequired = line1.flatLine || line1.dblSharpLine ? 2.5 : 3.0;\n      if (line2.dblSharpLine) clearance -= 0.5;\n    }\n    const collision = Math.abs(clearance) < clearanceRequired;\n    L('Line_1, Line_2, Collision: ', line1.line, line2.line, collision);\n    return collision;\n  }\n  static applyAccidentals(voices, keySignature) {\n    const tickPositions = [];\n    const tickNoteMap = {};\n    voices.forEach(voice => {\n      const tickPosition = new Fraction(0, 1);\n      const tickable = voice.getTickables();\n      tickable.forEach(t => {\n        if (t.shouldIgnoreTicks()) return;\n        const notesAtPosition = tickNoteMap[tickPosition.value()];\n        if (!notesAtPosition) {\n          tickPositions.push(tickPosition.value());\n          tickNoteMap[tickPosition.value()] = [t];\n        } else {\n          notesAtPosition.push(t);\n        }\n        tickPosition.add(t.getTicks());\n      });\n    });\n    const music = new Music();\n    if (!keySignature) keySignature = 'C';\n    const scaleMapKey = music.createScaleMap(keySignature);\n    const scaleMap = {};\n    tickPositions.forEach(tickPos => {\n      const tickables = tickNoteMap[tickPos];\n      const modifiedPitches = [];\n      const processNote = t => {\n        if (!isStaveNote(t) || t.isRest() || t.shouldIgnoreTicks()) {\n          return;\n        }\n        const staveNote = t;\n        staveNote.keys.forEach((keyString, keyIndex) => {\n          const key = music.getNoteParts(keyString.split('/')[0]);\n          const octave = keyString.split('/')[1];\n          const accidentalString = key.accidental || 'n';\n          const pitch = key.root + accidentalString;\n          if (!scaleMap[key.root + octave]) scaleMap[key.root + octave] = scaleMapKey[key.root];\n          const sameAccidental = scaleMap[key.root + octave] === pitch;\n          const previouslyModified = modifiedPitches.indexOf(keyString) > -1;\n          staveNote.getModifiers().forEach((modifier, index) => {\n            if (isAccidental(modifier) && modifier.type == accidentalString && modifier.getIndex() == keyIndex) {\n              staveNote.getModifiers().splice(index, 1);\n            }\n          });\n          if (!sameAccidental || sameAccidental && previouslyModified) {\n            scaleMap[key.root + octave] = pitch;\n            const accidental = new Accidental(accidentalString);\n            staveNote.addModifier(accidental, keyIndex);\n            modifiedPitches.push(keyString);\n          }\n        });\n        staveNote.getModifiers().forEach(modifier => {\n          if (isGraceNoteGroup(modifier)) {\n            modifier.getGraceNotes().forEach(processNote);\n          }\n        });\n      };\n      tickables.forEach(processNote);\n    });\n  }\n  constructor(type) {\n    super();\n    L('New accidental: ', type);\n    this.type = type;\n    this.position = Modifier.Position.LEFT;\n    this.render_options = {\n      font_scale: Tables.NOTATION_FONT_SCALE,\n      parenLeftPadding: 2,\n      parenRightPadding: 2\n    };\n    this.accidental = Tables.accidentalCodes(this.type);\n    defined(this.accidental, 'ArgumentError', `Unknown accidental type: ${type}`);\n    this.cautionary = false;\n    this.reset();\n  }\n  reset() {\n    const fontScale = this.render_options.font_scale;\n    this.glyph = new Glyph(this.accidental.code, fontScale);\n    this.glyph.setOriginX(1.0);\n    if (this.cautionary) {\n      this.parenLeft = new Glyph(Tables.accidentalCodes('{').code, fontScale);\n      this.parenRight = new Glyph(Tables.accidentalCodes('}').code, fontScale);\n      this.parenLeft.setOriginX(1.0);\n      this.parenRight.setOriginX(1.0);\n    }\n  }\n  getWidth() {\n    if (this.cautionary) {\n      const parenLeft = defined(this.parenLeft);\n      const parenRight = defined(this.parenRight);\n      const parenWidth = parenLeft.getMetrics().width + parenRight.getMetrics().width + this.render_options.parenLeftPadding + this.render_options.parenRightPadding;\n      return this.glyph.getMetrics().width + parenWidth;\n    } else {\n      return this.glyph.getMetrics().width;\n    }\n  }\n  setNote(note) {\n    defined(note, 'ArgumentError', `Bad note value: ${note}`);\n    this.note = note;\n    if (isGraceNote(note)) {\n      this.render_options.font_scale = 25;\n      this.reset();\n    }\n    return this;\n  }\n  setAsCautionary() {\n    this.cautionary = true;\n    this.render_options.font_scale = 28;\n    this.reset();\n    return this;\n  }\n  draw() {\n    const {\n      type,\n      position,\n      index,\n      cautionary,\n      x_shift,\n      y_shift,\n      glyph,\n      render_options: {\n        parenLeftPadding,\n        parenRightPadding\n      }\n    } = this;\n    const ctx = this.checkContext();\n    const note = this.checkAttachedNote();\n    this.setRendered();\n    const start = note.getModifierStartXY(position, index);\n    let accX = start.x + x_shift;\n    const accY = start.y + y_shift;\n    L('Rendering: ', type, accX, accY);\n    if (!cautionary) {\n      glyph.render(ctx, accX, accY);\n    } else {\n      const parenLeft = defined(this.parenLeft);\n      const parenRight = defined(this.parenRight);\n      parenRight.render(ctx, accX, accY);\n      accX -= parenRight.getMetrics().width;\n      accX -= parenRightPadding;\n      accX -= this.accidental.parenRightPaddingAdjustment;\n      glyph.render(ctx, accX, accY);\n      accX -= glyph.getMetrics().width;\n      accX -= parenLeftPadding;\n      parenLeft.render(ctx, accX, accY);\n    }\n  }\n}\nAccidental.DEBUG = false;\nexport { Accidental };","map":{"version":3,"names":["Fraction","Glyph","Modifier","Music","Tables","isAccidental","isGraceNote","isGraceNoteGroup","isStaveNote","defined","log","L","_len","arguments","length","args","Array","_key","Accidental","DEBUG","CATEGORY","format","accidentals","state","_this","musicFont","currentMusicFont","noteheadAccidentalPadding","lookupMetric","leftShift","left_shift","accidentalSpacing","additionalPadding","accidentalLinePositionsAndSpaceNeeds","prevNote","undefined","extraXSpaceNeededForLeftDisplacedNotehead","i","acc","note","getNote","stave","getStave","index","checkIndex","props","getKeyProps","n","keys","Math","max","getLeftDisplacedHeadPx","getXShift","lineSpace","getSpacingBetweenLines","y","getYForLine","line","accLine","round","push","extraXSpaceNeeded","spacingBetweenStaveLines","sort","a","b","staveLineAccidentalLayoutMetrics","maxExtraXSpaceNeeded","accidentalLinePositionAndSpaceNeeds","priorLineMetric","currentLineMetric","flatLine","dblSharpLine","numAcc","width","column","type","getWidth","totalColumns","noFurtherConflicts","groupStart","groupEnd","checkCollision","getGroupLine","getGroupLines","indexes","map","lineDifference","indexA","indexB","item","notColliding","_len2","indexPairs","_key2","every","_ref","line1","line2","groupLength","endCase","groupMember","patternLength","collisionDetected","accidentalColumnsTable","columnWidths","columnXOffsets","forEach","totalShift","accCount","lineWidth","lastAccOnLine","xShift","setXShift","clearance","clearanceRequired","collision","abs","applyAccidentals","voices","keySignature","tickPositions","tickNoteMap","voice","tickPosition","tickable","getTickables","t","shouldIgnoreTicks","notesAtPosition","value","add","getTicks","music","scaleMapKey","createScaleMap","scaleMap","tickPos","tickables","modifiedPitches","processNote","isRest","staveNote","keyString","keyIndex","key","getNoteParts","split","octave","accidentalString","accidental","pitch","root","sameAccidental","previouslyModified","indexOf","getModifiers","modifier","getIndex","splice","addModifier","getGraceNotes","constructor","position","Position","LEFT","render_options","font_scale","NOTATION_FONT_SCALE","parenLeftPadding","parenRightPadding","accidentalCodes","cautionary","reset","fontScale","glyph","code","setOriginX","parenLeft","parenRight","parenWidth","getMetrics","setNote","setAsCautionary","draw","x_shift","y_shift","ctx","checkContext","checkAttachedNote","setRendered","start","getModifierStartXY","accX","x","accY","render","parenRightPaddingAdjustment"],"sources":["/Users/lang/Documents/code/Song2Notation/frontend/node_modules/vexflow/build/esm/src/accidental.js"],"sourcesContent":["import { Fraction } from './fraction.js';\nimport { Glyph } from './glyph.js';\nimport { Modifier } from './modifier.js';\nimport { Music } from './music.js';\nimport { Tables } from './tables.js';\nimport { isAccidental, isGraceNote, isGraceNoteGroup, isStaveNote } from './typeguard.js';\nimport { defined, log } from './util.js';\nfunction L(...args) {\n    if (Accidental.DEBUG)\n        log('Vex.Flow.Accidental', args);\n}\nclass Accidental extends Modifier {\n    static get CATEGORY() {\n        return \"Accidental\";\n    }\n    static format(accidentals, state) {\n        if (!accidentals || accidentals.length === 0)\n            return;\n        const musicFont = Tables.currentMusicFont();\n        const noteheadAccidentalPadding = musicFont.lookupMetric('accidental.noteheadAccidentalPadding');\n        const leftShift = state.left_shift + noteheadAccidentalPadding;\n        const accidentalSpacing = musicFont.lookupMetric('accidental.accidentalSpacing');\n        const additionalPadding = musicFont.lookupMetric('accidental.leftPadding');\n        const accidentalLinePositionsAndSpaceNeeds = [];\n        let prevNote = undefined;\n        let extraXSpaceNeededForLeftDisplacedNotehead = 0;\n        for (let i = 0; i < accidentals.length; ++i) {\n            const acc = accidentals[i];\n            const note = acc.getNote();\n            const stave = note.getStave();\n            const index = acc.checkIndex();\n            const props = note.getKeyProps()[index];\n            if (note !== prevNote) {\n                for (let n = 0; n < note.keys.length; ++n) {\n                    extraXSpaceNeededForLeftDisplacedNotehead = Math.max(note.getLeftDisplacedHeadPx() - note.getXShift(), extraXSpaceNeededForLeftDisplacedNotehead);\n                }\n                prevNote = note;\n            }\n            if (stave) {\n                const lineSpace = stave.getSpacingBetweenLines();\n                const y = stave.getYForLine(props.line);\n                const accLine = Math.round((y / lineSpace) * 2) / 2;\n                accidentalLinePositionsAndSpaceNeeds.push({\n                    y,\n                    line: accLine,\n                    extraXSpaceNeeded: extraXSpaceNeededForLeftDisplacedNotehead,\n                    acc,\n                    spacingBetweenStaveLines: lineSpace,\n                });\n            }\n            else {\n                accidentalLinePositionsAndSpaceNeeds.push({\n                    line: props.line,\n                    extraXSpaceNeeded: extraXSpaceNeededForLeftDisplacedNotehead,\n                    acc,\n                });\n            }\n        }\n        accidentalLinePositionsAndSpaceNeeds.sort((a, b) => b.line - a.line);\n        const staveLineAccidentalLayoutMetrics = [];\n        let maxExtraXSpaceNeeded = 0;\n        for (let i = 0; i < accidentalLinePositionsAndSpaceNeeds.length; i++) {\n            const accidentalLinePositionAndSpaceNeeds = accidentalLinePositionsAndSpaceNeeds[i];\n            const priorLineMetric = staveLineAccidentalLayoutMetrics[staveLineAccidentalLayoutMetrics.length - 1];\n            let currentLineMetric;\n            if (!priorLineMetric || (priorLineMetric === null || priorLineMetric === void 0 ? void 0 : priorLineMetric.line) !== accidentalLinePositionAndSpaceNeeds.line) {\n                currentLineMetric = {\n                    line: accidentalLinePositionAndSpaceNeeds.line,\n                    flatLine: true,\n                    dblSharpLine: true,\n                    numAcc: 0,\n                    width: 0,\n                    column: 0,\n                };\n                staveLineAccidentalLayoutMetrics.push(currentLineMetric);\n            }\n            else {\n                currentLineMetric = priorLineMetric;\n            }\n            if (accidentalLinePositionAndSpaceNeeds.acc.type !== 'b' &&\n                accidentalLinePositionAndSpaceNeeds.acc.type !== 'bb') {\n                currentLineMetric.flatLine = false;\n            }\n            if (accidentalLinePositionAndSpaceNeeds.acc.type !== '##') {\n                currentLineMetric.dblSharpLine = false;\n            }\n            currentLineMetric.numAcc++;\n            currentLineMetric.width += accidentalLinePositionAndSpaceNeeds.acc.getWidth() + accidentalSpacing;\n            maxExtraXSpaceNeeded = Math.max(accidentalLinePositionAndSpaceNeeds.extraXSpaceNeeded, maxExtraXSpaceNeeded);\n        }\n        let totalColumns = 0;\n        for (let i = 0; i < staveLineAccidentalLayoutMetrics.length; i++) {\n            let noFurtherConflicts = false;\n            const groupStart = i;\n            let groupEnd = i;\n            while (groupEnd + 1 < staveLineAccidentalLayoutMetrics.length && !noFurtherConflicts) {\n                if (this.checkCollision(staveLineAccidentalLayoutMetrics[groupEnd], staveLineAccidentalLayoutMetrics[groupEnd + 1])) {\n                    groupEnd++;\n                }\n                else {\n                    noFurtherConflicts = true;\n                }\n            }\n            const getGroupLine = (index) => staveLineAccidentalLayoutMetrics[groupStart + index];\n            const getGroupLines = (indexes) => indexes.map(getGroupLine);\n            const lineDifference = (indexA, indexB) => {\n                const [a, b] = getGroupLines([indexA, indexB]).map((item) => item.line);\n                return a - b;\n            };\n            const notColliding = (...indexPairs) => indexPairs.map(getGroupLines).every(([line1, line2]) => !this.checkCollision(line1, line2));\n            const groupLength = groupEnd - groupStart + 1;\n            let endCase = this.checkCollision(staveLineAccidentalLayoutMetrics[groupStart], staveLineAccidentalLayoutMetrics[groupEnd])\n                ? 'a'\n                : 'b';\n            switch (groupLength) {\n                case 3:\n                    if (endCase === 'a' && lineDifference(1, 2) === 0.5 && lineDifference(0, 1) !== 0.5) {\n                        endCase = 'second_on_bottom';\n                    }\n                    break;\n                case 4:\n                    if (notColliding([0, 2], [1, 3])) {\n                        endCase = 'spaced_out_tetrachord';\n                    }\n                    break;\n                case 5:\n                    if (endCase === 'b' && notColliding([1, 3])) {\n                        endCase = 'spaced_out_pentachord';\n                        if (notColliding([0, 2], [2, 4])) {\n                            endCase = 'very_spaced_out_pentachord';\n                        }\n                    }\n                    break;\n                case 6:\n                    if (notColliding([0, 3], [1, 4], [2, 5])) {\n                        endCase = 'spaced_out_hexachord';\n                    }\n                    if (notColliding([0, 2], [2, 4], [1, 3], [3, 5])) {\n                        endCase = 'very_spaced_out_hexachord';\n                    }\n                    break;\n                default:\n                    break;\n            }\n            let groupMember;\n            let column;\n            if (groupLength >= 7) {\n                let patternLength = 2;\n                let collisionDetected = true;\n                while (collisionDetected === true) {\n                    collisionDetected = false;\n                    for (let line = 0; line + patternLength < staveLineAccidentalLayoutMetrics.length; line++) {\n                        if (this.checkCollision(staveLineAccidentalLayoutMetrics[line], staveLineAccidentalLayoutMetrics[line + patternLength])) {\n                            collisionDetected = true;\n                            patternLength++;\n                            break;\n                        }\n                    }\n                }\n                for (groupMember = i; groupMember <= groupEnd; groupMember++) {\n                    column = ((groupMember - i) % patternLength) + 1;\n                    staveLineAccidentalLayoutMetrics[groupMember].column = column;\n                    totalColumns = totalColumns > column ? totalColumns : column;\n                }\n            }\n            else {\n                for (groupMember = i; groupMember <= groupEnd; groupMember++) {\n                    column = Tables.accidentalColumnsTable[groupLength][endCase][groupMember - i];\n                    staveLineAccidentalLayoutMetrics[groupMember].column = column;\n                    totalColumns = totalColumns > column ? totalColumns : column;\n                }\n            }\n            i = groupEnd;\n        }\n        const columnWidths = [];\n        const columnXOffsets = [];\n        for (let i = 0; i <= totalColumns; i++) {\n            columnWidths[i] = 0;\n            columnXOffsets[i] = 0;\n        }\n        columnWidths[0] = leftShift + maxExtraXSpaceNeeded;\n        columnXOffsets[0] = leftShift;\n        staveLineAccidentalLayoutMetrics.forEach((line) => {\n            if (line.width > columnWidths[line.column])\n                columnWidths[line.column] = line.width;\n        });\n        for (let i = 1; i < columnWidths.length; i++) {\n            columnXOffsets[i] = columnWidths[i] + columnXOffsets[i - 1];\n        }\n        const totalShift = columnXOffsets[columnXOffsets.length - 1];\n        let accCount = 0;\n        staveLineAccidentalLayoutMetrics.forEach((line) => {\n            let lineWidth = 0;\n            const lastAccOnLine = accCount + line.numAcc;\n            for (accCount; accCount < lastAccOnLine; accCount++) {\n                const xShift = columnXOffsets[line.column - 1] + lineWidth + maxExtraXSpaceNeeded;\n                accidentalLinePositionsAndSpaceNeeds[accCount].acc.setXShift(xShift);\n                lineWidth += accidentalLinePositionsAndSpaceNeeds[accCount].acc.getWidth() + accidentalSpacing;\n                L('Line, accCount, shift: ', line.line, accCount, xShift);\n            }\n        });\n        state.left_shift = totalShift + additionalPadding;\n    }\n    static checkCollision(line1, line2) {\n        let clearance = line2.line - line1.line;\n        let clearanceRequired = 3;\n        if (clearance > 0) {\n            clearanceRequired = line2.flatLine || line2.dblSharpLine ? 2.5 : 3.0;\n            if (line1.dblSharpLine)\n                clearance -= 0.5;\n        }\n        else {\n            clearanceRequired = line1.flatLine || line1.dblSharpLine ? 2.5 : 3.0;\n            if (line2.dblSharpLine)\n                clearance -= 0.5;\n        }\n        const collision = Math.abs(clearance) < clearanceRequired;\n        L('Line_1, Line_2, Collision: ', line1.line, line2.line, collision);\n        return collision;\n    }\n    static applyAccidentals(voices, keySignature) {\n        const tickPositions = [];\n        const tickNoteMap = {};\n        voices.forEach((voice) => {\n            const tickPosition = new Fraction(0, 1);\n            const tickable = voice.getTickables();\n            tickable.forEach((t) => {\n                if (t.shouldIgnoreTicks())\n                    return;\n                const notesAtPosition = tickNoteMap[tickPosition.value()];\n                if (!notesAtPosition) {\n                    tickPositions.push(tickPosition.value());\n                    tickNoteMap[tickPosition.value()] = [t];\n                }\n                else {\n                    notesAtPosition.push(t);\n                }\n                tickPosition.add(t.getTicks());\n            });\n        });\n        const music = new Music();\n        if (!keySignature)\n            keySignature = 'C';\n        const scaleMapKey = music.createScaleMap(keySignature);\n        const scaleMap = {};\n        tickPositions.forEach((tickPos) => {\n            const tickables = tickNoteMap[tickPos];\n            const modifiedPitches = [];\n            const processNote = (t) => {\n                if (!isStaveNote(t) || t.isRest() || t.shouldIgnoreTicks()) {\n                    return;\n                }\n                const staveNote = t;\n                staveNote.keys.forEach((keyString, keyIndex) => {\n                    const key = music.getNoteParts(keyString.split('/')[0]);\n                    const octave = keyString.split('/')[1];\n                    const accidentalString = key.accidental || 'n';\n                    const pitch = key.root + accidentalString;\n                    if (!scaleMap[key.root + octave])\n                        scaleMap[key.root + octave] = scaleMapKey[key.root];\n                    const sameAccidental = scaleMap[key.root + octave] === pitch;\n                    const previouslyModified = modifiedPitches.indexOf(keyString) > -1;\n                    staveNote.getModifiers().forEach((modifier, index) => {\n                        if (isAccidental(modifier) && modifier.type == accidentalString && modifier.getIndex() == keyIndex) {\n                            staveNote.getModifiers().splice(index, 1);\n                        }\n                    });\n                    if (!sameAccidental || (sameAccidental && previouslyModified)) {\n                        scaleMap[key.root + octave] = pitch;\n                        const accidental = new Accidental(accidentalString);\n                        staveNote.addModifier(accidental, keyIndex);\n                        modifiedPitches.push(keyString);\n                    }\n                });\n                staveNote.getModifiers().forEach((modifier) => {\n                    if (isGraceNoteGroup(modifier)) {\n                        modifier.getGraceNotes().forEach(processNote);\n                    }\n                });\n            };\n            tickables.forEach(processNote);\n        });\n    }\n    constructor(type) {\n        super();\n        L('New accidental: ', type);\n        this.type = type;\n        this.position = Modifier.Position.LEFT;\n        this.render_options = {\n            font_scale: Tables.NOTATION_FONT_SCALE,\n            parenLeftPadding: 2,\n            parenRightPadding: 2,\n        };\n        this.accidental = Tables.accidentalCodes(this.type);\n        defined(this.accidental, 'ArgumentError', `Unknown accidental type: ${type}`);\n        this.cautionary = false;\n        this.reset();\n    }\n    reset() {\n        const fontScale = this.render_options.font_scale;\n        this.glyph = new Glyph(this.accidental.code, fontScale);\n        this.glyph.setOriginX(1.0);\n        if (this.cautionary) {\n            this.parenLeft = new Glyph(Tables.accidentalCodes('{').code, fontScale);\n            this.parenRight = new Glyph(Tables.accidentalCodes('}').code, fontScale);\n            this.parenLeft.setOriginX(1.0);\n            this.parenRight.setOriginX(1.0);\n        }\n    }\n    getWidth() {\n        if (this.cautionary) {\n            const parenLeft = defined(this.parenLeft);\n            const parenRight = defined(this.parenRight);\n            const parenWidth = parenLeft.getMetrics().width +\n                parenRight.getMetrics().width +\n                this.render_options.parenLeftPadding +\n                this.render_options.parenRightPadding;\n            return this.glyph.getMetrics().width + parenWidth;\n        }\n        else {\n            return this.glyph.getMetrics().width;\n        }\n    }\n    setNote(note) {\n        defined(note, 'ArgumentError', `Bad note value: ${note}`);\n        this.note = note;\n        if (isGraceNote(note)) {\n            this.render_options.font_scale = 25;\n            this.reset();\n        }\n        return this;\n    }\n    setAsCautionary() {\n        this.cautionary = true;\n        this.render_options.font_scale = 28;\n        this.reset();\n        return this;\n    }\n    draw() {\n        const { type, position, index, cautionary, x_shift, y_shift, glyph, render_options: { parenLeftPadding, parenRightPadding }, } = this;\n        const ctx = this.checkContext();\n        const note = this.checkAttachedNote();\n        this.setRendered();\n        const start = note.getModifierStartXY(position, index);\n        let accX = start.x + x_shift;\n        const accY = start.y + y_shift;\n        L('Rendering: ', type, accX, accY);\n        if (!cautionary) {\n            glyph.render(ctx, accX, accY);\n        }\n        else {\n            const parenLeft = defined(this.parenLeft);\n            const parenRight = defined(this.parenRight);\n            parenRight.render(ctx, accX, accY);\n            accX -= parenRight.getMetrics().width;\n            accX -= parenRightPadding;\n            accX -= this.accidental.parenRightPaddingAdjustment;\n            glyph.render(ctx, accX, accY);\n            accX -= glyph.getMetrics().width;\n            accX -= parenLeftPadding;\n            parenLeft.render(ctx, accX, accY);\n        }\n    }\n}\nAccidental.DEBUG = false;\nexport { Accidental };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}