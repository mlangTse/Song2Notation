{"ast":null,"code":"import { Font, FontStyle, FontWeight } from './font.js';\nimport { Glyph } from './glyph.js';\nimport { Modifier } from './modifier.js';\nimport { Tables } from './tables.js';\nimport { TextFormatter } from './textformatter.js';\nimport { isStemmableNote } from './typeguard.js';\nimport { log, RuntimeError } from './util.js';\nfunction L() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  if (ChordSymbol.DEBUG) log('Vex.Flow.ChordSymbol', args);\n}\nexport var ChordSymbolHorizontalJustify;\n(function (ChordSymbolHorizontalJustify) {\n  ChordSymbolHorizontalJustify[ChordSymbolHorizontalJustify[\"LEFT\"] = 1] = \"LEFT\";\n  ChordSymbolHorizontalJustify[ChordSymbolHorizontalJustify[\"CENTER\"] = 2] = \"CENTER\";\n  ChordSymbolHorizontalJustify[ChordSymbolHorizontalJustify[\"RIGHT\"] = 3] = \"RIGHT\";\n  ChordSymbolHorizontalJustify[ChordSymbolHorizontalJustify[\"CENTER_STEM\"] = 4] = \"CENTER_STEM\";\n})(ChordSymbolHorizontalJustify || (ChordSymbolHorizontalJustify = {}));\nexport var ChordSymbolVerticalJustify;\n(function (ChordSymbolVerticalJustify) {\n  ChordSymbolVerticalJustify[ChordSymbolVerticalJustify[\"TOP\"] = 1] = \"TOP\";\n  ChordSymbolVerticalJustify[ChordSymbolVerticalJustify[\"BOTTOM\"] = 2] = \"BOTTOM\";\n})(ChordSymbolVerticalJustify || (ChordSymbolVerticalJustify = {}));\nexport var SymbolTypes;\n(function (SymbolTypes) {\n  SymbolTypes[SymbolTypes[\"GLYPH\"] = 1] = \"GLYPH\";\n  SymbolTypes[SymbolTypes[\"TEXT\"] = 2] = \"TEXT\";\n  SymbolTypes[SymbolTypes[\"LINE\"] = 3] = \"LINE\";\n})(SymbolTypes || (SymbolTypes = {}));\nexport var SymbolModifiers;\n(function (SymbolModifiers) {\n  SymbolModifiers[SymbolModifiers[\"NONE\"] = 1] = \"NONE\";\n  SymbolModifiers[SymbolModifiers[\"SUBSCRIPT\"] = 2] = \"SUBSCRIPT\";\n  SymbolModifiers[SymbolModifiers[\"SUPERSCRIPT\"] = 3] = \"SUPERSCRIPT\";\n})(SymbolModifiers || (SymbolModifiers = {}));\nclass ChordSymbol extends Modifier {\n  static get CATEGORY() {\n    return \"ChordSymbol\";\n  }\n  static get superSubRatio() {\n    return ChordSymbol.metrics.global.superSubRatio;\n  }\n  static set NO_TEXT_FORMAT(val) {\n    ChordSymbol.noFormat = val;\n  }\n  static get NO_TEXT_FORMAT() {\n    return ChordSymbol.noFormat;\n  }\n  static getMetricForGlyph(glyphCode) {\n    if (ChordSymbol.metrics.glyphs[glyphCode]) {\n      return ChordSymbol.metrics.glyphs[glyphCode];\n    }\n    return undefined;\n  }\n  static get engravingFontResolution() {\n    return Tables.currentMusicFont().getResolution();\n  }\n  static get spacingBetweenBlocks() {\n    return ChordSymbol.metrics.global.spacing / ChordSymbol.engravingFontResolution;\n  }\n  static getWidthForGlyph(glyph) {\n    const metric = ChordSymbol.getMetricForGlyph(glyph.code);\n    if (!metric) {\n      return 0.65;\n    }\n    return metric.advanceWidth / ChordSymbol.engravingFontResolution;\n  }\n  static getYShiftForGlyph(glyph) {\n    const metric = ChordSymbol.getMetricForGlyph(glyph.code);\n    if (!metric) {\n      return 0;\n    }\n    return metric.yOffset / ChordSymbol.engravingFontResolution;\n  }\n  static getXShiftForGlyph(glyph) {\n    const metric = ChordSymbol.getMetricForGlyph(glyph.code);\n    if (!metric) {\n      return 0;\n    }\n    return -1 * metric.leftSideBearing / ChordSymbol.engravingFontResolution;\n  }\n  static get superscriptOffset() {\n    return ChordSymbol.metrics.global.superscriptOffset / ChordSymbol.engravingFontResolution;\n  }\n  static get subscriptOffset() {\n    return ChordSymbol.metrics.global.subscriptOffset / ChordSymbol.engravingFontResolution;\n  }\n  static get kerningOffset() {\n    return ChordSymbol.metrics.global.kerningOffset / ChordSymbol.engravingFontResolution;\n  }\n  static get metrics() {\n    const chordSymbol = Tables.currentMusicFont().getMetrics().chordSymbol;\n    if (!chordSymbol) throw new RuntimeError('BadMetrics', `chordSymbol missing`);\n    return chordSymbol;\n  }\n  static get lowerKerningText() {\n    return ChordSymbol.metrics.global.lowerKerningText;\n  }\n  static get upperKerningText() {\n    return ChordSymbol.metrics.global.upperKerningText;\n  }\n  static isSuperscript(block) {\n    return block.symbolModifier !== undefined && block.symbolModifier === SymbolModifiers.SUPERSCRIPT;\n  }\n  static isSubscript(block) {\n    return block.symbolModifier !== undefined && block.symbolModifier === SymbolModifiers.SUBSCRIPT;\n  }\n  static get minPadding() {\n    const musicFont = Tables.currentMusicFont();\n    return musicFont.lookupMetric('noteHead.minPadding');\n  }\n  static format(symbols, state) {\n    var _a;\n    if (!symbols || symbols.length === 0) return false;\n    let width = 0;\n    let nonSuperWidth = 0;\n    let leftWidth = 0;\n    let rightWidth = 0;\n    let maxLeftGlyphWidth = 0;\n    let maxRightGlyphWidth = 0;\n    for (const symbol of symbols) {\n      const fontSize = Font.convertSizeToPointValue((_a = symbol.textFont) === null || _a === void 0 ? void 0 : _a.size);\n      const fontAdj = Font.scaleSize(fontSize, 0.05);\n      const glyphAdj = fontAdj * 2;\n      const note = symbol.checkAttachedNote();\n      let symbolWidth = 0;\n      let lineSpaces = 1;\n      let vAlign = false;\n      for (let j = 0; j < symbol.symbolBlocks.length; ++j) {\n        const block = symbol.symbolBlocks[j];\n        const sup = ChordSymbol.isSuperscript(block);\n        const sub = ChordSymbol.isSubscript(block);\n        const superSubScale = sup || sub ? ChordSymbol.superSubRatio : 1;\n        const adj = block.symbolType === SymbolTypes.GLYPH ? glyphAdj * superSubScale : fontAdj * superSubScale;\n        if (sup || sub) {\n          lineSpaces = 2;\n        }\n        const fontSize = symbol.textFormatter.fontSizeInPixels;\n        const superSubFontSize = fontSize * superSubScale;\n        if (block.symbolType === SymbolTypes.GLYPH && block.glyph !== undefined) {\n          block.width = ChordSymbol.getWidthForGlyph(block.glyph) * superSubFontSize;\n          block.yShift += ChordSymbol.getYShiftForGlyph(block.glyph) * superSubFontSize;\n          block.xShift += ChordSymbol.getXShiftForGlyph(block.glyph) * superSubFontSize;\n          block.glyph.scale = block.glyph.scale * adj;\n        } else if (block.symbolType === SymbolTypes.TEXT) {\n          block.width = block.width * superSubFontSize;\n          block.yShift += symbol.getYOffsetForText(block.text) * adj;\n        }\n        if (block.symbolType === SymbolTypes.GLYPH && block.glyph !== undefined && block.glyph.code === ChordSymbol.glyphs.over.code) {\n          lineSpaces = 2;\n        }\n        block.width += ChordSymbol.spacingBetweenBlocks * fontSize * superSubScale;\n        if (sup && j > 0) {\n          const prev = symbol.symbolBlocks[j - 1];\n          if (!ChordSymbol.isSuperscript(prev)) {\n            nonSuperWidth = width;\n          }\n        }\n        if (sub && nonSuperWidth > 0) {\n          vAlign = true;\n          block.xShift = block.xShift + (nonSuperWidth - width);\n          width = nonSuperWidth;\n          nonSuperWidth = 0;\n          symbol.setEnableKerning(false);\n        }\n        if (!sup && !sub) {\n          nonSuperWidth = 0;\n        }\n        block.vAlign = vAlign;\n        width += block.width;\n        symbolWidth = width;\n      }\n      symbol.updateKerningAdjustments();\n      symbol.updateOverBarAdjustments();\n      if (symbol.getVertical() === ChordSymbolVerticalJustify.TOP) {\n        symbol.setTextLine(state.top_text_line);\n        state.top_text_line += lineSpaces;\n      } else {\n        symbol.setTextLine(state.text_line + 1);\n        state.text_line += lineSpaces + 1;\n      }\n      if (symbol.getReportWidth() && isStemmableNote(note)) {\n        const glyphWidth = note.getGlyphProps().getWidth();\n        if (symbol.getHorizontal() === ChordSymbolHorizontalJustify.LEFT) {\n          maxLeftGlyphWidth = Math.max(glyphWidth, maxLeftGlyphWidth);\n          leftWidth = Math.max(leftWidth, symbolWidth) + ChordSymbol.minPadding;\n        } else if (symbol.getHorizontal() === ChordSymbolHorizontalJustify.RIGHT) {\n          maxRightGlyphWidth = Math.max(glyphWidth, maxRightGlyphWidth);\n          rightWidth = Math.max(rightWidth, symbolWidth);\n        } else {\n          leftWidth = Math.max(leftWidth, symbolWidth / 2) + ChordSymbol.minPadding;\n          rightWidth = Math.max(rightWidth, symbolWidth / 2);\n          maxLeftGlyphWidth = Math.max(glyphWidth / 2, maxLeftGlyphWidth);\n          maxRightGlyphWidth = Math.max(glyphWidth / 2, maxRightGlyphWidth);\n        }\n      }\n      width = 0;\n    }\n    const rightOverlap = Math.min(Math.max(rightWidth - maxRightGlyphWidth, 0), Math.max(rightWidth - state.right_shift, 0));\n    const leftOverlap = Math.min(Math.max(leftWidth - maxLeftGlyphWidth, 0), Math.max(leftWidth - state.left_shift, 0));\n    state.left_shift += leftOverlap;\n    state.right_shift += rightOverlap;\n    return true;\n  }\n  constructor() {\n    super();\n    this.symbolBlocks = [];\n    this.horizontal = ChordSymbolHorizontalJustify.LEFT;\n    this.vertical = ChordSymbolVerticalJustify.TOP;\n    this.useKerning = true;\n    this.reportWidth = true;\n    this.resetFont();\n  }\n  static get TEXT_FONT() {\n    let family = 'Roboto Slab, Times, serif';\n    if (Tables.currentMusicFont().getName() === 'Petaluma') {\n      family = 'PetalumaScript, Arial, sans-serif';\n    }\n    return {\n      family,\n      size: 12,\n      weight: FontWeight.NORMAL,\n      style: FontStyle.NORMAL\n    };\n  }\n  get superscriptOffset() {\n    return ChordSymbol.superscriptOffset * this.textFormatter.fontSizeInPixels;\n  }\n  get subscriptOffset() {\n    return ChordSymbol.subscriptOffset * this.textFormatter.fontSizeInPixels;\n  }\n  setReportWidth(value) {\n    this.reportWidth = value;\n    return this;\n  }\n  getReportWidth() {\n    return this.reportWidth;\n  }\n  updateOverBarAdjustments() {\n    const barIndex = this.symbolBlocks.findIndex(_ref => {\n      let {\n        symbolType,\n        glyph\n      } = _ref;\n      return symbolType === SymbolTypes.GLYPH && glyph !== undefined && glyph.code === 'csymDiagonalArrangementSlash';\n    });\n    if (barIndex < 0) {\n      return;\n    }\n    const bar = this.symbolBlocks[barIndex];\n    const xoff = bar.width / 4;\n    const yoff = 0.25 * this.textFormatter.fontSizeInPixels;\n    let symIndex = 0;\n    for (symIndex === 0; symIndex < barIndex; ++symIndex) {\n      const symbol = this.symbolBlocks[symIndex];\n      symbol.xShift = symbol.xShift + xoff;\n      symbol.yShift = symbol.yShift - yoff;\n    }\n    for (symIndex = barIndex + 1; symIndex < this.symbolBlocks.length; ++symIndex) {\n      const symbol = this.symbolBlocks[symIndex];\n      symbol.xShift = symbol.xShift - xoff;\n      symbol.yShift = symbol.yShift + yoff;\n    }\n  }\n  updateKerningAdjustments() {\n    let accum = 0;\n    for (let j = 0; j < this.symbolBlocks.length; ++j) {\n      const symbol = this.symbolBlocks[j];\n      accum += this.getKerningAdjustment(j);\n      symbol.xShift += accum;\n    }\n  }\n  getKerningAdjustment(j) {\n    if (!this.useKerning) {\n      return 0;\n    }\n    const currSymbol = this.symbolBlocks[j];\n    const prevSymbol = j > 0 ? this.symbolBlocks[j - 1] : undefined;\n    let adjustment = 0;\n    if (currSymbol.symbolType === SymbolTypes.GLYPH && currSymbol.glyph !== undefined && currSymbol.glyph.code === ChordSymbol.glyphs.over.code) {\n      adjustment += currSymbol.glyph.metrics.x_shift;\n    }\n    if (prevSymbol !== undefined && prevSymbol.symbolType === SymbolTypes.GLYPH && prevSymbol.glyph !== undefined && prevSymbol.glyph.code === ChordSymbol.glyphs.over.code) {\n      adjustment += prevSymbol.glyph.metrics.x_shift;\n    }\n    let preKernUpper = false;\n    let preKernLower = false;\n    if (prevSymbol !== undefined && prevSymbol.symbolType === SymbolTypes.TEXT) {\n      preKernUpper = ChordSymbol.upperKerningText.some(xx => xx === prevSymbol.text[prevSymbol.text.length - 1]);\n      preKernLower = ChordSymbol.lowerKerningText.some(xx => xx === prevSymbol.text[prevSymbol.text.length - 1]);\n    }\n    const kerningOffsetPixels = ChordSymbol.kerningOffset * this.textFormatter.fontSizeInPixels;\n    if (preKernUpper && currSymbol.symbolModifier === SymbolModifiers.SUPERSCRIPT) {\n      adjustment += kerningOffsetPixels;\n    }\n    if (preKernLower && currSymbol.symbolType === SymbolTypes.TEXT) {\n      if (currSymbol.text[0] >= 'a' && currSymbol.text[0] <= 'z') {\n        adjustment += kerningOffsetPixels / 2;\n      }\n      if (ChordSymbol.upperKerningText.some(xx => xx === (prevSymbol === null || prevSymbol === void 0 ? void 0 : prevSymbol.text[prevSymbol.text.length - 1]))) {\n        adjustment += kerningOffsetPixels / 2;\n      }\n    }\n    return adjustment;\n  }\n  getSymbolBlock() {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var _a, _b, _c;\n    const symbolType = (_a = params.symbolType) !== null && _a !== void 0 ? _a : SymbolTypes.TEXT;\n    const symbolBlock = {\n      text: (_b = params.text) !== null && _b !== void 0 ? _b : '',\n      symbolType,\n      symbolModifier: (_c = params.symbolModifier) !== null && _c !== void 0 ? _c : SymbolModifiers.NONE,\n      xShift: 0,\n      yShift: 0,\n      vAlign: false,\n      width: 0\n    };\n    if (symbolType === SymbolTypes.GLYPH && typeof params.glyph === 'string') {\n      const glyphArgs = ChordSymbol.glyphs[params.glyph];\n      const glyphPoints = 20;\n      symbolBlock.glyph = new Glyph(glyphArgs.code, glyphPoints, {\n        category: 'chordSymbol'\n      });\n    } else if (symbolType === SymbolTypes.TEXT) {\n      symbolBlock.width = this.textFormatter.getWidthForTextInEm(symbolBlock.text);\n    } else if (symbolType === SymbolTypes.LINE) {\n      symbolBlock.width = params.width;\n    }\n    return symbolBlock;\n  }\n  addSymbolBlock(parameters) {\n    this.symbolBlocks.push(this.getSymbolBlock(parameters));\n    return this;\n  }\n  addText(text) {\n    let parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const symbolType = SymbolTypes.TEXT;\n    return this.addSymbolBlock(Object.assign(Object.assign({}, parameters), {\n      text,\n      symbolType\n    }));\n  }\n  addTextSuperscript(text) {\n    const symbolType = SymbolTypes.TEXT;\n    const symbolModifier = SymbolModifiers.SUPERSCRIPT;\n    return this.addSymbolBlock({\n      text,\n      symbolType,\n      symbolModifier\n    });\n  }\n  addTextSubscript(text) {\n    const symbolType = SymbolTypes.TEXT;\n    const symbolModifier = SymbolModifiers.SUBSCRIPT;\n    return this.addSymbolBlock({\n      text,\n      symbolType,\n      symbolModifier\n    });\n  }\n  addGlyphSuperscript(glyph) {\n    const symbolType = SymbolTypes.GLYPH;\n    const symbolModifier = SymbolModifiers.SUPERSCRIPT;\n    return this.addSymbolBlock({\n      glyph,\n      symbolType,\n      symbolModifier\n    });\n  }\n  addGlyph(glyph) {\n    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const symbolType = SymbolTypes.GLYPH;\n    return this.addSymbolBlock(Object.assign(Object.assign({}, params), {\n      glyph,\n      symbolType\n    }));\n  }\n  addGlyphOrText(text) {\n    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let str = '';\n    for (let i = 0; i < text.length; ++i) {\n      const char = text[i];\n      if (ChordSymbol.glyphs[char]) {\n        if (str.length > 0) {\n          this.addText(str, params);\n          str = '';\n        }\n        this.addGlyph(char, params);\n      } else {\n        str += char;\n      }\n    }\n    if (str.length > 0) {\n      this.addText(str, params);\n    }\n    return this;\n  }\n  addLine(width) {\n    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const symbolType = SymbolTypes.LINE;\n    return this.addSymbolBlock(Object.assign(Object.assign({}, params), {\n      symbolType,\n      width\n    }));\n  }\n  setFont(f, size, weight, style) {\n    super.setFont(f, size, weight, style);\n    this.textFormatter = TextFormatter.create(this.textFont);\n    return this;\n  }\n  setEnableKerning(val) {\n    this.useKerning = val;\n    return this;\n  }\n  setVertical(vj) {\n    this.vertical = typeof vj === 'string' ? ChordSymbol.VerticalJustifyString[vj] : vj;\n    return this;\n  }\n  getVertical() {\n    return this.vertical;\n  }\n  setHorizontal(hj) {\n    this.horizontal = typeof hj === 'string' ? ChordSymbol.HorizontalJustifyString[hj] : hj;\n    return this;\n  }\n  getHorizontal() {\n    return this.horizontal;\n  }\n  getWidth() {\n    let width = 0;\n    this.symbolBlocks.forEach(symbol => {\n      width += symbol.vAlign ? 0 : symbol.width;\n    });\n    return width;\n  }\n  getYOffsetForText(text) {\n    var _a;\n    let acc = 0;\n    let i = 0;\n    for (i = 0; i < text.length; ++i) {\n      const metrics = this.textFormatter.getGlyphMetrics(text[i]);\n      if (metrics) {\n        const yMax = (_a = metrics.y_max) !== null && _a !== void 0 ? _a : 0;\n        acc = yMax < acc ? yMax : acc;\n      }\n    }\n    const resolution = this.textFormatter.getResolution();\n    return i > 0 ? -1 * (acc / resolution) : 0;\n  }\n  draw() {\n    const ctx = this.checkContext();\n    const note = this.checkAttachedNote();\n    this.setRendered();\n    ctx.save();\n    this.applyStyle();\n    ctx.openGroup('chordsymbol', this.getAttribute('id'));\n    const start = note.getModifierStartXY(Modifier.Position.ABOVE, this.index);\n    ctx.setFont(this.textFont);\n    let y;\n    const hasStem = note.hasStem();\n    const stave = note.checkStave();\n    if (this.vertical === ChordSymbolVerticalJustify.BOTTOM) {\n      y = stave.getYForBottomText(this.text_line + Tables.TEXT_HEIGHT_OFFSET_HACK);\n      if (hasStem) {\n        const stem_ext = note.checkStem().getExtents();\n        const spacing = stave.getSpacingBetweenLines();\n        const stem_base = note.getStemDirection() === 1 ? stem_ext.baseY : stem_ext.topY;\n        y = Math.max(y, stem_base + spacing * (this.text_line + 2));\n      }\n    } else {\n      const topY = Math.min(...note.getYs());\n      y = Math.min(stave.getYForTopText(this.text_line), topY - 10);\n      if (hasStem) {\n        const stem_ext = note.checkStem().getExtents();\n        const spacing = stave.getSpacingBetweenLines();\n        y = Math.min(y, stem_ext.topY - 5 - spacing * this.text_line);\n      }\n    }\n    let x = start.x;\n    if (this.horizontal === ChordSymbolHorizontalJustify.LEFT) {\n      x = start.x;\n    } else if (this.horizontal === ChordSymbolHorizontalJustify.RIGHT) {\n      x = start.x + this.getWidth();\n    } else if (this.horizontal === ChordSymbolHorizontalJustify.CENTER) {\n      x = start.x - this.getWidth() / 2;\n    } else {\n      x = note.getStemX() - this.getWidth() / 2;\n    }\n    L('Rendering ChordSymbol: ', this.textFormatter, x, y);\n    this.symbolBlocks.forEach(symbol => {\n      const isSuper = ChordSymbol.isSuperscript(symbol);\n      const isSub = ChordSymbol.isSubscript(symbol);\n      let curY = y;\n      L('shift was ', symbol.xShift, symbol.yShift);\n      L('curY pre sub ', curY);\n      if (isSuper) {\n        curY += this.superscriptOffset;\n      }\n      if (isSub) {\n        curY += this.subscriptOffset;\n      }\n      L('curY sup/sub ', curY);\n      if (symbol.symbolType === SymbolTypes.TEXT) {\n        if (isSuper || isSub) {\n          ctx.save();\n          if (this.textFont) {\n            const {\n              family,\n              size,\n              weight,\n              style\n            } = this.textFont;\n            const smallerFontSize = Font.scaleSize(size, ChordSymbol.superSubRatio);\n            ctx.setFont(family, smallerFontSize, weight, style);\n          }\n        }\n        L('Rendering Text: ', symbol.text, x + symbol.xShift, curY + symbol.yShift);\n        ctx.fillText(symbol.text, x + symbol.xShift, curY + symbol.yShift);\n        if (isSuper || isSub) {\n          ctx.restore();\n        }\n      } else if (symbol.symbolType === SymbolTypes.GLYPH && symbol.glyph) {\n        curY += symbol.yShift;\n        L('Rendering Glyph: ', symbol.glyph.code, x + symbol.xShift, curY);\n        symbol.glyph.render(ctx, x + symbol.xShift, curY);\n      } else if (symbol.symbolType === SymbolTypes.LINE) {\n        L('Rendering Line : ', symbol.width, x, curY);\n        ctx.beginPath();\n        ctx.setLineWidth(1);\n        ctx.moveTo(x, y);\n        ctx.lineTo(x + symbol.width, curY);\n        ctx.stroke();\n      }\n      x += symbol.width;\n      if (symbol.vAlign) {\n        x += symbol.xShift;\n      }\n    });\n    ctx.closeGroup();\n    this.restoreStyle();\n    ctx.restore();\n  }\n}\nChordSymbol.DEBUG = false;\nChordSymbol.HorizontalJustify = ChordSymbolHorizontalJustify;\nChordSymbol.HorizontalJustifyString = {\n  left: ChordSymbolHorizontalJustify.LEFT,\n  right: ChordSymbolHorizontalJustify.RIGHT,\n  center: ChordSymbolHorizontalJustify.CENTER,\n  centerStem: ChordSymbolHorizontalJustify.CENTER_STEM\n};\nChordSymbol.VerticalJustify = ChordSymbolVerticalJustify;\nChordSymbol.VerticalJustifyString = {\n  top: ChordSymbolVerticalJustify.TOP,\n  above: ChordSymbolVerticalJustify.TOP,\n  below: ChordSymbolVerticalJustify.BOTTOM,\n  bottom: ChordSymbolVerticalJustify.BOTTOM\n};\nChordSymbol.glyphs = {\n  diminished: {\n    code: 'csymDiminished'\n  },\n  dim: {\n    code: 'csymDiminished'\n  },\n  halfDiminished: {\n    code: 'csymHalfDiminished'\n  },\n  '+': {\n    code: 'csymAugmented'\n  },\n  augmented: {\n    code: 'csymAugmented'\n  },\n  majorSeventh: {\n    code: 'csymMajorSeventh'\n  },\n  minor: {\n    code: 'csymMinor'\n  },\n  '-': {\n    code: 'csymMinor'\n  },\n  '(': {\n    code: 'csymParensLeftTall'\n  },\n  leftParen: {\n    code: 'csymParensLeftTall'\n  },\n  ')': {\n    code: 'csymParensRightTall'\n  },\n  rightParen: {\n    code: 'csymParensRightTall'\n  },\n  leftBracket: {\n    code: 'csymBracketLeftTall'\n  },\n  rightBracket: {\n    code: 'csymBracketRightTall'\n  },\n  leftParenTall: {\n    code: 'csymParensLeftVeryTall'\n  },\n  rightParenTall: {\n    code: 'csymParensRightVeryTall'\n  },\n  '/': {\n    code: 'csymDiagonalArrangementSlash'\n  },\n  over: {\n    code: 'csymDiagonalArrangementSlash'\n  },\n  '#': {\n    code: 'accidentalSharp'\n  },\n  b: {\n    code: 'accidentalFlat'\n  }\n};\nChordSymbol.symbolTypes = SymbolTypes;\nChordSymbol.symbolModifiers = SymbolModifiers;\nChordSymbol.noFormat = false;\nexport { ChordSymbol };","map":{"version":3,"names":["Font","FontStyle","FontWeight","Glyph","Modifier","Tables","TextFormatter","isStemmableNote","log","RuntimeError","L","_len","arguments","length","args","Array","_key","ChordSymbol","DEBUG","ChordSymbolHorizontalJustify","ChordSymbolVerticalJustify","SymbolTypes","SymbolModifiers","CATEGORY","superSubRatio","metrics","global","NO_TEXT_FORMAT","val","noFormat","getMetricForGlyph","glyphCode","glyphs","undefined","engravingFontResolution","currentMusicFont","getResolution","spacingBetweenBlocks","spacing","getWidthForGlyph","glyph","metric","code","advanceWidth","getYShiftForGlyph","yOffset","getXShiftForGlyph","leftSideBearing","superscriptOffset","subscriptOffset","kerningOffset","chordSymbol","getMetrics","lowerKerningText","upperKerningText","isSuperscript","block","symbolModifier","SUPERSCRIPT","isSubscript","SUBSCRIPT","minPadding","musicFont","lookupMetric","format","symbols","state","_a","width","nonSuperWidth","leftWidth","rightWidth","maxLeftGlyphWidth","maxRightGlyphWidth","symbol","fontSize","convertSizeToPointValue","textFont","size","fontAdj","scaleSize","glyphAdj","note","checkAttachedNote","symbolWidth","lineSpaces","vAlign","j","symbolBlocks","sup","sub","superSubScale","adj","symbolType","GLYPH","textFormatter","fontSizeInPixels","superSubFontSize","yShift","xShift","scale","TEXT","getYOffsetForText","text","over","prev","setEnableKerning","updateKerningAdjustments","updateOverBarAdjustments","getVertical","TOP","setTextLine","top_text_line","text_line","getReportWidth","glyphWidth","getGlyphProps","getWidth","getHorizontal","LEFT","Math","max","RIGHT","rightOverlap","min","right_shift","leftOverlap","left_shift","constructor","horizontal","vertical","useKerning","reportWidth","resetFont","TEXT_FONT","family","getName","weight","NORMAL","style","setReportWidth","value","barIndex","findIndex","_ref","bar","xoff","yoff","symIndex","accum","getKerningAdjustment","currSymbol","prevSymbol","adjustment","x_shift","preKernUpper","preKernLower","some","xx","kerningOffsetPixels","getSymbolBlock","params","_b","_c","symbolBlock","NONE","glyphArgs","glyphPoints","category","getWidthForTextInEm","LINE","addSymbolBlock","parameters","push","addText","Object","assign","addTextSuperscript","addTextSubscript","addGlyphSuperscript","addGlyph","addGlyphOrText","str","i","char","addLine","setFont","f","create","setVertical","vj","VerticalJustifyString","setHorizontal","hj","HorizontalJustifyString","forEach","acc","getGlyphMetrics","yMax","y_max","resolution","draw","ctx","checkContext","setRendered","save","applyStyle","openGroup","getAttribute","start","getModifierStartXY","Position","ABOVE","index","y","hasStem","stave","checkStave","BOTTOM","getYForBottomText","TEXT_HEIGHT_OFFSET_HACK","stem_ext","checkStem","getExtents","getSpacingBetweenLines","stem_base","getStemDirection","baseY","topY","getYs","getYForTopText","x","CENTER","getStemX","isSuper","isSub","curY","smallerFontSize","fillText","restore","render","beginPath","setLineWidth","moveTo","lineTo","stroke","closeGroup","restoreStyle","HorizontalJustify","left","right","center","centerStem","CENTER_STEM","VerticalJustify","top","above","below","bottom","diminished","dim","halfDiminished","augmented","majorSeventh","minor","leftParen","rightParen","leftBracket","rightBracket","leftParenTall","rightParenTall","b","symbolTypes","symbolModifiers"],"sources":["/Users/lang/Documents/code/Song2Notation/frontend/node_modules/vexflow/build/esm/src/chordsymbol.js"],"sourcesContent":["import { Font, FontStyle, FontWeight } from './font.js';\nimport { Glyph } from './glyph.js';\nimport { Modifier } from './modifier.js';\nimport { Tables } from './tables.js';\nimport { TextFormatter } from './textformatter.js';\nimport { isStemmableNote } from './typeguard.js';\nimport { log, RuntimeError } from './util.js';\nfunction L(...args) {\n    if (ChordSymbol.DEBUG)\n        log('Vex.Flow.ChordSymbol', args);\n}\nexport var ChordSymbolHorizontalJustify;\n(function (ChordSymbolHorizontalJustify) {\n    ChordSymbolHorizontalJustify[ChordSymbolHorizontalJustify[\"LEFT\"] = 1] = \"LEFT\";\n    ChordSymbolHorizontalJustify[ChordSymbolHorizontalJustify[\"CENTER\"] = 2] = \"CENTER\";\n    ChordSymbolHorizontalJustify[ChordSymbolHorizontalJustify[\"RIGHT\"] = 3] = \"RIGHT\";\n    ChordSymbolHorizontalJustify[ChordSymbolHorizontalJustify[\"CENTER_STEM\"] = 4] = \"CENTER_STEM\";\n})(ChordSymbolHorizontalJustify || (ChordSymbolHorizontalJustify = {}));\nexport var ChordSymbolVerticalJustify;\n(function (ChordSymbolVerticalJustify) {\n    ChordSymbolVerticalJustify[ChordSymbolVerticalJustify[\"TOP\"] = 1] = \"TOP\";\n    ChordSymbolVerticalJustify[ChordSymbolVerticalJustify[\"BOTTOM\"] = 2] = \"BOTTOM\";\n})(ChordSymbolVerticalJustify || (ChordSymbolVerticalJustify = {}));\nexport var SymbolTypes;\n(function (SymbolTypes) {\n    SymbolTypes[SymbolTypes[\"GLYPH\"] = 1] = \"GLYPH\";\n    SymbolTypes[SymbolTypes[\"TEXT\"] = 2] = \"TEXT\";\n    SymbolTypes[SymbolTypes[\"LINE\"] = 3] = \"LINE\";\n})(SymbolTypes || (SymbolTypes = {}));\nexport var SymbolModifiers;\n(function (SymbolModifiers) {\n    SymbolModifiers[SymbolModifiers[\"NONE\"] = 1] = \"NONE\";\n    SymbolModifiers[SymbolModifiers[\"SUBSCRIPT\"] = 2] = \"SUBSCRIPT\";\n    SymbolModifiers[SymbolModifiers[\"SUPERSCRIPT\"] = 3] = \"SUPERSCRIPT\";\n})(SymbolModifiers || (SymbolModifiers = {}));\nclass ChordSymbol extends Modifier {\n    static get CATEGORY() {\n        return \"ChordSymbol\";\n    }\n    static get superSubRatio() {\n        return ChordSymbol.metrics.global.superSubRatio;\n    }\n    static set NO_TEXT_FORMAT(val) {\n        ChordSymbol.noFormat = val;\n    }\n    static get NO_TEXT_FORMAT() {\n        return ChordSymbol.noFormat;\n    }\n    static getMetricForGlyph(glyphCode) {\n        if (ChordSymbol.metrics.glyphs[glyphCode]) {\n            return ChordSymbol.metrics.glyphs[glyphCode];\n        }\n        return undefined;\n    }\n    static get engravingFontResolution() {\n        return Tables.currentMusicFont().getResolution();\n    }\n    static get spacingBetweenBlocks() {\n        return ChordSymbol.metrics.global.spacing / ChordSymbol.engravingFontResolution;\n    }\n    static getWidthForGlyph(glyph) {\n        const metric = ChordSymbol.getMetricForGlyph(glyph.code);\n        if (!metric) {\n            return 0.65;\n        }\n        return metric.advanceWidth / ChordSymbol.engravingFontResolution;\n    }\n    static getYShiftForGlyph(glyph) {\n        const metric = ChordSymbol.getMetricForGlyph(glyph.code);\n        if (!metric) {\n            return 0;\n        }\n        return metric.yOffset / ChordSymbol.engravingFontResolution;\n    }\n    static getXShiftForGlyph(glyph) {\n        const metric = ChordSymbol.getMetricForGlyph(glyph.code);\n        if (!metric) {\n            return 0;\n        }\n        return (-1 * metric.leftSideBearing) / ChordSymbol.engravingFontResolution;\n    }\n    static get superscriptOffset() {\n        return ChordSymbol.metrics.global.superscriptOffset / ChordSymbol.engravingFontResolution;\n    }\n    static get subscriptOffset() {\n        return ChordSymbol.metrics.global.subscriptOffset / ChordSymbol.engravingFontResolution;\n    }\n    static get kerningOffset() {\n        return ChordSymbol.metrics.global.kerningOffset / ChordSymbol.engravingFontResolution;\n    }\n    static get metrics() {\n        const chordSymbol = Tables.currentMusicFont().getMetrics().chordSymbol;\n        if (!chordSymbol)\n            throw new RuntimeError('BadMetrics', `chordSymbol missing`);\n        return chordSymbol;\n    }\n    static get lowerKerningText() {\n        return ChordSymbol.metrics.global.lowerKerningText;\n    }\n    static get upperKerningText() {\n        return ChordSymbol.metrics.global.upperKerningText;\n    }\n    static isSuperscript(block) {\n        return block.symbolModifier !== undefined && block.symbolModifier === SymbolModifiers.SUPERSCRIPT;\n    }\n    static isSubscript(block) {\n        return block.symbolModifier !== undefined && block.symbolModifier === SymbolModifiers.SUBSCRIPT;\n    }\n    static get minPadding() {\n        const musicFont = Tables.currentMusicFont();\n        return musicFont.lookupMetric('noteHead.minPadding');\n    }\n    static format(symbols, state) {\n        var _a;\n        if (!symbols || symbols.length === 0)\n            return false;\n        let width = 0;\n        let nonSuperWidth = 0;\n        let leftWidth = 0;\n        let rightWidth = 0;\n        let maxLeftGlyphWidth = 0;\n        let maxRightGlyphWidth = 0;\n        for (const symbol of symbols) {\n            const fontSize = Font.convertSizeToPointValue((_a = symbol.textFont) === null || _a === void 0 ? void 0 : _a.size);\n            const fontAdj = Font.scaleSize(fontSize, 0.05);\n            const glyphAdj = fontAdj * 2;\n            const note = symbol.checkAttachedNote();\n            let symbolWidth = 0;\n            let lineSpaces = 1;\n            let vAlign = false;\n            for (let j = 0; j < symbol.symbolBlocks.length; ++j) {\n                const block = symbol.symbolBlocks[j];\n                const sup = ChordSymbol.isSuperscript(block);\n                const sub = ChordSymbol.isSubscript(block);\n                const superSubScale = sup || sub ? ChordSymbol.superSubRatio : 1;\n                const adj = block.symbolType === SymbolTypes.GLYPH ? glyphAdj * superSubScale : fontAdj * superSubScale;\n                if (sup || sub) {\n                    lineSpaces = 2;\n                }\n                const fontSize = symbol.textFormatter.fontSizeInPixels;\n                const superSubFontSize = fontSize * superSubScale;\n                if (block.symbolType === SymbolTypes.GLYPH && block.glyph !== undefined) {\n                    block.width = ChordSymbol.getWidthForGlyph(block.glyph) * superSubFontSize;\n                    block.yShift += ChordSymbol.getYShiftForGlyph(block.glyph) * superSubFontSize;\n                    block.xShift += ChordSymbol.getXShiftForGlyph(block.glyph) * superSubFontSize;\n                    block.glyph.scale = block.glyph.scale * adj;\n                }\n                else if (block.symbolType === SymbolTypes.TEXT) {\n                    block.width = block.width * superSubFontSize;\n                    block.yShift += symbol.getYOffsetForText(block.text) * adj;\n                }\n                if (block.symbolType === SymbolTypes.GLYPH &&\n                    block.glyph !== undefined &&\n                    block.glyph.code === ChordSymbol.glyphs.over.code) {\n                    lineSpaces = 2;\n                }\n                block.width += ChordSymbol.spacingBetweenBlocks * fontSize * superSubScale;\n                if (sup && j > 0) {\n                    const prev = symbol.symbolBlocks[j - 1];\n                    if (!ChordSymbol.isSuperscript(prev)) {\n                        nonSuperWidth = width;\n                    }\n                }\n                if (sub && nonSuperWidth > 0) {\n                    vAlign = true;\n                    block.xShift = block.xShift + (nonSuperWidth - width);\n                    width = nonSuperWidth;\n                    nonSuperWidth = 0;\n                    symbol.setEnableKerning(false);\n                }\n                if (!sup && !sub) {\n                    nonSuperWidth = 0;\n                }\n                block.vAlign = vAlign;\n                width += block.width;\n                symbolWidth = width;\n            }\n            symbol.updateKerningAdjustments();\n            symbol.updateOverBarAdjustments();\n            if (symbol.getVertical() === ChordSymbolVerticalJustify.TOP) {\n                symbol.setTextLine(state.top_text_line);\n                state.top_text_line += lineSpaces;\n            }\n            else {\n                symbol.setTextLine(state.text_line + 1);\n                state.text_line += lineSpaces + 1;\n            }\n            if (symbol.getReportWidth() && isStemmableNote(note)) {\n                const glyphWidth = note.getGlyphProps().getWidth();\n                if (symbol.getHorizontal() === ChordSymbolHorizontalJustify.LEFT) {\n                    maxLeftGlyphWidth = Math.max(glyphWidth, maxLeftGlyphWidth);\n                    leftWidth = Math.max(leftWidth, symbolWidth) + ChordSymbol.minPadding;\n                }\n                else if (symbol.getHorizontal() === ChordSymbolHorizontalJustify.RIGHT) {\n                    maxRightGlyphWidth = Math.max(glyphWidth, maxRightGlyphWidth);\n                    rightWidth = Math.max(rightWidth, symbolWidth);\n                }\n                else {\n                    leftWidth = Math.max(leftWidth, symbolWidth / 2) + ChordSymbol.minPadding;\n                    rightWidth = Math.max(rightWidth, symbolWidth / 2);\n                    maxLeftGlyphWidth = Math.max(glyphWidth / 2, maxLeftGlyphWidth);\n                    maxRightGlyphWidth = Math.max(glyphWidth / 2, maxRightGlyphWidth);\n                }\n            }\n            width = 0;\n        }\n        const rightOverlap = Math.min(Math.max(rightWidth - maxRightGlyphWidth, 0), Math.max(rightWidth - state.right_shift, 0));\n        const leftOverlap = Math.min(Math.max(leftWidth - maxLeftGlyphWidth, 0), Math.max(leftWidth - state.left_shift, 0));\n        state.left_shift += leftOverlap;\n        state.right_shift += rightOverlap;\n        return true;\n    }\n    constructor() {\n        super();\n        this.symbolBlocks = [];\n        this.horizontal = ChordSymbolHorizontalJustify.LEFT;\n        this.vertical = ChordSymbolVerticalJustify.TOP;\n        this.useKerning = true;\n        this.reportWidth = true;\n        this.resetFont();\n    }\n    static get TEXT_FONT() {\n        let family = 'Roboto Slab, Times, serif';\n        if (Tables.currentMusicFont().getName() === 'Petaluma') {\n            family = 'PetalumaScript, Arial, sans-serif';\n        }\n        return {\n            family,\n            size: 12,\n            weight: FontWeight.NORMAL,\n            style: FontStyle.NORMAL,\n        };\n    }\n    get superscriptOffset() {\n        return ChordSymbol.superscriptOffset * this.textFormatter.fontSizeInPixels;\n    }\n    get subscriptOffset() {\n        return ChordSymbol.subscriptOffset * this.textFormatter.fontSizeInPixels;\n    }\n    setReportWidth(value) {\n        this.reportWidth = value;\n        return this;\n    }\n    getReportWidth() {\n        return this.reportWidth;\n    }\n    updateOverBarAdjustments() {\n        const barIndex = this.symbolBlocks.findIndex(({ symbolType, glyph }) => symbolType === SymbolTypes.GLYPH && glyph !== undefined && glyph.code === 'csymDiagonalArrangementSlash');\n        if (barIndex < 0) {\n            return;\n        }\n        const bar = this.symbolBlocks[barIndex];\n        const xoff = bar.width / 4;\n        const yoff = 0.25 * this.textFormatter.fontSizeInPixels;\n        let symIndex = 0;\n        for (symIndex === 0; symIndex < barIndex; ++symIndex) {\n            const symbol = this.symbolBlocks[symIndex];\n            symbol.xShift = symbol.xShift + xoff;\n            symbol.yShift = symbol.yShift - yoff;\n        }\n        for (symIndex = barIndex + 1; symIndex < this.symbolBlocks.length; ++symIndex) {\n            const symbol = this.symbolBlocks[symIndex];\n            symbol.xShift = symbol.xShift - xoff;\n            symbol.yShift = symbol.yShift + yoff;\n        }\n    }\n    updateKerningAdjustments() {\n        let accum = 0;\n        for (let j = 0; j < this.symbolBlocks.length; ++j) {\n            const symbol = this.symbolBlocks[j];\n            accum += this.getKerningAdjustment(j);\n            symbol.xShift += accum;\n        }\n    }\n    getKerningAdjustment(j) {\n        if (!this.useKerning) {\n            return 0;\n        }\n        const currSymbol = this.symbolBlocks[j];\n        const prevSymbol = j > 0 ? this.symbolBlocks[j - 1] : undefined;\n        let adjustment = 0;\n        if (currSymbol.symbolType === SymbolTypes.GLYPH &&\n            currSymbol.glyph !== undefined &&\n            currSymbol.glyph.code === ChordSymbol.glyphs.over.code) {\n            adjustment += currSymbol.glyph.metrics.x_shift;\n        }\n        if (prevSymbol !== undefined &&\n            prevSymbol.symbolType === SymbolTypes.GLYPH &&\n            prevSymbol.glyph !== undefined &&\n            prevSymbol.glyph.code === ChordSymbol.glyphs.over.code) {\n            adjustment += prevSymbol.glyph.metrics.x_shift;\n        }\n        let preKernUpper = false;\n        let preKernLower = false;\n        if (prevSymbol !== undefined && prevSymbol.symbolType === SymbolTypes.TEXT) {\n            preKernUpper = ChordSymbol.upperKerningText.some((xx) => xx === prevSymbol.text[prevSymbol.text.length - 1]);\n            preKernLower = ChordSymbol.lowerKerningText.some((xx) => xx === prevSymbol.text[prevSymbol.text.length - 1]);\n        }\n        const kerningOffsetPixels = ChordSymbol.kerningOffset * this.textFormatter.fontSizeInPixels;\n        if (preKernUpper && currSymbol.symbolModifier === SymbolModifiers.SUPERSCRIPT) {\n            adjustment += kerningOffsetPixels;\n        }\n        if (preKernLower && currSymbol.symbolType === SymbolTypes.TEXT) {\n            if (currSymbol.text[0] >= 'a' && currSymbol.text[0] <= 'z') {\n                adjustment += kerningOffsetPixels / 2;\n            }\n            if (ChordSymbol.upperKerningText.some((xx) => xx === (prevSymbol === null || prevSymbol === void 0 ? void 0 : prevSymbol.text[prevSymbol.text.length - 1]))) {\n                adjustment += kerningOffsetPixels / 2;\n            }\n        }\n        return adjustment;\n    }\n    getSymbolBlock(params = {}) {\n        var _a, _b, _c;\n        const symbolType = (_a = params.symbolType) !== null && _a !== void 0 ? _a : SymbolTypes.TEXT;\n        const symbolBlock = {\n            text: (_b = params.text) !== null && _b !== void 0 ? _b : '',\n            symbolType,\n            symbolModifier: (_c = params.symbolModifier) !== null && _c !== void 0 ? _c : SymbolModifiers.NONE,\n            xShift: 0,\n            yShift: 0,\n            vAlign: false,\n            width: 0,\n        };\n        if (symbolType === SymbolTypes.GLYPH && typeof params.glyph === 'string') {\n            const glyphArgs = ChordSymbol.glyphs[params.glyph];\n            const glyphPoints = 20;\n            symbolBlock.glyph = new Glyph(glyphArgs.code, glyphPoints, { category: 'chordSymbol' });\n        }\n        else if (symbolType === SymbolTypes.TEXT) {\n            symbolBlock.width = this.textFormatter.getWidthForTextInEm(symbolBlock.text);\n        }\n        else if (symbolType === SymbolTypes.LINE) {\n            symbolBlock.width = params.width;\n        }\n        return symbolBlock;\n    }\n    addSymbolBlock(parameters) {\n        this.symbolBlocks.push(this.getSymbolBlock(parameters));\n        return this;\n    }\n    addText(text, parameters = {}) {\n        const symbolType = SymbolTypes.TEXT;\n        return this.addSymbolBlock(Object.assign(Object.assign({}, parameters), { text, symbolType }));\n    }\n    addTextSuperscript(text) {\n        const symbolType = SymbolTypes.TEXT;\n        const symbolModifier = SymbolModifiers.SUPERSCRIPT;\n        return this.addSymbolBlock({ text, symbolType, symbolModifier });\n    }\n    addTextSubscript(text) {\n        const symbolType = SymbolTypes.TEXT;\n        const symbolModifier = SymbolModifiers.SUBSCRIPT;\n        return this.addSymbolBlock({ text, symbolType, symbolModifier });\n    }\n    addGlyphSuperscript(glyph) {\n        const symbolType = SymbolTypes.GLYPH;\n        const symbolModifier = SymbolModifiers.SUPERSCRIPT;\n        return this.addSymbolBlock({ glyph, symbolType, symbolModifier });\n    }\n    addGlyph(glyph, params = {}) {\n        const symbolType = SymbolTypes.GLYPH;\n        return this.addSymbolBlock(Object.assign(Object.assign({}, params), { glyph, symbolType }));\n    }\n    addGlyphOrText(text, params = {}) {\n        let str = '';\n        for (let i = 0; i < text.length; ++i) {\n            const char = text[i];\n            if (ChordSymbol.glyphs[char]) {\n                if (str.length > 0) {\n                    this.addText(str, params);\n                    str = '';\n                }\n                this.addGlyph(char, params);\n            }\n            else {\n                str += char;\n            }\n        }\n        if (str.length > 0) {\n            this.addText(str, params);\n        }\n        return this;\n    }\n    addLine(width, params = {}) {\n        const symbolType = SymbolTypes.LINE;\n        return this.addSymbolBlock(Object.assign(Object.assign({}, params), { symbolType, width }));\n    }\n    setFont(f, size, weight, style) {\n        super.setFont(f, size, weight, style);\n        this.textFormatter = TextFormatter.create(this.textFont);\n        return this;\n    }\n    setEnableKerning(val) {\n        this.useKerning = val;\n        return this;\n    }\n    setVertical(vj) {\n        this.vertical = typeof vj === 'string' ? ChordSymbol.VerticalJustifyString[vj] : vj;\n        return this;\n    }\n    getVertical() {\n        return this.vertical;\n    }\n    setHorizontal(hj) {\n        this.horizontal = typeof hj === 'string' ? ChordSymbol.HorizontalJustifyString[hj] : hj;\n        return this;\n    }\n    getHorizontal() {\n        return this.horizontal;\n    }\n    getWidth() {\n        let width = 0;\n        this.symbolBlocks.forEach((symbol) => {\n            width += symbol.vAlign ? 0 : symbol.width;\n        });\n        return width;\n    }\n    getYOffsetForText(text) {\n        var _a;\n        let acc = 0;\n        let i = 0;\n        for (i = 0; i < text.length; ++i) {\n            const metrics = this.textFormatter.getGlyphMetrics(text[i]);\n            if (metrics) {\n                const yMax = (_a = metrics.y_max) !== null && _a !== void 0 ? _a : 0;\n                acc = yMax < acc ? yMax : acc;\n            }\n        }\n        const resolution = this.textFormatter.getResolution();\n        return i > 0 ? -1 * (acc / resolution) : 0;\n    }\n    draw() {\n        const ctx = this.checkContext();\n        const note = this.checkAttachedNote();\n        this.setRendered();\n        ctx.save();\n        this.applyStyle();\n        ctx.openGroup('chordsymbol', this.getAttribute('id'));\n        const start = note.getModifierStartXY(Modifier.Position.ABOVE, this.index);\n        ctx.setFont(this.textFont);\n        let y;\n        const hasStem = note.hasStem();\n        const stave = note.checkStave();\n        if (this.vertical === ChordSymbolVerticalJustify.BOTTOM) {\n            y = stave.getYForBottomText(this.text_line + Tables.TEXT_HEIGHT_OFFSET_HACK);\n            if (hasStem) {\n                const stem_ext = note.checkStem().getExtents();\n                const spacing = stave.getSpacingBetweenLines();\n                const stem_base = note.getStemDirection() === 1 ? stem_ext.baseY : stem_ext.topY;\n                y = Math.max(y, stem_base + spacing * (this.text_line + 2));\n            }\n        }\n        else {\n            const topY = Math.min(...note.getYs());\n            y = Math.min(stave.getYForTopText(this.text_line), topY - 10);\n            if (hasStem) {\n                const stem_ext = note.checkStem().getExtents();\n                const spacing = stave.getSpacingBetweenLines();\n                y = Math.min(y, stem_ext.topY - 5 - spacing * this.text_line);\n            }\n        }\n        let x = start.x;\n        if (this.horizontal === ChordSymbolHorizontalJustify.LEFT) {\n            x = start.x;\n        }\n        else if (this.horizontal === ChordSymbolHorizontalJustify.RIGHT) {\n            x = start.x + this.getWidth();\n        }\n        else if (this.horizontal === ChordSymbolHorizontalJustify.CENTER) {\n            x = start.x - this.getWidth() / 2;\n        }\n        else {\n            x = note.getStemX() - this.getWidth() / 2;\n        }\n        L('Rendering ChordSymbol: ', this.textFormatter, x, y);\n        this.symbolBlocks.forEach((symbol) => {\n            const isSuper = ChordSymbol.isSuperscript(symbol);\n            const isSub = ChordSymbol.isSubscript(symbol);\n            let curY = y;\n            L('shift was ', symbol.xShift, symbol.yShift);\n            L('curY pre sub ', curY);\n            if (isSuper) {\n                curY += this.superscriptOffset;\n            }\n            if (isSub) {\n                curY += this.subscriptOffset;\n            }\n            L('curY sup/sub ', curY);\n            if (symbol.symbolType === SymbolTypes.TEXT) {\n                if (isSuper || isSub) {\n                    ctx.save();\n                    if (this.textFont) {\n                        const { family, size, weight, style } = this.textFont;\n                        const smallerFontSize = Font.scaleSize(size, ChordSymbol.superSubRatio);\n                        ctx.setFont(family, smallerFontSize, weight, style);\n                    }\n                }\n                L('Rendering Text: ', symbol.text, x + symbol.xShift, curY + symbol.yShift);\n                ctx.fillText(symbol.text, x + symbol.xShift, curY + symbol.yShift);\n                if (isSuper || isSub) {\n                    ctx.restore();\n                }\n            }\n            else if (symbol.symbolType === SymbolTypes.GLYPH && symbol.glyph) {\n                curY += symbol.yShift;\n                L('Rendering Glyph: ', symbol.glyph.code, x + symbol.xShift, curY);\n                symbol.glyph.render(ctx, x + symbol.xShift, curY);\n            }\n            else if (symbol.symbolType === SymbolTypes.LINE) {\n                L('Rendering Line : ', symbol.width, x, curY);\n                ctx.beginPath();\n                ctx.setLineWidth(1);\n                ctx.moveTo(x, y);\n                ctx.lineTo(x + symbol.width, curY);\n                ctx.stroke();\n            }\n            x += symbol.width;\n            if (symbol.vAlign) {\n                x += symbol.xShift;\n            }\n        });\n        ctx.closeGroup();\n        this.restoreStyle();\n        ctx.restore();\n    }\n}\nChordSymbol.DEBUG = false;\nChordSymbol.HorizontalJustify = ChordSymbolHorizontalJustify;\nChordSymbol.HorizontalJustifyString = {\n    left: ChordSymbolHorizontalJustify.LEFT,\n    right: ChordSymbolHorizontalJustify.RIGHT,\n    center: ChordSymbolHorizontalJustify.CENTER,\n    centerStem: ChordSymbolHorizontalJustify.CENTER_STEM,\n};\nChordSymbol.VerticalJustify = ChordSymbolVerticalJustify;\nChordSymbol.VerticalJustifyString = {\n    top: ChordSymbolVerticalJustify.TOP,\n    above: ChordSymbolVerticalJustify.TOP,\n    below: ChordSymbolVerticalJustify.BOTTOM,\n    bottom: ChordSymbolVerticalJustify.BOTTOM,\n};\nChordSymbol.glyphs = {\n    diminished: {\n        code: 'csymDiminished',\n    },\n    dim: {\n        code: 'csymDiminished',\n    },\n    halfDiminished: {\n        code: 'csymHalfDiminished',\n    },\n    '+': {\n        code: 'csymAugmented',\n    },\n    augmented: {\n        code: 'csymAugmented',\n    },\n    majorSeventh: {\n        code: 'csymMajorSeventh',\n    },\n    minor: {\n        code: 'csymMinor',\n    },\n    '-': {\n        code: 'csymMinor',\n    },\n    '(': {\n        code: 'csymParensLeftTall',\n    },\n    leftParen: {\n        code: 'csymParensLeftTall',\n    },\n    ')': {\n        code: 'csymParensRightTall',\n    },\n    rightParen: {\n        code: 'csymParensRightTall',\n    },\n    leftBracket: {\n        code: 'csymBracketLeftTall',\n    },\n    rightBracket: {\n        code: 'csymBracketRightTall',\n    },\n    leftParenTall: {\n        code: 'csymParensLeftVeryTall',\n    },\n    rightParenTall: {\n        code: 'csymParensRightVeryTall',\n    },\n    '/': {\n        code: 'csymDiagonalArrangementSlash',\n    },\n    over: {\n        code: 'csymDiagonalArrangementSlash',\n    },\n    '#': {\n        code: 'accidentalSharp',\n    },\n    b: {\n        code: 'accidentalFlat',\n    },\n};\nChordSymbol.symbolTypes = SymbolTypes;\nChordSymbol.symbolModifiers = SymbolModifiers;\nChordSymbol.noFormat = false;\nexport { ChordSymbol };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}