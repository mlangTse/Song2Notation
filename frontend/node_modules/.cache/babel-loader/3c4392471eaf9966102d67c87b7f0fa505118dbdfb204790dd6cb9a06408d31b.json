{"ast":null,"code":"import { Element } from './element.js';\nimport { Fraction } from './fraction.js';\nimport { Stem } from './stem.js';\nimport { Tables } from './tables.js';\nimport { isStaveNote, isTabNote } from './typeguard.js';\nimport { RuntimeError } from './util.js';\nfunction calculateStemDirection(notes) {\n  let lineSum = 0;\n  notes.forEach(note => {\n    if (note.keyProps) {\n      note.keyProps.forEach(keyProp => {\n        lineSum += keyProp.line - 3;\n      });\n    }\n  });\n  if (lineSum >= 0) {\n    return Stem.DOWN;\n  }\n  return Stem.UP;\n}\nfunction getStemSlope(firstNote, lastNote) {\n  const firstStemTipY = firstNote.getStemExtents().topY;\n  const firstStemX = firstNote.getStemX();\n  const lastStemTipY = lastNote.getStemExtents().topY;\n  const lastStemX = lastNote.getStemX();\n  return (lastStemTipY - firstStemTipY) / (lastStemX - firstStemX);\n}\nexport const BEAM_LEFT = 'L';\nexport const BEAM_RIGHT = 'R';\nexport const BEAM_BOTH = 'B';\nexport class Beam extends Element {\n  static get CATEGORY() {\n    return \"Beam\";\n  }\n  getStemDirection() {\n    return this.stem_direction;\n  }\n  static getDefaultBeamGroups(time_sig) {\n    if (!time_sig || time_sig === 'c') {\n      time_sig = '4/4';\n    }\n    const defaults = {\n      '1/2': ['1/2'],\n      '2/2': ['1/2'],\n      '3/2': ['1/2'],\n      '4/2': ['1/2'],\n      '1/4': ['1/4'],\n      '2/4': ['1/4'],\n      '3/4': ['1/4'],\n      '4/4': ['1/4'],\n      '1/8': ['1/8'],\n      '2/8': ['2/8'],\n      '3/8': ['3/8'],\n      '4/8': ['2/8'],\n      '1/16': ['1/16'],\n      '2/16': ['2/16'],\n      '3/16': ['3/16'],\n      '4/16': ['2/16']\n    };\n    const groups = defaults[time_sig];\n    if (groups === undefined) {\n      const beatTotal = parseInt(time_sig.split('/')[0], 10);\n      const beatValue = parseInt(time_sig.split('/')[1], 10);\n      const tripleMeter = beatTotal % 3 === 0;\n      if (tripleMeter) {\n        return [new Fraction(3, beatValue)];\n      } else if (beatValue > 4) {\n        return [new Fraction(2, beatValue)];\n      } else if (beatValue <= 4) {\n        return [new Fraction(1, beatValue)];\n      }\n    } else {\n      return groups.map(group => new Fraction().parse(group));\n    }\n    return [new Fraction(1, 4)];\n  }\n  static applyAndGetBeams(voice, stem_direction, groups) {\n    return Beam.generateBeams(voice.getTickables(), {\n      groups,\n      stem_direction\n    });\n  }\n  static generateBeams(notes) {\n    let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!config.groups || !config.groups.length) {\n      config.groups = [new Fraction(2, 8)];\n    }\n    const tickGroups = config.groups.map(group => {\n      if (!group.multiply) {\n        throw new RuntimeError('InvalidBeamGroups', 'The beam groups must be an array of Vex.Flow.Fractions');\n      }\n      return group.clone().multiply(Tables.RESOLUTION, 1);\n    });\n    const unprocessedNotes = notes;\n    let currentTickGroup = 0;\n    let noteGroups = [];\n    let currentGroup = [];\n    function getTotalTicks(vf_notes) {\n      return vf_notes.reduce((memo, note) => note.getTicks().clone().add(memo), new Fraction(0, 1));\n    }\n    function nextTickGroup() {\n      if (tickGroups.length - 1 > currentTickGroup) {\n        currentTickGroup += 1;\n      } else {\n        currentTickGroup = 0;\n      }\n    }\n    function createGroups() {\n      let nextGroup = [];\n      let currentGroupTotalTicks = new Fraction(0, 1);\n      unprocessedNotes.forEach(unprocessedNote => {\n        nextGroup = [];\n        if (unprocessedNote.shouldIgnoreTicks()) {\n          noteGroups.push(currentGroup);\n          currentGroup = nextGroup;\n          return;\n        }\n        currentGroup.push(unprocessedNote);\n        const ticksPerGroup = tickGroups[currentTickGroup].clone();\n        const totalTicks = getTotalTicks(currentGroup).add(currentGroupTotalTicks);\n        const unbeamable = Tables.durationToNumber(unprocessedNote.getDuration()) < 8;\n        if (unbeamable && unprocessedNote.getTuplet()) {\n          ticksPerGroup.numerator *= 2;\n        }\n        if (totalTicks.greaterThan(ticksPerGroup)) {\n          if (!unbeamable) {\n            const note = currentGroup.pop();\n            if (note) nextGroup.push(note);\n          }\n          noteGroups.push(currentGroup);\n          do {\n            currentGroupTotalTicks = totalTicks.subtract(tickGroups[currentTickGroup]);\n            nextTickGroup();\n          } while (currentGroupTotalTicks.greaterThanEquals(tickGroups[currentTickGroup]));\n          currentGroup = nextGroup;\n        } else if (totalTicks.equals(ticksPerGroup)) {\n          noteGroups.push(currentGroup);\n          currentGroupTotalTicks = new Fraction(0, 1);\n          currentGroup = nextGroup;\n          nextTickGroup();\n        }\n      });\n      if (currentGroup.length > 0) {\n        noteGroups.push(currentGroup);\n      }\n    }\n    function getBeamGroups() {\n      return noteGroups.filter(group => {\n        if (group.length > 1) {\n          let beamable = true;\n          group.forEach(note => {\n            if (note.getIntrinsicTicks() >= Tables.durationToTicks('4')) {\n              beamable = false;\n            }\n          });\n          return beamable;\n        }\n        return false;\n      });\n    }\n    function sanitizeGroups() {\n      const sanitizedGroups = [];\n      noteGroups.forEach(group => {\n        let tempGroup = [];\n        group.forEach((note, index, group) => {\n          const isFirstOrLast = index === 0 || index === group.length - 1;\n          const prevNote = group[index - 1];\n          const breaksOnEachRest = !config.beam_rests && note.isRest();\n          const breaksOnFirstOrLastRest = config.beam_rests && config.beam_middle_only && note.isRest() && isFirstOrLast;\n          let breakOnStemChange = false;\n          if (config.maintain_stem_directions && prevNote && !note.isRest() && !prevNote.isRest()) {\n            const prevDirection = prevNote.getStemDirection();\n            const currentDirection = note.getStemDirection();\n            breakOnStemChange = currentDirection !== prevDirection;\n          }\n          const isUnbeamableDuration = parseInt(note.getDuration(), 10) < 8;\n          const shouldBreak = breaksOnEachRest || breaksOnFirstOrLastRest || breakOnStemChange || isUnbeamableDuration;\n          if (shouldBreak) {\n            if (tempGroup.length > 0) {\n              sanitizedGroups.push(tempGroup);\n            }\n            tempGroup = breakOnStemChange ? [note] : [];\n          } else {\n            tempGroup.push(note);\n          }\n        });\n        if (tempGroup.length > 0) {\n          sanitizedGroups.push(tempGroup);\n        }\n      });\n      noteGroups = sanitizedGroups;\n    }\n    function formatStems() {\n      noteGroups.forEach(group => {\n        let stemDirection;\n        if (config.maintain_stem_directions) {\n          const note = findFirstNote(group);\n          stemDirection = note ? note.getStemDirection() : Stem.UP;\n        } else {\n          if (config.stem_direction) {\n            stemDirection = config.stem_direction;\n          } else {\n            stemDirection = calculateStemDirection(group);\n          }\n        }\n        applyStemDirection(group, stemDirection);\n      });\n    }\n    function findFirstNote(group) {\n      for (let i = 0; i < group.length; i++) {\n        const note = group[i];\n        if (!note.isRest()) {\n          return note;\n        }\n      }\n      return false;\n    }\n    function applyStemDirection(group, direction) {\n      group.forEach(note => {\n        note.setStemDirection(direction);\n      });\n    }\n    function getTuplets() {\n      const uniqueTuplets = [];\n      noteGroups.forEach(group => {\n        let tuplet;\n        group.forEach(note => {\n          const noteTuplet = note.getTuplet();\n          if (noteTuplet && tuplet !== noteTuplet) {\n            tuplet = noteTuplet;\n            uniqueTuplets.push(tuplet);\n          }\n        });\n      });\n      return uniqueTuplets;\n    }\n    createGroups();\n    sanitizeGroups();\n    formatStems();\n    const beamedNoteGroups = getBeamGroups();\n    const allTuplets = getTuplets();\n    const beams = [];\n    beamedNoteGroups.forEach(group => {\n      const beam = new Beam(group);\n      if (config.show_stemlets) {\n        beam.render_options.show_stemlets = true;\n      }\n      if (config.secondary_breaks) {\n        beam.render_options.secondary_break_ticks = Tables.durationToTicks(config.secondary_breaks);\n      }\n      if (config.flat_beams === true) {\n        beam.render_options.flat_beams = true;\n        beam.render_options.flat_beam_offset = config.flat_beam_offset;\n      }\n      beams.push(beam);\n    });\n    allTuplets.forEach(tuplet => {\n      const direction = tuplet.notes[0].stem_direction === Stem.DOWN ? -1 : 1;\n      tuplet.setTupletLocation(direction);\n      let bracketed = false;\n      for (let i = 0; i < tuplet.notes.length; i++) {\n        const note = tuplet.notes[i];\n        if (!note.hasBeam()) {\n          bracketed = true;\n          break;\n        }\n      }\n      tuplet.setBracketed(bracketed);\n    });\n    return beams;\n  }\n  constructor(notes) {\n    let auto_stem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    super();\n    this.slope = 0;\n    this.y_shift = 0;\n    this.forcedPartialDirections = {};\n    if (!notes || notes.length === 0) {\n      throw new RuntimeError('BadArguments', 'No notes provided for beam.');\n    }\n    if (notes.length === 1) {\n      throw new RuntimeError('BadArguments', 'Too few notes for beam.');\n    }\n    this.ticks = notes[0].getIntrinsicTicks();\n    if (this.ticks >= Tables.durationToTicks('4')) {\n      throw new RuntimeError('BadArguments', 'Beams can only be applied to notes shorter than a quarter note.');\n    }\n    let i;\n    let note;\n    this.stem_direction = notes[0].getStemDirection();\n    let stem_direction = this.stem_direction;\n    if (auto_stem && isStaveNote(notes[0])) {\n      stem_direction = calculateStemDirection(notes);\n    } else if (auto_stem && isTabNote(notes[0])) {\n      const stem_weight = notes.reduce((memo, note) => memo + note.getStemDirection(), 0);\n      stem_direction = stem_weight > -1 ? Stem.UP : Stem.DOWN;\n    }\n    for (i = 0; i < notes.length; ++i) {\n      note = notes[i];\n      if (auto_stem) {\n        note.setStemDirection(stem_direction);\n        this.stem_direction = stem_direction;\n      }\n      note.setBeam(this);\n    }\n    this.postFormatted = false;\n    this.notes = notes;\n    this.beam_count = this.getBeamCount();\n    this.break_on_indices = [];\n    this.render_options = {\n      beam_width: 5,\n      max_slope: 0.25,\n      min_slope: -0.25,\n      slope_iterations: 20,\n      slope_cost: 100,\n      show_stemlets: false,\n      stemlet_extension: 7,\n      partial_beam_length: 10,\n      flat_beams: false,\n      min_flat_beam_offset: 15\n    };\n  }\n  getNotes() {\n    return this.notes;\n  }\n  getBeamCount() {\n    const beamCounts = this.notes.map(note => note.getGlyphProps().beam_count);\n    const maxBeamCount = beamCounts.reduce((max, beamCount) => beamCount > max ? beamCount : max);\n    return maxBeamCount;\n  }\n  breakSecondaryAt(indices) {\n    this.break_on_indices = indices;\n    return this;\n  }\n  setPartialBeamSideAt(noteIndex, side) {\n    this.forcedPartialDirections[noteIndex] = side;\n    return this;\n  }\n  unsetPartialBeamSideAt(noteIndex) {\n    delete this.forcedPartialDirections[noteIndex];\n    return this;\n  }\n  getSlopeY(x, first_x_px, first_y_px, slope) {\n    return first_y_px + (x - first_x_px) * slope;\n  }\n  calculateSlope() {\n    const {\n      notes,\n      stem_direction: stemDirection,\n      render_options: {\n        max_slope,\n        min_slope,\n        slope_iterations,\n        slope_cost\n      }\n    } = this;\n    const firstNote = notes[0];\n    const initialSlope = getStemSlope(firstNote, notes[notes.length - 1]);\n    const increment = (max_slope - min_slope) / slope_iterations;\n    let minCost = Number.MAX_VALUE;\n    let bestSlope = 0;\n    let yShift = 0;\n    for (let slope = min_slope; slope <= max_slope; slope += increment) {\n      let totalStemExtension = 0;\n      let yShiftTemp = 0;\n      for (let i = 1; i < notes.length; ++i) {\n        const note = notes[i];\n        if (note.hasStem() || note.isRest()) {\n          const adjustedStemTipY = this.getSlopeY(note.getStemX(), firstNote.getStemX(), firstNote.getStemExtents().topY, slope) + yShiftTemp;\n          const stemTipY = note.getStemExtents().topY;\n          if (stemTipY * stemDirection < adjustedStemTipY * stemDirection) {\n            const diff = Math.abs(stemTipY - adjustedStemTipY);\n            yShiftTemp += diff * -stemDirection;\n            totalStemExtension += diff * i;\n          } else {\n            totalStemExtension += (stemTipY - adjustedStemTipY) * stemDirection;\n          }\n        }\n      }\n      const idealSlope = initialSlope / 2;\n      const distanceFromIdeal = Math.abs(idealSlope - slope);\n      const cost = slope_cost * distanceFromIdeal + Math.abs(totalStemExtension);\n      if (cost < minCost) {\n        minCost = cost;\n        bestSlope = slope;\n        yShift = yShiftTemp;\n      }\n    }\n    this.slope = bestSlope;\n    this.y_shift = yShift;\n  }\n  calculateFlatSlope() {\n    const {\n      notes,\n      stem_direction,\n      render_options: {\n        beam_width,\n        min_flat_beam_offset,\n        flat_beam_offset\n      }\n    } = this;\n    let total = 0;\n    let extremeY = 0;\n    let extremeBeamCount = 0;\n    let currentExtreme = 0;\n    for (let i = 0; i < notes.length; i++) {\n      const note = notes[i];\n      const stemTipY = note.getStemExtents().topY;\n      total += stemTipY;\n      if (stem_direction === Stem.DOWN && currentExtreme < stemTipY) {\n        currentExtreme = stemTipY;\n        extremeY = Math.max(...note.getYs());\n        extremeBeamCount = note.getBeamCount();\n      } else if (stem_direction === Stem.UP && (currentExtreme === 0 || currentExtreme > stemTipY)) {\n        currentExtreme = stemTipY;\n        extremeY = Math.min(...note.getYs());\n        extremeBeamCount = note.getBeamCount();\n      }\n    }\n    let offset = total / notes.length;\n    const beamWidth = beam_width * 1.5;\n    const extremeTest = min_flat_beam_offset + extremeBeamCount * beamWidth;\n    const newOffset = extremeY + extremeTest * -stem_direction;\n    if (stem_direction === Stem.DOWN && offset < newOffset) {\n      offset = extremeY + extremeTest;\n    } else if (stem_direction === Stem.UP && offset > newOffset) {\n      offset = extremeY - extremeTest;\n    }\n    if (!flat_beam_offset) {\n      this.render_options.flat_beam_offset = offset;\n    } else if (stem_direction === Stem.DOWN && offset > flat_beam_offset) {\n      this.render_options.flat_beam_offset = offset;\n    } else if (stem_direction === Stem.UP && offset < flat_beam_offset) {\n      this.render_options.flat_beam_offset = offset;\n    }\n    this.slope = 0;\n    this.y_shift = 0;\n  }\n  getBeamYToDraw() {\n    const firstNote = this.notes[0];\n    const firstStemTipY = firstNote.getStemExtents().topY;\n    let beamY = firstStemTipY;\n    if (this.render_options.flat_beams && this.render_options.flat_beam_offset) {\n      beamY = this.render_options.flat_beam_offset;\n    }\n    return beamY;\n  }\n  applyStemExtensions() {\n    const {\n      notes,\n      slope,\n      y_shift,\n      beam_count,\n      render_options: {\n        show_stemlets,\n        stemlet_extension,\n        beam_width\n      }\n    } = this;\n    const firstNote = notes[0];\n    const firstStemTipY = this.getBeamYToDraw();\n    const firstStemX = firstNote.getStemX();\n    for (let i = 0; i < notes.length; ++i) {\n      const note = notes[i];\n      const stem = note.getStem();\n      if (stem) {\n        const stemX = note.getStemX();\n        const {\n          topY: stemTipY\n        } = note.getStemExtents();\n        const beamedStemTipY = this.getSlopeY(stemX, firstStemX, firstStemTipY, slope) + y_shift;\n        const preBeamExtension = stem.getExtension();\n        const beamExtension = note.getStemDirection() === Stem.UP ? stemTipY - beamedStemTipY : beamedStemTipY - stemTipY;\n        let crossStemExtension = 0;\n        if (note.getStemDirection() !== this.stem_direction) {\n          const beamCount = note.getGlyphProps().beam_count;\n          crossStemExtension = (1 + (beamCount - 1) * 1.5) * this.render_options.beam_width;\n        }\n        stem.setExtension(preBeamExtension + beamExtension + crossStemExtension);\n        stem.adjustHeightForBeam();\n        if (note.isRest() && show_stemlets) {\n          const beamWidth = beam_width;\n          const totalBeamWidth = (beam_count - 1) * beamWidth * 1.5 + beamWidth;\n          stem.setVisibility(true).setStemlet(true, totalBeamWidth + stemlet_extension);\n        }\n      }\n    }\n  }\n  lookupBeamDirection(duration, prev_tick, tick, next_tick, noteIndex) {\n    if (duration === '4') {\n      return BEAM_LEFT;\n    }\n    const forcedBeamDirection = this.forcedPartialDirections[noteIndex];\n    if (forcedBeamDirection) return forcedBeamDirection;\n    const lookup_duration = `${Tables.durationToNumber(duration) / 2}`;\n    const prev_note_gets_beam = prev_tick < Tables.durationToTicks(lookup_duration);\n    const next_note_gets_beam = next_tick < Tables.durationToTicks(lookup_duration);\n    const note_gets_beam = tick < Tables.durationToTicks(lookup_duration);\n    if (prev_note_gets_beam && next_note_gets_beam && note_gets_beam) {\n      return BEAM_BOTH;\n    } else if (prev_note_gets_beam && !next_note_gets_beam && note_gets_beam) {\n      return BEAM_LEFT;\n    } else if (!prev_note_gets_beam && next_note_gets_beam && note_gets_beam) {\n      return BEAM_RIGHT;\n    }\n    return this.lookupBeamDirection(lookup_duration, prev_tick, tick, next_tick, noteIndex);\n  }\n  getBeamLines(duration) {\n    const tick_of_duration = Tables.durationToTicks(duration);\n    let beam_started = false;\n    const beam_lines = [];\n    let current_beam = undefined;\n    const partial_beam_length = this.render_options.partial_beam_length;\n    let previous_should_break = false;\n    let tick_tally = 0;\n    for (let i = 0; i < this.notes.length; ++i) {\n      const note = this.notes[i];\n      const ticks = note.getTicks().value();\n      tick_tally += ticks;\n      let should_break = false;\n      if (parseInt(duration, 10) >= 8) {\n        should_break = this.break_on_indices.indexOf(i) !== -1;\n        if (this.render_options.secondary_break_ticks && tick_tally >= this.render_options.secondary_break_ticks) {\n          tick_tally = 0;\n          should_break = true;\n        }\n      }\n      const note_gets_beam = note.getIntrinsicTicks() < tick_of_duration;\n      const stem_x = note.getStemX() - Stem.WIDTH / 2;\n      const prev_note = this.notes[i - 1];\n      const next_note = this.notes[i + 1];\n      const next_note_gets_beam = next_note && next_note.getIntrinsicTicks() < tick_of_duration;\n      const prev_note_gets_beam = prev_note && prev_note.getIntrinsicTicks() < tick_of_duration;\n      const beam_alone = prev_note && next_note && note_gets_beam && !prev_note_gets_beam && !next_note_gets_beam;\n      if (note_gets_beam) {\n        if (beam_started) {\n          current_beam = beam_lines[beam_lines.length - 1];\n          current_beam.end = stem_x;\n          if (should_break) {\n            beam_started = false;\n            if (next_note && !next_note_gets_beam && current_beam.end === undefined) {\n              current_beam.end = current_beam.start - partial_beam_length;\n            }\n          }\n        } else {\n          current_beam = {\n            start: stem_x,\n            end: undefined\n          };\n          beam_started = true;\n          if (beam_alone) {\n            const prev_tick = prev_note.getIntrinsicTicks();\n            const next_tick = next_note.getIntrinsicTicks();\n            const tick = note.getIntrinsicTicks();\n            const beam_direction = this.lookupBeamDirection(duration, prev_tick, tick, next_tick, i);\n            if ([BEAM_LEFT, BEAM_BOTH].includes(beam_direction)) {\n              current_beam.end = current_beam.start - partial_beam_length;\n            } else {\n              current_beam.end = current_beam.start + partial_beam_length;\n            }\n          } else if (!next_note_gets_beam) {\n            if ((previous_should_break || i === 0) && next_note) {\n              current_beam.end = current_beam.start + partial_beam_length;\n            } else {\n              current_beam.end = current_beam.start - partial_beam_length;\n            }\n          } else if (should_break) {\n            current_beam.end = current_beam.start - partial_beam_length;\n            beam_started = false;\n          }\n          beam_lines.push(current_beam);\n        }\n      } else {\n        beam_started = false;\n      }\n      previous_should_break = should_break;\n    }\n    const last_beam = beam_lines[beam_lines.length - 1];\n    if (last_beam && last_beam.end === undefined) {\n      last_beam.end = last_beam.start - partial_beam_length;\n    }\n    return beam_lines;\n  }\n  drawStems(ctx) {\n    this.notes.forEach(note => {\n      const stem = note.getStem();\n      if (stem) {\n        const stem_x = note.getStemX();\n        stem.setNoteHeadXBounds(stem_x, stem_x);\n        stem.setContext(ctx).draw();\n      }\n    }, this);\n  }\n  drawBeamLines(ctx) {\n    const valid_beam_durations = ['4', '8', '16', '32', '64'];\n    const firstNote = this.notes[0];\n    let beamY = this.getBeamYToDraw();\n    const firstStemX = firstNote.getStemX();\n    const beamThickness = this.render_options.beam_width * this.stem_direction;\n    for (let i = 0; i < valid_beam_durations.length; ++i) {\n      const duration = valid_beam_durations[i];\n      const beamLines = this.getBeamLines(duration);\n      for (let j = 0; j < beamLines.length; ++j) {\n        const beam_line = beamLines[j];\n        const startBeamX = beam_line.start;\n        const startBeamY = this.getSlopeY(startBeamX, firstStemX, beamY, this.slope);\n        const lastBeamX = beam_line.end;\n        if (lastBeamX) {\n          const lastBeamY = this.getSlopeY(lastBeamX, firstStemX, beamY, this.slope);\n          ctx.beginPath();\n          ctx.moveTo(startBeamX, startBeamY);\n          ctx.lineTo(startBeamX, startBeamY + beamThickness);\n          ctx.lineTo(lastBeamX + 1, lastBeamY + beamThickness);\n          ctx.lineTo(lastBeamX + 1, lastBeamY);\n          ctx.closePath();\n          ctx.fill();\n        } else {\n          throw new RuntimeError('NoLastBeamX', 'lastBeamX undefined.');\n        }\n      }\n      beamY += beamThickness * 1.5;\n    }\n  }\n  preFormat() {\n    return this;\n  }\n  postFormat() {\n    if (this.postFormatted) return;\n    if (isTabNote(this.notes[0]) || this.render_options.flat_beams) {\n      this.calculateFlatSlope();\n    } else {\n      this.calculateSlope();\n    }\n    this.applyStemExtensions();\n    this.postFormatted = true;\n  }\n  draw() {\n    const ctx = this.checkContext();\n    this.setRendered();\n    if (this.unbeamable) return;\n    if (!this.postFormatted) {\n      this.postFormat();\n    }\n    this.drawStems(ctx);\n    this.applyStyle();\n    ctx.openGroup('beam', this.getAttribute('id'));\n    this.drawBeamLines(ctx);\n    ctx.closeGroup();\n    this.restoreStyle();\n  }\n}","map":{"version":3,"names":["Element","Fraction","Stem","Tables","isStaveNote","isTabNote","RuntimeError","calculateStemDirection","notes","lineSum","forEach","note","keyProps","keyProp","line","DOWN","UP","getStemSlope","firstNote","lastNote","firstStemTipY","getStemExtents","topY","firstStemX","getStemX","lastStemTipY","lastStemX","BEAM_LEFT","BEAM_RIGHT","BEAM_BOTH","Beam","CATEGORY","getStemDirection","stem_direction","getDefaultBeamGroups","time_sig","defaults","groups","undefined","beatTotal","parseInt","split","beatValue","tripleMeter","map","group","parse","applyAndGetBeams","voice","generateBeams","getTickables","config","arguments","length","tickGroups","multiply","clone","RESOLUTION","unprocessedNotes","currentTickGroup","noteGroups","currentGroup","getTotalTicks","vf_notes","reduce","memo","getTicks","add","nextTickGroup","createGroups","nextGroup","currentGroupTotalTicks","unprocessedNote","shouldIgnoreTicks","push","ticksPerGroup","totalTicks","unbeamable","durationToNumber","getDuration","getTuplet","numerator","greaterThan","pop","subtract","greaterThanEquals","equals","getBeamGroups","filter","beamable","getIntrinsicTicks","durationToTicks","sanitizeGroups","sanitizedGroups","tempGroup","index","isFirstOrLast","prevNote","breaksOnEachRest","beam_rests","isRest","breaksOnFirstOrLastRest","beam_middle_only","breakOnStemChange","maintain_stem_directions","prevDirection","currentDirection","isUnbeamableDuration","shouldBreak","formatStems","stemDirection","findFirstNote","applyStemDirection","i","direction","setStemDirection","getTuplets","uniqueTuplets","tuplet","noteTuplet","beamedNoteGroups","allTuplets","beams","beam","show_stemlets","render_options","secondary_breaks","secondary_break_ticks","flat_beams","flat_beam_offset","setTupletLocation","bracketed","hasBeam","setBracketed","constructor","auto_stem","slope","y_shift","forcedPartialDirections","ticks","stem_weight","setBeam","postFormatted","beam_count","getBeamCount","break_on_indices","beam_width","max_slope","min_slope","slope_iterations","slope_cost","stemlet_extension","partial_beam_length","min_flat_beam_offset","getNotes","beamCounts","getGlyphProps","maxBeamCount","max","beamCount","breakSecondaryAt","indices","setPartialBeamSideAt","noteIndex","side","unsetPartialBeamSideAt","getSlopeY","x","first_x_px","first_y_px","calculateSlope","initialSlope","increment","minCost","Number","MAX_VALUE","bestSlope","yShift","totalStemExtension","yShiftTemp","hasStem","adjustedStemTipY","stemTipY","diff","Math","abs","idealSlope","distanceFromIdeal","cost","calculateFlatSlope","total","extremeY","extremeBeamCount","currentExtreme","getYs","min","offset","beamWidth","extremeTest","newOffset","getBeamYToDraw","beamY","applyStemExtensions","stem","getStem","stemX","beamedStemTipY","preBeamExtension","getExtension","beamExtension","crossStemExtension","setExtension","adjustHeightForBeam","totalBeamWidth","setVisibility","setStemlet","lookupBeamDirection","duration","prev_tick","tick","next_tick","forcedBeamDirection","lookup_duration","prev_note_gets_beam","next_note_gets_beam","note_gets_beam","getBeamLines","tick_of_duration","beam_started","beam_lines","current_beam","previous_should_break","tick_tally","value","should_break","indexOf","stem_x","WIDTH","prev_note","next_note","beam_alone","end","start","beam_direction","includes","last_beam","drawStems","ctx","setNoteHeadXBounds","setContext","draw","drawBeamLines","valid_beam_durations","beamThickness","beamLines","j","beam_line","startBeamX","startBeamY","lastBeamX","lastBeamY","beginPath","moveTo","lineTo","closePath","fill","preFormat","postFormat","checkContext","setRendered","applyStyle","openGroup","getAttribute","closeGroup","restoreStyle"],"sources":["/Users/lang/Documents/code/Song2Notation/frontend/node_modules/vexflow/build/esm/src/beam.js"],"sourcesContent":["import { Element } from './element.js';\nimport { Fraction } from './fraction.js';\nimport { Stem } from './stem.js';\nimport { Tables } from './tables.js';\nimport { isStaveNote, isTabNote } from './typeguard.js';\nimport { RuntimeError } from './util.js';\nfunction calculateStemDirection(notes) {\n    let lineSum = 0;\n    notes.forEach((note) => {\n        if (note.keyProps) {\n            note.keyProps.forEach((keyProp) => {\n                lineSum += keyProp.line - 3;\n            });\n        }\n    });\n    if (lineSum >= 0) {\n        return Stem.DOWN;\n    }\n    return Stem.UP;\n}\nfunction getStemSlope(firstNote, lastNote) {\n    const firstStemTipY = firstNote.getStemExtents().topY;\n    const firstStemX = firstNote.getStemX();\n    const lastStemTipY = lastNote.getStemExtents().topY;\n    const lastStemX = lastNote.getStemX();\n    return (lastStemTipY - firstStemTipY) / (lastStemX - firstStemX);\n}\nexport const BEAM_LEFT = 'L';\nexport const BEAM_RIGHT = 'R';\nexport const BEAM_BOTH = 'B';\nexport class Beam extends Element {\n    static get CATEGORY() {\n        return \"Beam\";\n    }\n    getStemDirection() {\n        return this.stem_direction;\n    }\n    static getDefaultBeamGroups(time_sig) {\n        if (!time_sig || time_sig === 'c') {\n            time_sig = '4/4';\n        }\n        const defaults = {\n            '1/2': ['1/2'],\n            '2/2': ['1/2'],\n            '3/2': ['1/2'],\n            '4/2': ['1/2'],\n            '1/4': ['1/4'],\n            '2/4': ['1/4'],\n            '3/4': ['1/4'],\n            '4/4': ['1/4'],\n            '1/8': ['1/8'],\n            '2/8': ['2/8'],\n            '3/8': ['3/8'],\n            '4/8': ['2/8'],\n            '1/16': ['1/16'],\n            '2/16': ['2/16'],\n            '3/16': ['3/16'],\n            '4/16': ['2/16'],\n        };\n        const groups = defaults[time_sig];\n        if (groups === undefined) {\n            const beatTotal = parseInt(time_sig.split('/')[0], 10);\n            const beatValue = parseInt(time_sig.split('/')[1], 10);\n            const tripleMeter = beatTotal % 3 === 0;\n            if (tripleMeter) {\n                return [new Fraction(3, beatValue)];\n            }\n            else if (beatValue > 4) {\n                return [new Fraction(2, beatValue)];\n            }\n            else if (beatValue <= 4) {\n                return [new Fraction(1, beatValue)];\n            }\n        }\n        else {\n            return groups.map((group) => new Fraction().parse(group));\n        }\n        return [new Fraction(1, 4)];\n    }\n    static applyAndGetBeams(voice, stem_direction, groups) {\n        return Beam.generateBeams(voice.getTickables(), { groups, stem_direction });\n    }\n    static generateBeams(notes, config = {}) {\n        if (!config.groups || !config.groups.length) {\n            config.groups = [new Fraction(2, 8)];\n        }\n        const tickGroups = config.groups.map((group) => {\n            if (!group.multiply) {\n                throw new RuntimeError('InvalidBeamGroups', 'The beam groups must be an array of Vex.Flow.Fractions');\n            }\n            return group.clone().multiply(Tables.RESOLUTION, 1);\n        });\n        const unprocessedNotes = notes;\n        let currentTickGroup = 0;\n        let noteGroups = [];\n        let currentGroup = [];\n        function getTotalTicks(vf_notes) {\n            return vf_notes.reduce((memo, note) => note.getTicks().clone().add(memo), new Fraction(0, 1));\n        }\n        function nextTickGroup() {\n            if (tickGroups.length - 1 > currentTickGroup) {\n                currentTickGroup += 1;\n            }\n            else {\n                currentTickGroup = 0;\n            }\n        }\n        function createGroups() {\n            let nextGroup = [];\n            let currentGroupTotalTicks = new Fraction(0, 1);\n            unprocessedNotes.forEach((unprocessedNote) => {\n                nextGroup = [];\n                if (unprocessedNote.shouldIgnoreTicks()) {\n                    noteGroups.push(currentGroup);\n                    currentGroup = nextGroup;\n                    return;\n                }\n                currentGroup.push(unprocessedNote);\n                const ticksPerGroup = tickGroups[currentTickGroup].clone();\n                const totalTicks = getTotalTicks(currentGroup).add(currentGroupTotalTicks);\n                const unbeamable = Tables.durationToNumber(unprocessedNote.getDuration()) < 8;\n                if (unbeamable && unprocessedNote.getTuplet()) {\n                    ticksPerGroup.numerator *= 2;\n                }\n                if (totalTicks.greaterThan(ticksPerGroup)) {\n                    if (!unbeamable) {\n                        const note = currentGroup.pop();\n                        if (note)\n                            nextGroup.push(note);\n                    }\n                    noteGroups.push(currentGroup);\n                    do {\n                        currentGroupTotalTicks = totalTicks.subtract(tickGroups[currentTickGroup]);\n                        nextTickGroup();\n                    } while (currentGroupTotalTicks.greaterThanEquals(tickGroups[currentTickGroup]));\n                    currentGroup = nextGroup;\n                }\n                else if (totalTicks.equals(ticksPerGroup)) {\n                    noteGroups.push(currentGroup);\n                    currentGroupTotalTicks = new Fraction(0, 1);\n                    currentGroup = nextGroup;\n                    nextTickGroup();\n                }\n            });\n            if (currentGroup.length > 0) {\n                noteGroups.push(currentGroup);\n            }\n        }\n        function getBeamGroups() {\n            return noteGroups.filter((group) => {\n                if (group.length > 1) {\n                    let beamable = true;\n                    group.forEach((note) => {\n                        if (note.getIntrinsicTicks() >= Tables.durationToTicks('4')) {\n                            beamable = false;\n                        }\n                    });\n                    return beamable;\n                }\n                return false;\n            });\n        }\n        function sanitizeGroups() {\n            const sanitizedGroups = [];\n            noteGroups.forEach((group) => {\n                let tempGroup = [];\n                group.forEach((note, index, group) => {\n                    const isFirstOrLast = index === 0 || index === group.length - 1;\n                    const prevNote = group[index - 1];\n                    const breaksOnEachRest = !config.beam_rests && note.isRest();\n                    const breaksOnFirstOrLastRest = config.beam_rests && config.beam_middle_only && note.isRest() && isFirstOrLast;\n                    let breakOnStemChange = false;\n                    if (config.maintain_stem_directions && prevNote && !note.isRest() && !prevNote.isRest()) {\n                        const prevDirection = prevNote.getStemDirection();\n                        const currentDirection = note.getStemDirection();\n                        breakOnStemChange = currentDirection !== prevDirection;\n                    }\n                    const isUnbeamableDuration = parseInt(note.getDuration(), 10) < 8;\n                    const shouldBreak = breaksOnEachRest || breaksOnFirstOrLastRest || breakOnStemChange || isUnbeamableDuration;\n                    if (shouldBreak) {\n                        if (tempGroup.length > 0) {\n                            sanitizedGroups.push(tempGroup);\n                        }\n                        tempGroup = breakOnStemChange ? [note] : [];\n                    }\n                    else {\n                        tempGroup.push(note);\n                    }\n                });\n                if (tempGroup.length > 0) {\n                    sanitizedGroups.push(tempGroup);\n                }\n            });\n            noteGroups = sanitizedGroups;\n        }\n        function formatStems() {\n            noteGroups.forEach((group) => {\n                let stemDirection;\n                if (config.maintain_stem_directions) {\n                    const note = findFirstNote(group);\n                    stemDirection = note ? note.getStemDirection() : Stem.UP;\n                }\n                else {\n                    if (config.stem_direction) {\n                        stemDirection = config.stem_direction;\n                    }\n                    else {\n                        stemDirection = calculateStemDirection(group);\n                    }\n                }\n                applyStemDirection(group, stemDirection);\n            });\n        }\n        function findFirstNote(group) {\n            for (let i = 0; i < group.length; i++) {\n                const note = group[i];\n                if (!note.isRest()) {\n                    return note;\n                }\n            }\n            return false;\n        }\n        function applyStemDirection(group, direction) {\n            group.forEach((note) => {\n                note.setStemDirection(direction);\n            });\n        }\n        function getTuplets() {\n            const uniqueTuplets = [];\n            noteGroups.forEach((group) => {\n                let tuplet;\n                group.forEach((note) => {\n                    const noteTuplet = note.getTuplet();\n                    if (noteTuplet && tuplet !== noteTuplet) {\n                        tuplet = noteTuplet;\n                        uniqueTuplets.push(tuplet);\n                    }\n                });\n            });\n            return uniqueTuplets;\n        }\n        createGroups();\n        sanitizeGroups();\n        formatStems();\n        const beamedNoteGroups = getBeamGroups();\n        const allTuplets = getTuplets();\n        const beams = [];\n        beamedNoteGroups.forEach((group) => {\n            const beam = new Beam(group);\n            if (config.show_stemlets) {\n                beam.render_options.show_stemlets = true;\n            }\n            if (config.secondary_breaks) {\n                beam.render_options.secondary_break_ticks = Tables.durationToTicks(config.secondary_breaks);\n            }\n            if (config.flat_beams === true) {\n                beam.render_options.flat_beams = true;\n                beam.render_options.flat_beam_offset = config.flat_beam_offset;\n            }\n            beams.push(beam);\n        });\n        allTuplets.forEach((tuplet) => {\n            const direction = tuplet.notes[0].stem_direction === Stem.DOWN ? -1 : 1;\n            tuplet.setTupletLocation(direction);\n            let bracketed = false;\n            for (let i = 0; i < tuplet.notes.length; i++) {\n                const note = tuplet.notes[i];\n                if (!note.hasBeam()) {\n                    bracketed = true;\n                    break;\n                }\n            }\n            tuplet.setBracketed(bracketed);\n        });\n        return beams;\n    }\n    constructor(notes, auto_stem = false) {\n        super();\n        this.slope = 0;\n        this.y_shift = 0;\n        this.forcedPartialDirections = {};\n        if (!notes || notes.length === 0) {\n            throw new RuntimeError('BadArguments', 'No notes provided for beam.');\n        }\n        if (notes.length === 1) {\n            throw new RuntimeError('BadArguments', 'Too few notes for beam.');\n        }\n        this.ticks = notes[0].getIntrinsicTicks();\n        if (this.ticks >= Tables.durationToTicks('4')) {\n            throw new RuntimeError('BadArguments', 'Beams can only be applied to notes shorter than a quarter note.');\n        }\n        let i;\n        let note;\n        this.stem_direction = notes[0].getStemDirection();\n        let stem_direction = this.stem_direction;\n        if (auto_stem && isStaveNote(notes[0])) {\n            stem_direction = calculateStemDirection(notes);\n        }\n        else if (auto_stem && isTabNote(notes[0])) {\n            const stem_weight = notes.reduce((memo, note) => memo + note.getStemDirection(), 0);\n            stem_direction = stem_weight > -1 ? Stem.UP : Stem.DOWN;\n        }\n        for (i = 0; i < notes.length; ++i) {\n            note = notes[i];\n            if (auto_stem) {\n                note.setStemDirection(stem_direction);\n                this.stem_direction = stem_direction;\n            }\n            note.setBeam(this);\n        }\n        this.postFormatted = false;\n        this.notes = notes;\n        this.beam_count = this.getBeamCount();\n        this.break_on_indices = [];\n        this.render_options = {\n            beam_width: 5,\n            max_slope: 0.25,\n            min_slope: -0.25,\n            slope_iterations: 20,\n            slope_cost: 100,\n            show_stemlets: false,\n            stemlet_extension: 7,\n            partial_beam_length: 10,\n            flat_beams: false,\n            min_flat_beam_offset: 15,\n        };\n    }\n    getNotes() {\n        return this.notes;\n    }\n    getBeamCount() {\n        const beamCounts = this.notes.map((note) => note.getGlyphProps().beam_count);\n        const maxBeamCount = beamCounts.reduce((max, beamCount) => (beamCount > max ? beamCount : max));\n        return maxBeamCount;\n    }\n    breakSecondaryAt(indices) {\n        this.break_on_indices = indices;\n        return this;\n    }\n    setPartialBeamSideAt(noteIndex, side) {\n        this.forcedPartialDirections[noteIndex] = side;\n        return this;\n    }\n    unsetPartialBeamSideAt(noteIndex) {\n        delete this.forcedPartialDirections[noteIndex];\n        return this;\n    }\n    getSlopeY(x, first_x_px, first_y_px, slope) {\n        return first_y_px + (x - first_x_px) * slope;\n    }\n    calculateSlope() {\n        const { notes, stem_direction: stemDirection, render_options: { max_slope, min_slope, slope_iterations, slope_cost }, } = this;\n        const firstNote = notes[0];\n        const initialSlope = getStemSlope(firstNote, notes[notes.length - 1]);\n        const increment = (max_slope - min_slope) / slope_iterations;\n        let minCost = Number.MAX_VALUE;\n        let bestSlope = 0;\n        let yShift = 0;\n        for (let slope = min_slope; slope <= max_slope; slope += increment) {\n            let totalStemExtension = 0;\n            let yShiftTemp = 0;\n            for (let i = 1; i < notes.length; ++i) {\n                const note = notes[i];\n                if (note.hasStem() || note.isRest()) {\n                    const adjustedStemTipY = this.getSlopeY(note.getStemX(), firstNote.getStemX(), firstNote.getStemExtents().topY, slope) + yShiftTemp;\n                    const stemTipY = note.getStemExtents().topY;\n                    if (stemTipY * stemDirection < adjustedStemTipY * stemDirection) {\n                        const diff = Math.abs(stemTipY - adjustedStemTipY);\n                        yShiftTemp += diff * -stemDirection;\n                        totalStemExtension += diff * i;\n                    }\n                    else {\n                        totalStemExtension += (stemTipY - adjustedStemTipY) * stemDirection;\n                    }\n                }\n            }\n            const idealSlope = initialSlope / 2;\n            const distanceFromIdeal = Math.abs(idealSlope - slope);\n            const cost = slope_cost * distanceFromIdeal + Math.abs(totalStemExtension);\n            if (cost < minCost) {\n                minCost = cost;\n                bestSlope = slope;\n                yShift = yShiftTemp;\n            }\n        }\n        this.slope = bestSlope;\n        this.y_shift = yShift;\n    }\n    calculateFlatSlope() {\n        const { notes, stem_direction, render_options: { beam_width, min_flat_beam_offset, flat_beam_offset }, } = this;\n        let total = 0;\n        let extremeY = 0;\n        let extremeBeamCount = 0;\n        let currentExtreme = 0;\n        for (let i = 0; i < notes.length; i++) {\n            const note = notes[i];\n            const stemTipY = note.getStemExtents().topY;\n            total += stemTipY;\n            if (stem_direction === Stem.DOWN && currentExtreme < stemTipY) {\n                currentExtreme = stemTipY;\n                extremeY = Math.max(...note.getYs());\n                extremeBeamCount = note.getBeamCount();\n            }\n            else if (stem_direction === Stem.UP && (currentExtreme === 0 || currentExtreme > stemTipY)) {\n                currentExtreme = stemTipY;\n                extremeY = Math.min(...note.getYs());\n                extremeBeamCount = note.getBeamCount();\n            }\n        }\n        let offset = total / notes.length;\n        const beamWidth = beam_width * 1.5;\n        const extremeTest = min_flat_beam_offset + extremeBeamCount * beamWidth;\n        const newOffset = extremeY + extremeTest * -stem_direction;\n        if (stem_direction === Stem.DOWN && offset < newOffset) {\n            offset = extremeY + extremeTest;\n        }\n        else if (stem_direction === Stem.UP && offset > newOffset) {\n            offset = extremeY - extremeTest;\n        }\n        if (!flat_beam_offset) {\n            this.render_options.flat_beam_offset = offset;\n        }\n        else if (stem_direction === Stem.DOWN && offset > flat_beam_offset) {\n            this.render_options.flat_beam_offset = offset;\n        }\n        else if (stem_direction === Stem.UP && offset < flat_beam_offset) {\n            this.render_options.flat_beam_offset = offset;\n        }\n        this.slope = 0;\n        this.y_shift = 0;\n    }\n    getBeamYToDraw() {\n        const firstNote = this.notes[0];\n        const firstStemTipY = firstNote.getStemExtents().topY;\n        let beamY = firstStemTipY;\n        if (this.render_options.flat_beams && this.render_options.flat_beam_offset) {\n            beamY = this.render_options.flat_beam_offset;\n        }\n        return beamY;\n    }\n    applyStemExtensions() {\n        const { notes, slope, y_shift, beam_count, render_options: { show_stemlets, stemlet_extension, beam_width }, } = this;\n        const firstNote = notes[0];\n        const firstStemTipY = this.getBeamYToDraw();\n        const firstStemX = firstNote.getStemX();\n        for (let i = 0; i < notes.length; ++i) {\n            const note = notes[i];\n            const stem = note.getStem();\n            if (stem) {\n                const stemX = note.getStemX();\n                const { topY: stemTipY } = note.getStemExtents();\n                const beamedStemTipY = this.getSlopeY(stemX, firstStemX, firstStemTipY, slope) + y_shift;\n                const preBeamExtension = stem.getExtension();\n                const beamExtension = note.getStemDirection() === Stem.UP ? stemTipY - beamedStemTipY : beamedStemTipY - stemTipY;\n                let crossStemExtension = 0;\n                if (note.getStemDirection() !== this.stem_direction) {\n                    const beamCount = note.getGlyphProps().beam_count;\n                    crossStemExtension = (1 + (beamCount - 1) * 1.5) * this.render_options.beam_width;\n                }\n                stem.setExtension(preBeamExtension + beamExtension + crossStemExtension);\n                stem.adjustHeightForBeam();\n                if (note.isRest() && show_stemlets) {\n                    const beamWidth = beam_width;\n                    const totalBeamWidth = (beam_count - 1) * beamWidth * 1.5 + beamWidth;\n                    stem.setVisibility(true).setStemlet(true, totalBeamWidth + stemlet_extension);\n                }\n            }\n        }\n    }\n    lookupBeamDirection(duration, prev_tick, tick, next_tick, noteIndex) {\n        if (duration === '4') {\n            return BEAM_LEFT;\n        }\n        const forcedBeamDirection = this.forcedPartialDirections[noteIndex];\n        if (forcedBeamDirection)\n            return forcedBeamDirection;\n        const lookup_duration = `${Tables.durationToNumber(duration) / 2}`;\n        const prev_note_gets_beam = prev_tick < Tables.durationToTicks(lookup_duration);\n        const next_note_gets_beam = next_tick < Tables.durationToTicks(lookup_duration);\n        const note_gets_beam = tick < Tables.durationToTicks(lookup_duration);\n        if (prev_note_gets_beam && next_note_gets_beam && note_gets_beam) {\n            return BEAM_BOTH;\n        }\n        else if (prev_note_gets_beam && !next_note_gets_beam && note_gets_beam) {\n            return BEAM_LEFT;\n        }\n        else if (!prev_note_gets_beam && next_note_gets_beam && note_gets_beam) {\n            return BEAM_RIGHT;\n        }\n        return this.lookupBeamDirection(lookup_duration, prev_tick, tick, next_tick, noteIndex);\n    }\n    getBeamLines(duration) {\n        const tick_of_duration = Tables.durationToTicks(duration);\n        let beam_started = false;\n        const beam_lines = [];\n        let current_beam = undefined;\n        const partial_beam_length = this.render_options.partial_beam_length;\n        let previous_should_break = false;\n        let tick_tally = 0;\n        for (let i = 0; i < this.notes.length; ++i) {\n            const note = this.notes[i];\n            const ticks = note.getTicks().value();\n            tick_tally += ticks;\n            let should_break = false;\n            if (parseInt(duration, 10) >= 8) {\n                should_break = this.break_on_indices.indexOf(i) !== -1;\n                if (this.render_options.secondary_break_ticks && tick_tally >= this.render_options.secondary_break_ticks) {\n                    tick_tally = 0;\n                    should_break = true;\n                }\n            }\n            const note_gets_beam = note.getIntrinsicTicks() < tick_of_duration;\n            const stem_x = note.getStemX() - Stem.WIDTH / 2;\n            const prev_note = this.notes[i - 1];\n            const next_note = this.notes[i + 1];\n            const next_note_gets_beam = next_note && next_note.getIntrinsicTicks() < tick_of_duration;\n            const prev_note_gets_beam = prev_note && prev_note.getIntrinsicTicks() < tick_of_duration;\n            const beam_alone = prev_note && next_note && note_gets_beam && !prev_note_gets_beam && !next_note_gets_beam;\n            if (note_gets_beam) {\n                if (beam_started) {\n                    current_beam = beam_lines[beam_lines.length - 1];\n                    current_beam.end = stem_x;\n                    if (should_break) {\n                        beam_started = false;\n                        if (next_note && !next_note_gets_beam && current_beam.end === undefined) {\n                            current_beam.end = current_beam.start - partial_beam_length;\n                        }\n                    }\n                }\n                else {\n                    current_beam = { start: stem_x, end: undefined };\n                    beam_started = true;\n                    if (beam_alone) {\n                        const prev_tick = prev_note.getIntrinsicTicks();\n                        const next_tick = next_note.getIntrinsicTicks();\n                        const tick = note.getIntrinsicTicks();\n                        const beam_direction = this.lookupBeamDirection(duration, prev_tick, tick, next_tick, i);\n                        if ([BEAM_LEFT, BEAM_BOTH].includes(beam_direction)) {\n                            current_beam.end = current_beam.start - partial_beam_length;\n                        }\n                        else {\n                            current_beam.end = current_beam.start + partial_beam_length;\n                        }\n                    }\n                    else if (!next_note_gets_beam) {\n                        if ((previous_should_break || i === 0) && next_note) {\n                            current_beam.end = current_beam.start + partial_beam_length;\n                        }\n                        else {\n                            current_beam.end = current_beam.start - partial_beam_length;\n                        }\n                    }\n                    else if (should_break) {\n                        current_beam.end = current_beam.start - partial_beam_length;\n                        beam_started = false;\n                    }\n                    beam_lines.push(current_beam);\n                }\n            }\n            else {\n                beam_started = false;\n            }\n            previous_should_break = should_break;\n        }\n        const last_beam = beam_lines[beam_lines.length - 1];\n        if (last_beam && last_beam.end === undefined) {\n            last_beam.end = last_beam.start - partial_beam_length;\n        }\n        return beam_lines;\n    }\n    drawStems(ctx) {\n        this.notes.forEach((note) => {\n            const stem = note.getStem();\n            if (stem) {\n                const stem_x = note.getStemX();\n                stem.setNoteHeadXBounds(stem_x, stem_x);\n                stem.setContext(ctx).draw();\n            }\n        }, this);\n    }\n    drawBeamLines(ctx) {\n        const valid_beam_durations = ['4', '8', '16', '32', '64'];\n        const firstNote = this.notes[0];\n        let beamY = this.getBeamYToDraw();\n        const firstStemX = firstNote.getStemX();\n        const beamThickness = this.render_options.beam_width * this.stem_direction;\n        for (let i = 0; i < valid_beam_durations.length; ++i) {\n            const duration = valid_beam_durations[i];\n            const beamLines = this.getBeamLines(duration);\n            for (let j = 0; j < beamLines.length; ++j) {\n                const beam_line = beamLines[j];\n                const startBeamX = beam_line.start;\n                const startBeamY = this.getSlopeY(startBeamX, firstStemX, beamY, this.slope);\n                const lastBeamX = beam_line.end;\n                if (lastBeamX) {\n                    const lastBeamY = this.getSlopeY(lastBeamX, firstStemX, beamY, this.slope);\n                    ctx.beginPath();\n                    ctx.moveTo(startBeamX, startBeamY);\n                    ctx.lineTo(startBeamX, startBeamY + beamThickness);\n                    ctx.lineTo(lastBeamX + 1, lastBeamY + beamThickness);\n                    ctx.lineTo(lastBeamX + 1, lastBeamY);\n                    ctx.closePath();\n                    ctx.fill();\n                }\n                else {\n                    throw new RuntimeError('NoLastBeamX', 'lastBeamX undefined.');\n                }\n            }\n            beamY += beamThickness * 1.5;\n        }\n    }\n    preFormat() {\n        return this;\n    }\n    postFormat() {\n        if (this.postFormatted)\n            return;\n        if (isTabNote(this.notes[0]) || this.render_options.flat_beams) {\n            this.calculateFlatSlope();\n        }\n        else {\n            this.calculateSlope();\n        }\n        this.applyStemExtensions();\n        this.postFormatted = true;\n    }\n    draw() {\n        const ctx = this.checkContext();\n        this.setRendered();\n        if (this.unbeamable)\n            return;\n        if (!this.postFormatted) {\n            this.postFormat();\n        }\n        this.drawStems(ctx);\n        this.applyStyle();\n        ctx.openGroup('beam', this.getAttribute('id'));\n        this.drawBeamLines(ctx);\n        ctx.closeGroup();\n        this.restoreStyle();\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}