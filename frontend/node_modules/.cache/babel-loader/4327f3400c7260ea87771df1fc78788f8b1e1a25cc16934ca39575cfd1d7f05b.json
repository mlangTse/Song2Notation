{"ast":null,"code":"import { Glyph } from './glyph.js';\nimport { Modifier } from './modifier.js';\nimport { Stem } from './stem.js';\nimport { Tables } from './tables.js';\nimport { isGraceNote, isStaveNote, isStemmableNote, isTabNote } from './typeguard.js';\nimport { defined, log, RuntimeError } from './util.js';\nfunction L() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  if (Articulation.DEBUG) log('Vex.Flow.Articulation', args);\n}\nconst {\n  ABOVE,\n  BELOW\n} = Modifier.Position;\nfunction roundToNearestHalf(mathFn, value) {\n  return mathFn(value / 0.5) * 0.5;\n}\nfunction isWithinLines(line, position) {\n  return position === ABOVE ? line <= 5 : line >= 1;\n}\nfunction getRoundingFunction(line, position) {\n  if (isWithinLines(line, position)) {\n    if (position === ABOVE) {\n      return Math.ceil;\n    } else {\n      return Math.floor;\n    }\n  } else {\n    return Math.round;\n  }\n}\nfunction snapLineToStaff(canSitBetweenLines, line, position, offsetDirection) {\n  const snappedLine = roundToNearestHalf(getRoundingFunction(line, position), line);\n  const canSnapToStaffSpace = canSitBetweenLines && isWithinLines(snappedLine, position);\n  const onStaffLine = snappedLine % 1 === 0;\n  if (canSnapToStaffSpace && onStaffLine) {\n    const HALF_STAFF_SPACE = 0.5;\n    return snappedLine + HALF_STAFF_SPACE * -offsetDirection;\n  } else {\n    return snappedLine;\n  }\n}\nconst isStaveOrGraceNote = note => isStaveNote(note) || isGraceNote(note);\nfunction getTopY(note, textLine) {\n  const stemDirection = note.getStemDirection();\n  const {\n    topY: stemTipY,\n    baseY: stemBaseY\n  } = note.getStemExtents();\n  if (isStaveOrGraceNote(note)) {\n    if (note.hasStem()) {\n      if (stemDirection === Stem.UP) {\n        return stemTipY;\n      } else {\n        return stemBaseY;\n      }\n    } else {\n      return Math.min(...note.getYs());\n    }\n  } else if (isTabNote(note)) {\n    if (note.hasStem()) {\n      if (stemDirection === Stem.UP) {\n        return stemTipY;\n      } else {\n        return note.checkStave().getYForTopText(textLine);\n      }\n    } else {\n      return note.checkStave().getYForTopText(textLine);\n    }\n  } else {\n    throw new RuntimeError('UnknownCategory', 'Only can get the top and bottom ys of stavenotes and tabnotes');\n  }\n}\nfunction getBottomY(note, textLine) {\n  const stemDirection = note.getStemDirection();\n  const {\n    topY: stemTipY,\n    baseY: stemBaseY\n  } = note.getStemExtents();\n  if (isStaveOrGraceNote(note)) {\n    if (note.hasStem()) {\n      if (stemDirection === Stem.UP) {\n        return stemBaseY;\n      } else {\n        return stemTipY;\n      }\n    } else {\n      return Math.max(...note.getYs());\n    }\n  } else if (isTabNote(note)) {\n    if (note.hasStem()) {\n      if (stemDirection === Stem.UP) {\n        return note.checkStave().getYForBottomText(textLine);\n      } else {\n        return stemTipY;\n      }\n    } else {\n      return note.checkStave().getYForBottomText(textLine);\n    }\n  } else {\n    throw new RuntimeError('UnknownCategory', 'Only can get the top and bottom ys of stavenotes and tabnotes');\n  }\n}\nfunction getInitialOffset(note, position) {\n  const isOnStemTip = position === ABOVE && note.getStemDirection() === Stem.UP || position === BELOW && note.getStemDirection() === Stem.DOWN;\n  if (isStaveOrGraceNote(note)) {\n    if (note.hasStem() && isOnStemTip) {\n      return 0.5;\n    } else {\n      return 1;\n    }\n  } else {\n    if (note.hasStem() && isOnStemTip) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n}\nclass Articulation extends Modifier {\n  static get CATEGORY() {\n    return \"Articulation\";\n  }\n  static format(articulations, state) {\n    if (!articulations || articulations.length === 0) return false;\n    const margin = 0.5;\n    let maxGlyphWidth = 0;\n    const getIncrement = (articulation, line, position) => roundToNearestHalf(getRoundingFunction(line, position), defined(articulation.glyph.getMetrics().height) / 10 + margin);\n    articulations.forEach(articulation => {\n      const note = articulation.checkAttachedNote();\n      maxGlyphWidth = Math.max(note.getGlyphProps().getWidth(), maxGlyphWidth);\n      let lines = 5;\n      const stemDirection = note.hasStem() ? note.getStemDirection() : Stem.UP;\n      let stemHeight = 0;\n      if (isStemmableNote(note)) {\n        const stem = note.getStem();\n        if (stem) {\n          stemHeight = Math.abs(stem.getHeight()) / Tables.STAVE_LINE_DISTANCE;\n        }\n      }\n      const stave = note.getStave();\n      if (stave) {\n        lines = stave.getNumLines();\n      }\n      if (articulation.getPosition() === ABOVE) {\n        let noteLine = note.getLineNumber(true);\n        if (stemDirection === Stem.UP) {\n          noteLine += stemHeight;\n        }\n        let increment = getIncrement(articulation, state.top_text_line, ABOVE);\n        const curTop = noteLine + state.top_text_line + 0.5;\n        if (!articulation.articulation.between_lines && curTop < lines) {\n          increment += lines - curTop;\n        }\n        articulation.setTextLine(state.top_text_line);\n        state.top_text_line += increment;\n      } else if (articulation.getPosition() === BELOW) {\n        let noteLine = Math.max(lines - note.getLineNumber(), 0);\n        if (stemDirection === Stem.DOWN) {\n          noteLine += stemHeight;\n        }\n        let increment = getIncrement(articulation, state.text_line, BELOW);\n        const curBottom = noteLine + state.text_line + 0.5;\n        if (!articulation.articulation.between_lines && curBottom < lines) {\n          increment += lines - curBottom;\n        }\n        articulation.setTextLine(state.text_line);\n        state.text_line += increment;\n      }\n    });\n    const width = articulations.map(articulation => articulation.getWidth()).reduce((maxWidth, articWidth) => Math.max(articWidth, maxWidth));\n    const overlap = Math.min(Math.max(width - maxGlyphWidth, 0), Math.max(width - (state.left_shift + state.right_shift), 0));\n    state.left_shift += overlap / 2;\n    state.right_shift += overlap / 2;\n    return true;\n  }\n  static easyScoreHook(_ref, note, builder) {\n    let {\n      articulations\n    } = _ref;\n    if (!articulations) return;\n    const articNameToCode = {\n      staccato: 'a.',\n      tenuto: 'a-',\n      accent: 'a>'\n    };\n    articulations.split(',').map(articString => articString.trim().split('.')).map(_ref2 => {\n      let [name, position] = _ref2;\n      const artic = {\n        type: articNameToCode[name]\n      };\n      if (position) artic.position = Modifier.PositionString[position];\n      return builder.getFactory().Articulation(artic);\n    }).map(artic => note.addModifier(artic, 0));\n  }\n  constructor(type) {\n    super();\n    this.type = type;\n    this.position = ABOVE;\n    this.render_options = {\n      font_scale: Tables.NOTATION_FONT_SCALE\n    };\n    this.reset();\n  }\n  reset() {\n    this.articulation = Tables.articulationCodes(this.type);\n    if (!this.articulation) {\n      this.articulation = {\n        code: this.type,\n        between_lines: false\n      };\n      if (this.type.endsWith('Above')) this.position = ABOVE;\n      if (this.type.endsWith('Below')) this.position = BELOW;\n    }\n    const code = (this.position === ABOVE ? this.articulation.aboveCode : this.articulation.belowCode) || this.articulation.code;\n    this.glyph = new Glyph(code !== null && code !== void 0 ? code : '', this.render_options.font_scale);\n    defined(this.glyph, 'ArgumentError', `Articulation not found: ${this.type}`);\n    this.setWidth(defined(this.glyph.getMetrics().width));\n  }\n  setBetweenLines() {\n    let betweenLines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this.articulation.between_lines = betweenLines;\n    return this;\n  }\n  draw() {\n    const ctx = this.checkContext();\n    const note = this.checkAttachedNote();\n    this.setRendered();\n    const index = this.checkIndex();\n    const {\n      position,\n      glyph,\n      text_line: textLine\n    } = this;\n    const canSitBetweenLines = this.articulation.between_lines;\n    const stave = note.checkStave();\n    const staffSpace = stave.getSpacingBetweenLines();\n    const isTab = isTabNote(note);\n    const {\n      x\n    } = note.getModifierStartXY(position, index);\n    const shouldSitOutsideStaff = !canSitBetweenLines || isTab;\n    const initialOffset = getInitialOffset(note, position);\n    const padding = Tables.currentMusicFont().lookupMetric(`articulation.${glyph.getCode()}.padding`, 0);\n    let y = {\n      [ABOVE]: () => {\n        glyph.setOrigin(0.5, 1);\n        const y = getTopY(note, textLine) - (textLine + initialOffset) * staffSpace;\n        return shouldSitOutsideStaff ? Math.min(stave.getYForTopText(Articulation.INITIAL_OFFSET), y) : y;\n      },\n      [BELOW]: () => {\n        glyph.setOrigin(0.5, 0);\n        const y = getBottomY(note, textLine) + (textLine + initialOffset) * staffSpace;\n        return shouldSitOutsideStaff ? Math.max(stave.getYForBottomText(Articulation.INITIAL_OFFSET), y) : y;\n      }\n    }[position]();\n    if (!isTab) {\n      const offsetDirection = position === ABOVE ? -1 : +1;\n      const noteLine = note.getKeyProps()[index].line;\n      const distanceFromNote = (note.getYs()[index] - y) / staffSpace;\n      const articLine = distanceFromNote + Number(noteLine);\n      const snappedLine = snapLineToStaff(canSitBetweenLines, articLine, position, offsetDirection);\n      if (isWithinLines(snappedLine, position)) glyph.setOrigin(0.5, 0.5);\n      y += Math.abs(snappedLine - articLine) * staffSpace * offsetDirection + padding * offsetDirection;\n    }\n    L(`Rendering articulation at (x: ${x}, y: ${y})`);\n    glyph.render(ctx, x, y);\n  }\n}\nArticulation.DEBUG = false;\nArticulation.INITIAL_OFFSET = -0.5;\nexport { Articulation };","map":{"version":3,"names":["Glyph","Modifier","Stem","Tables","isGraceNote","isStaveNote","isStemmableNote","isTabNote","defined","log","RuntimeError","L","_len","arguments","length","args","Array","_key","Articulation","DEBUG","ABOVE","BELOW","Position","roundToNearestHalf","mathFn","value","isWithinLines","line","position","getRoundingFunction","Math","ceil","floor","round","snapLineToStaff","canSitBetweenLines","offsetDirection","snappedLine","canSnapToStaffSpace","onStaffLine","HALF_STAFF_SPACE","isStaveOrGraceNote","note","getTopY","textLine","stemDirection","getStemDirection","topY","stemTipY","baseY","stemBaseY","getStemExtents","hasStem","UP","min","getYs","checkStave","getYForTopText","getBottomY","max","getYForBottomText","getInitialOffset","isOnStemTip","DOWN","CATEGORY","format","articulations","state","margin","maxGlyphWidth","getIncrement","articulation","glyph","getMetrics","height","forEach","checkAttachedNote","getGlyphProps","getWidth","lines","stemHeight","stem","getStem","abs","getHeight","STAVE_LINE_DISTANCE","stave","getStave","getNumLines","getPosition","noteLine","getLineNumber","increment","top_text_line","curTop","between_lines","setTextLine","text_line","curBottom","width","map","reduce","maxWidth","articWidth","overlap","left_shift","right_shift","easyScoreHook","_ref","builder","articNameToCode","staccato","tenuto","accent","split","articString","trim","_ref2","name","artic","type","PositionString","getFactory","addModifier","constructor","render_options","font_scale","NOTATION_FONT_SCALE","reset","articulationCodes","code","endsWith","aboveCode","belowCode","setWidth","setBetweenLines","betweenLines","undefined","draw","ctx","checkContext","setRendered","index","checkIndex","staffSpace","getSpacingBetweenLines","isTab","x","getModifierStartXY","shouldSitOutsideStaff","initialOffset","padding","currentMusicFont","lookupMetric","getCode","y","setOrigin","INITIAL_OFFSET","getKeyProps","distanceFromNote","articLine","Number","render"],"sources":["/Users/lang/Documents/code/Song2Notation/frontend/node_modules/vexflow/build/esm/src/articulation.js"],"sourcesContent":["import { Glyph } from './glyph.js';\nimport { Modifier } from './modifier.js';\nimport { Stem } from './stem.js';\nimport { Tables } from './tables.js';\nimport { isGraceNote, isStaveNote, isStemmableNote, isTabNote } from './typeguard.js';\nimport { defined, log, RuntimeError } from './util.js';\nfunction L(...args) {\n    if (Articulation.DEBUG)\n        log('Vex.Flow.Articulation', args);\n}\nconst { ABOVE, BELOW } = Modifier.Position;\nfunction roundToNearestHalf(mathFn, value) {\n    return mathFn(value / 0.5) * 0.5;\n}\nfunction isWithinLines(line, position) {\n    return position === ABOVE ? line <= 5 : line >= 1;\n}\nfunction getRoundingFunction(line, position) {\n    if (isWithinLines(line, position)) {\n        if (position === ABOVE) {\n            return Math.ceil;\n        }\n        else {\n            return Math.floor;\n        }\n    }\n    else {\n        return Math.round;\n    }\n}\nfunction snapLineToStaff(canSitBetweenLines, line, position, offsetDirection) {\n    const snappedLine = roundToNearestHalf(getRoundingFunction(line, position), line);\n    const canSnapToStaffSpace = canSitBetweenLines && isWithinLines(snappedLine, position);\n    const onStaffLine = snappedLine % 1 === 0;\n    if (canSnapToStaffSpace && onStaffLine) {\n        const HALF_STAFF_SPACE = 0.5;\n        return snappedLine + HALF_STAFF_SPACE * -offsetDirection;\n    }\n    else {\n        return snappedLine;\n    }\n}\nconst isStaveOrGraceNote = (note) => isStaveNote(note) || isGraceNote(note);\nfunction getTopY(note, textLine) {\n    const stemDirection = note.getStemDirection();\n    const { topY: stemTipY, baseY: stemBaseY } = note.getStemExtents();\n    if (isStaveOrGraceNote(note)) {\n        if (note.hasStem()) {\n            if (stemDirection === Stem.UP) {\n                return stemTipY;\n            }\n            else {\n                return stemBaseY;\n            }\n        }\n        else {\n            return Math.min(...note.getYs());\n        }\n    }\n    else if (isTabNote(note)) {\n        if (note.hasStem()) {\n            if (stemDirection === Stem.UP) {\n                return stemTipY;\n            }\n            else {\n                return note.checkStave().getYForTopText(textLine);\n            }\n        }\n        else {\n            return note.checkStave().getYForTopText(textLine);\n        }\n    }\n    else {\n        throw new RuntimeError('UnknownCategory', 'Only can get the top and bottom ys of stavenotes and tabnotes');\n    }\n}\nfunction getBottomY(note, textLine) {\n    const stemDirection = note.getStemDirection();\n    const { topY: stemTipY, baseY: stemBaseY } = note.getStemExtents();\n    if (isStaveOrGraceNote(note)) {\n        if (note.hasStem()) {\n            if (stemDirection === Stem.UP) {\n                return stemBaseY;\n            }\n            else {\n                return stemTipY;\n            }\n        }\n        else {\n            return Math.max(...note.getYs());\n        }\n    }\n    else if (isTabNote(note)) {\n        if (note.hasStem()) {\n            if (stemDirection === Stem.UP) {\n                return note.checkStave().getYForBottomText(textLine);\n            }\n            else {\n                return stemTipY;\n            }\n        }\n        else {\n            return note.checkStave().getYForBottomText(textLine);\n        }\n    }\n    else {\n        throw new RuntimeError('UnknownCategory', 'Only can get the top and bottom ys of stavenotes and tabnotes');\n    }\n}\nfunction getInitialOffset(note, position) {\n    const isOnStemTip = (position === ABOVE && note.getStemDirection() === Stem.UP) ||\n        (position === BELOW && note.getStemDirection() === Stem.DOWN);\n    if (isStaveOrGraceNote(note)) {\n        if (note.hasStem() && isOnStemTip) {\n            return 0.5;\n        }\n        else {\n            return 1;\n        }\n    }\n    else {\n        if (note.hasStem() && isOnStemTip) {\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    }\n}\nclass Articulation extends Modifier {\n    static get CATEGORY() {\n        return \"Articulation\";\n    }\n    static format(articulations, state) {\n        if (!articulations || articulations.length === 0)\n            return false;\n        const margin = 0.5;\n        let maxGlyphWidth = 0;\n        const getIncrement = (articulation, line, position) => roundToNearestHalf(getRoundingFunction(line, position), defined(articulation.glyph.getMetrics().height) / 10 + margin);\n        articulations.forEach((articulation) => {\n            const note = articulation.checkAttachedNote();\n            maxGlyphWidth = Math.max(note.getGlyphProps().getWidth(), maxGlyphWidth);\n            let lines = 5;\n            const stemDirection = note.hasStem() ? note.getStemDirection() : Stem.UP;\n            let stemHeight = 0;\n            if (isStemmableNote(note)) {\n                const stem = note.getStem();\n                if (stem) {\n                    stemHeight = Math.abs(stem.getHeight()) / Tables.STAVE_LINE_DISTANCE;\n                }\n            }\n            const stave = note.getStave();\n            if (stave) {\n                lines = stave.getNumLines();\n            }\n            if (articulation.getPosition() === ABOVE) {\n                let noteLine = note.getLineNumber(true);\n                if (stemDirection === Stem.UP) {\n                    noteLine += stemHeight;\n                }\n                let increment = getIncrement(articulation, state.top_text_line, ABOVE);\n                const curTop = noteLine + state.top_text_line + 0.5;\n                if (!articulation.articulation.between_lines && curTop < lines) {\n                    increment += lines - curTop;\n                }\n                articulation.setTextLine(state.top_text_line);\n                state.top_text_line += increment;\n            }\n            else if (articulation.getPosition() === BELOW) {\n                let noteLine = Math.max(lines - note.getLineNumber(), 0);\n                if (stemDirection === Stem.DOWN) {\n                    noteLine += stemHeight;\n                }\n                let increment = getIncrement(articulation, state.text_line, BELOW);\n                const curBottom = noteLine + state.text_line + 0.5;\n                if (!articulation.articulation.between_lines && curBottom < lines) {\n                    increment += lines - curBottom;\n                }\n                articulation.setTextLine(state.text_line);\n                state.text_line += increment;\n            }\n        });\n        const width = articulations\n            .map((articulation) => articulation.getWidth())\n            .reduce((maxWidth, articWidth) => Math.max(articWidth, maxWidth));\n        const overlap = Math.min(Math.max(width - maxGlyphWidth, 0), Math.max(width - (state.left_shift + state.right_shift), 0));\n        state.left_shift += overlap / 2;\n        state.right_shift += overlap / 2;\n        return true;\n    }\n    static easyScoreHook({ articulations }, note, builder) {\n        if (!articulations)\n            return;\n        const articNameToCode = {\n            staccato: 'a.',\n            tenuto: 'a-',\n            accent: 'a>',\n        };\n        articulations\n            .split(',')\n            .map((articString) => articString.trim().split('.'))\n            .map(([name, position]) => {\n            const artic = { type: articNameToCode[name] };\n            if (position)\n                artic.position = Modifier.PositionString[position];\n            return builder.getFactory().Articulation(artic);\n        })\n            .map((artic) => note.addModifier(artic, 0));\n    }\n    constructor(type) {\n        super();\n        this.type = type;\n        this.position = ABOVE;\n        this.render_options = {\n            font_scale: Tables.NOTATION_FONT_SCALE,\n        };\n        this.reset();\n    }\n    reset() {\n        this.articulation = Tables.articulationCodes(this.type);\n        if (!this.articulation) {\n            this.articulation = { code: this.type, between_lines: false };\n            if (this.type.endsWith('Above'))\n                this.position = ABOVE;\n            if (this.type.endsWith('Below'))\n                this.position = BELOW;\n        }\n        const code = (this.position === ABOVE ? this.articulation.aboveCode : this.articulation.belowCode) || this.articulation.code;\n        this.glyph = new Glyph(code !== null && code !== void 0 ? code : '', this.render_options.font_scale);\n        defined(this.glyph, 'ArgumentError', `Articulation not found: ${this.type}`);\n        this.setWidth(defined(this.glyph.getMetrics().width));\n    }\n    setBetweenLines(betweenLines = true) {\n        this.articulation.between_lines = betweenLines;\n        return this;\n    }\n    draw() {\n        const ctx = this.checkContext();\n        const note = this.checkAttachedNote();\n        this.setRendered();\n        const index = this.checkIndex();\n        const { position, glyph, text_line: textLine } = this;\n        const canSitBetweenLines = this.articulation.between_lines;\n        const stave = note.checkStave();\n        const staffSpace = stave.getSpacingBetweenLines();\n        const isTab = isTabNote(note);\n        const { x } = note.getModifierStartXY(position, index);\n        const shouldSitOutsideStaff = !canSitBetweenLines || isTab;\n        const initialOffset = getInitialOffset(note, position);\n        const padding = Tables.currentMusicFont().lookupMetric(`articulation.${glyph.getCode()}.padding`, 0);\n        let y = {\n            [ABOVE]: () => {\n                glyph.setOrigin(0.5, 1);\n                const y = getTopY(note, textLine) - (textLine + initialOffset) * staffSpace;\n                return shouldSitOutsideStaff ? Math.min(stave.getYForTopText(Articulation.INITIAL_OFFSET), y) : y;\n            },\n            [BELOW]: () => {\n                glyph.setOrigin(0.5, 0);\n                const y = getBottomY(note, textLine) + (textLine + initialOffset) * staffSpace;\n                return shouldSitOutsideStaff ? Math.max(stave.getYForBottomText(Articulation.INITIAL_OFFSET), y) : y;\n            },\n        }[position]();\n        if (!isTab) {\n            const offsetDirection = position === ABOVE ? -1 : +1;\n            const noteLine = note.getKeyProps()[index].line;\n            const distanceFromNote = (note.getYs()[index] - y) / staffSpace;\n            const articLine = distanceFromNote + Number(noteLine);\n            const snappedLine = snapLineToStaff(canSitBetweenLines, articLine, position, offsetDirection);\n            if (isWithinLines(snappedLine, position))\n                glyph.setOrigin(0.5, 0.5);\n            y += Math.abs(snappedLine - articLine) * staffSpace * offsetDirection + padding * offsetDirection;\n        }\n        L(`Rendering articulation at (x: ${x}, y: ${y})`);\n        glyph.render(ctx, x, y);\n    }\n}\nArticulation.DEBUG = false;\nArticulation.INITIAL_OFFSET = -0.5;\nexport { Articulation };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}