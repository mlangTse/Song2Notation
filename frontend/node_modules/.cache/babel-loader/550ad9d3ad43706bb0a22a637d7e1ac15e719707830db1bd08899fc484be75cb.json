{"ast":null,"code":"import { Element } from './element.js';\nimport { RuntimeError } from './util.js';\nexport var CurvePosition;\n(function (CurvePosition) {\n  CurvePosition[CurvePosition[\"NEAR_HEAD\"] = 1] = \"NEAR_HEAD\";\n  CurvePosition[CurvePosition[\"NEAR_TOP\"] = 2] = \"NEAR_TOP\";\n})(CurvePosition || (CurvePosition = {}));\nexport class Curve extends Element {\n  static get CATEGORY() {\n    return \"Curve\";\n  }\n  static get Position() {\n    return CurvePosition;\n  }\n  static get PositionString() {\n    return {\n      nearHead: CurvePosition.NEAR_HEAD,\n      nearTop: CurvePosition.NEAR_TOP\n    };\n  }\n  constructor(from, to, options) {\n    super();\n    this.render_options = Object.assign({\n      thickness: 2,\n      x_shift: 0,\n      y_shift: 10,\n      position: CurvePosition.NEAR_HEAD,\n      position_end: CurvePosition.NEAR_HEAD,\n      invert: false,\n      cps: [{\n        x: 0,\n        y: 10\n      }, {\n        x: 0,\n        y: 10\n      }]\n    }, options);\n    this.from = from;\n    this.to = to;\n  }\n  setNotes(from, to) {\n    if (!from && !to) {\n      throw new RuntimeError('BadArguments', 'Curve needs to have either `from` or `to` set.');\n    }\n    this.from = from;\n    this.to = to;\n    return this;\n  }\n  isPartial() {\n    return !this.from || !this.to;\n  }\n  renderCurve(params) {\n    const ctx = this.checkContext();\n    const x_shift = this.render_options.x_shift;\n    const y_shift = this.render_options.y_shift * params.direction;\n    const first_x = params.first_x + x_shift;\n    const first_y = params.first_y + y_shift;\n    const last_x = params.last_x - x_shift;\n    const last_y = params.last_y + y_shift;\n    const thickness = this.render_options.thickness;\n    const cps = this.render_options.cps;\n    const {\n      x: cp0x,\n      y: cp0y\n    } = cps[0];\n    const {\n      x: cp1x,\n      y: cp1y\n    } = cps[1];\n    const cp_spacing = (last_x - first_x) / (cps.length + 2);\n    ctx.beginPath();\n    ctx.moveTo(first_x, first_y);\n    ctx.bezierCurveTo(first_x + cp_spacing + cp0x, first_y + cp0y * params.direction, last_x - cp_spacing + cp1x, last_y + cp1y * params.direction, last_x, last_y);\n    ctx.bezierCurveTo(last_x - cp_spacing + cp1x, last_y + (cp1y + thickness) * params.direction, first_x + cp_spacing + cp0x, first_y + (cp0y + thickness) * params.direction, first_x, first_y);\n    ctx.stroke();\n    ctx.closePath();\n    ctx.fill();\n  }\n  draw() {\n    this.checkContext();\n    this.setRendered();\n    const first_note = this.from;\n    const last_note = this.to;\n    let first_x;\n    let last_x;\n    let first_y;\n    let last_y;\n    let stem_direction = 0;\n    let metric = 'baseY';\n    let end_metric = 'baseY';\n    function getPosition(position) {\n      return typeof position === 'string' ? Curve.PositionString[position] : position;\n    }\n    const position = getPosition(this.render_options.position);\n    const position_end = getPosition(this.render_options.position_end);\n    if (position === CurvePosition.NEAR_TOP) {\n      metric = 'topY';\n      end_metric = 'topY';\n    }\n    if (position_end === CurvePosition.NEAR_HEAD) {\n      end_metric = 'baseY';\n    } else if (position_end === CurvePosition.NEAR_TOP) {\n      end_metric = 'topY';\n    }\n    if (first_note) {\n      first_x = first_note.getTieRightX();\n      stem_direction = first_note.getStemDirection();\n      first_y = first_note.getStemExtents()[metric];\n    } else {\n      const stave = last_note.checkStave();\n      first_x = stave.getTieStartX();\n      first_y = last_note.getStemExtents()[metric];\n    }\n    if (last_note) {\n      last_x = last_note.getTieLeftX();\n      stem_direction = last_note.getStemDirection();\n      last_y = last_note.getStemExtents()[end_metric];\n    } else {\n      const stave = first_note.checkStave();\n      last_x = stave.getTieEndX();\n      last_y = first_note.getStemExtents()[end_metric];\n    }\n    this.renderCurve({\n      first_x,\n      last_x,\n      first_y,\n      last_y,\n      direction: stem_direction * (this.render_options.invert === true ? -1 : 1)\n    });\n    return true;\n  }\n}","map":{"version":3,"names":["Element","RuntimeError","CurvePosition","Curve","CATEGORY","Position","PositionString","nearHead","NEAR_HEAD","nearTop","NEAR_TOP","constructor","from","to","options","render_options","Object","assign","thickness","x_shift","y_shift","position","position_end","invert","cps","x","y","setNotes","isPartial","renderCurve","params","ctx","checkContext","direction","first_x","first_y","last_x","last_y","cp0x","cp0y","cp1x","cp1y","cp_spacing","length","beginPath","moveTo","bezierCurveTo","stroke","closePath","fill","draw","setRendered","first_note","last_note","stem_direction","metric","end_metric","getPosition","getTieRightX","getStemDirection","getStemExtents","stave","checkStave","getTieStartX","getTieLeftX","getTieEndX"],"sources":["/Users/lang/Documents/code/Song2Notation/frontend/node_modules/vexflow/build/esm/src/curve.js"],"sourcesContent":["import { Element } from './element.js';\nimport { RuntimeError } from './util.js';\nexport var CurvePosition;\n(function (CurvePosition) {\n    CurvePosition[CurvePosition[\"NEAR_HEAD\"] = 1] = \"NEAR_HEAD\";\n    CurvePosition[CurvePosition[\"NEAR_TOP\"] = 2] = \"NEAR_TOP\";\n})(CurvePosition || (CurvePosition = {}));\nexport class Curve extends Element {\n    static get CATEGORY() {\n        return \"Curve\";\n    }\n    static get Position() {\n        return CurvePosition;\n    }\n    static get PositionString() {\n        return {\n            nearHead: CurvePosition.NEAR_HEAD,\n            nearTop: CurvePosition.NEAR_TOP,\n        };\n    }\n    constructor(from, to, options) {\n        super();\n        this.render_options = Object.assign({ thickness: 2, x_shift: 0, y_shift: 10, position: CurvePosition.NEAR_HEAD, position_end: CurvePosition.NEAR_HEAD, invert: false, cps: [\n                { x: 0, y: 10 },\n                { x: 0, y: 10 },\n            ] }, options);\n        this.from = from;\n        this.to = to;\n    }\n    setNotes(from, to) {\n        if (!from && !to) {\n            throw new RuntimeError('BadArguments', 'Curve needs to have either `from` or `to` set.');\n        }\n        this.from = from;\n        this.to = to;\n        return this;\n    }\n    isPartial() {\n        return !this.from || !this.to;\n    }\n    renderCurve(params) {\n        const ctx = this.checkContext();\n        const x_shift = this.render_options.x_shift;\n        const y_shift = this.render_options.y_shift * params.direction;\n        const first_x = params.first_x + x_shift;\n        const first_y = params.first_y + y_shift;\n        const last_x = params.last_x - x_shift;\n        const last_y = params.last_y + y_shift;\n        const thickness = this.render_options.thickness;\n        const cps = this.render_options.cps;\n        const { x: cp0x, y: cp0y } = cps[0];\n        const { x: cp1x, y: cp1y } = cps[1];\n        const cp_spacing = (last_x - first_x) / (cps.length + 2);\n        ctx.beginPath();\n        ctx.moveTo(first_x, first_y);\n        ctx.bezierCurveTo(first_x + cp_spacing + cp0x, first_y + cp0y * params.direction, last_x - cp_spacing + cp1x, last_y + cp1y * params.direction, last_x, last_y);\n        ctx.bezierCurveTo(last_x - cp_spacing + cp1x, last_y + (cp1y + thickness) * params.direction, first_x + cp_spacing + cp0x, first_y + (cp0y + thickness) * params.direction, first_x, first_y);\n        ctx.stroke();\n        ctx.closePath();\n        ctx.fill();\n    }\n    draw() {\n        this.checkContext();\n        this.setRendered();\n        const first_note = this.from;\n        const last_note = this.to;\n        let first_x;\n        let last_x;\n        let first_y;\n        let last_y;\n        let stem_direction = 0;\n        let metric = 'baseY';\n        let end_metric = 'baseY';\n        function getPosition(position) {\n            return typeof position === 'string' ? Curve.PositionString[position] : position;\n        }\n        const position = getPosition(this.render_options.position);\n        const position_end = getPosition(this.render_options.position_end);\n        if (position === CurvePosition.NEAR_TOP) {\n            metric = 'topY';\n            end_metric = 'topY';\n        }\n        if (position_end === CurvePosition.NEAR_HEAD) {\n            end_metric = 'baseY';\n        }\n        else if (position_end === CurvePosition.NEAR_TOP) {\n            end_metric = 'topY';\n        }\n        if (first_note) {\n            first_x = first_note.getTieRightX();\n            stem_direction = first_note.getStemDirection();\n            first_y = first_note.getStemExtents()[metric];\n        }\n        else {\n            const stave = last_note.checkStave();\n            first_x = stave.getTieStartX();\n            first_y = last_note.getStemExtents()[metric];\n        }\n        if (last_note) {\n            last_x = last_note.getTieLeftX();\n            stem_direction = last_note.getStemDirection();\n            last_y = last_note.getStemExtents()[end_metric];\n        }\n        else {\n            const stave = first_note.checkStave();\n            last_x = stave.getTieEndX();\n            last_y = first_note.getStemExtents()[end_metric];\n        }\n        this.renderCurve({\n            first_x,\n            last_x,\n            first_y,\n            last_y,\n            direction: stem_direction * (this.render_options.invert === true ? -1 : 1),\n        });\n        return true;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}