{"ast":null,"code":"import { Element } from './element.js';\nimport { Modifier, ModifierPosition } from './modifier.js';\nimport { Stem } from './stem.js';\nimport { Tables } from './tables.js';\nimport { TextFormatter } from './textformatter.js';\nimport { isStemmableNote, isTabNote } from './typeguard.js';\nimport { log } from './util.js';\nfunction L() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  if (Annotation.DEBUG) log('Vex.Flow.Annotation', args);\n}\nexport var AnnotationHorizontalJustify;\n(function (AnnotationHorizontalJustify) {\n  AnnotationHorizontalJustify[AnnotationHorizontalJustify[\"LEFT\"] = 1] = \"LEFT\";\n  AnnotationHorizontalJustify[AnnotationHorizontalJustify[\"CENTER\"] = 2] = \"CENTER\";\n  AnnotationHorizontalJustify[AnnotationHorizontalJustify[\"RIGHT\"] = 3] = \"RIGHT\";\n  AnnotationHorizontalJustify[AnnotationHorizontalJustify[\"CENTER_STEM\"] = 4] = \"CENTER_STEM\";\n})(AnnotationHorizontalJustify || (AnnotationHorizontalJustify = {}));\nexport var AnnotationVerticalJustify;\n(function (AnnotationVerticalJustify) {\n  AnnotationVerticalJustify[AnnotationVerticalJustify[\"TOP\"] = 1] = \"TOP\";\n  AnnotationVerticalJustify[AnnotationVerticalJustify[\"CENTER\"] = 2] = \"CENTER\";\n  AnnotationVerticalJustify[AnnotationVerticalJustify[\"BOTTOM\"] = 3] = \"BOTTOM\";\n  AnnotationVerticalJustify[AnnotationVerticalJustify[\"CENTER_STEM\"] = 4] = \"CENTER_STEM\";\n})(AnnotationVerticalJustify || (AnnotationVerticalJustify = {}));\nclass Annotation extends Modifier {\n  static get CATEGORY() {\n    return \"Annotation\";\n  }\n  static get minAnnotationPadding() {\n    const musicFont = Tables.currentMusicFont();\n    return musicFont.lookupMetric('noteHead.minPadding');\n  }\n  static format(annotations, state) {\n    if (!annotations || annotations.length === 0) return false;\n    let leftWidth = 0;\n    let rightWidth = 0;\n    let maxLeftGlyphWidth = 0;\n    let maxRightGlyphWidth = 0;\n    for (let i = 0; i < annotations.length; ++i) {\n      const annotation = annotations[i];\n      const textFormatter = TextFormatter.create(annotation.textFont);\n      const textLines = (2 + textFormatter.getYForStringInPx(annotation.text).height) / Tables.STAVE_LINE_DISTANCE;\n      let verticalSpaceNeeded = textLines;\n      const note = annotation.checkAttachedNote();\n      const glyphWidth = note.getGlyphProps().getWidth();\n      const textWidth = textFormatter.getWidthForTextInPx(annotation.text);\n      if (annotation.horizontalJustification === AnnotationHorizontalJustify.LEFT) {\n        maxLeftGlyphWidth = Math.max(glyphWidth, maxLeftGlyphWidth);\n        leftWidth = Math.max(leftWidth, textWidth) + Annotation.minAnnotationPadding;\n      } else if (annotation.horizontalJustification === AnnotationHorizontalJustify.RIGHT) {\n        maxRightGlyphWidth = Math.max(glyphWidth, maxRightGlyphWidth);\n        rightWidth = Math.max(rightWidth, textWidth);\n      } else {\n        leftWidth = Math.max(leftWidth, textWidth / 2) + Annotation.minAnnotationPadding;\n        rightWidth = Math.max(rightWidth, textWidth / 2);\n        maxLeftGlyphWidth = Math.max(glyphWidth / 2, maxLeftGlyphWidth);\n        maxRightGlyphWidth = Math.max(glyphWidth / 2, maxRightGlyphWidth);\n      }\n      const stave = note.getStave();\n      const stemDirection = note.hasStem() ? note.getStemDirection() : Stem.UP;\n      let stemHeight = 0;\n      let lines = 5;\n      if (isTabNote(note)) {\n        if (note.render_options.draw_stem) {\n          const stem = note.getStem();\n          if (stem) {\n            stemHeight = Math.abs(stem.getHeight()) / Tables.STAVE_LINE_DISTANCE;\n          }\n        } else {\n          stemHeight = 0;\n        }\n      } else if (isStemmableNote(note)) {\n        const stem = note.getStem();\n        if (stem && note.getNoteType() === 'n') {\n          stemHeight = Math.abs(stem.getHeight()) / Tables.STAVE_LINE_DISTANCE;\n        }\n      }\n      if (stave) {\n        lines = stave.getNumLines();\n      }\n      if (annotation.verticalJustification === this.VerticalJustify.TOP) {\n        let noteLine = note.getLineNumber(true);\n        if (isTabNote(note)) {\n          noteLine = lines - (note.leastString() - 0.5);\n        }\n        if (stemDirection === Stem.UP) {\n          noteLine += stemHeight;\n        }\n        const curTop = noteLine + state.top_text_line + 0.5;\n        if (curTop < lines) {\n          annotation.setTextLine(lines - noteLine);\n          verticalSpaceNeeded += lines - noteLine;\n          state.top_text_line = verticalSpaceNeeded;\n        } else {\n          annotation.setTextLine(state.top_text_line);\n          state.top_text_line += verticalSpaceNeeded;\n        }\n      } else if (annotation.verticalJustification === this.VerticalJustify.BOTTOM) {\n        let noteLine = lines - note.getLineNumber();\n        if (isTabNote(note)) {\n          noteLine = note.greatestString() - 1;\n        }\n        if (stemDirection === Stem.DOWN) {\n          noteLine += stemHeight;\n        }\n        const curBottom = noteLine + state.text_line + 1;\n        if (curBottom < lines) {\n          annotation.setTextLine(lines - curBottom);\n          verticalSpaceNeeded += lines - curBottom;\n          state.text_line = verticalSpaceNeeded;\n        } else {\n          annotation.setTextLine(state.text_line);\n          state.text_line += verticalSpaceNeeded;\n        }\n      } else {\n        annotation.setTextLine(state.text_line);\n      }\n    }\n    const rightOverlap = Math.min(Math.max(rightWidth - maxRightGlyphWidth, 0), Math.max(rightWidth - state.right_shift, 0));\n    const leftOverlap = Math.min(Math.max(leftWidth - maxLeftGlyphWidth, 0), Math.max(leftWidth - state.left_shift, 0));\n    state.left_shift += leftOverlap;\n    state.right_shift += rightOverlap;\n    return true;\n  }\n  constructor(text) {\n    super();\n    this.text = text;\n    this.horizontalJustification = AnnotationHorizontalJustify.CENTER;\n    this.verticalJustification = AnnotationVerticalJustify.TOP;\n    this.resetFont();\n    this.setWidth(Tables.textWidth(text));\n  }\n  setVerticalJustification(just) {\n    this.verticalJustification = typeof just === 'string' ? Annotation.VerticalJustifyString[just] : just;\n    return this;\n  }\n  getJustification() {\n    return this.horizontalJustification;\n  }\n  setJustification(just) {\n    this.horizontalJustification = typeof just === 'string' ? Annotation.HorizontalJustifyString[just] : just;\n    return this;\n  }\n  draw() {\n    const ctx = this.checkContext();\n    const note = this.checkAttachedNote();\n    const stemDirection = note.hasStem() ? note.getStemDirection() : Stem.UP;\n    const textFormatter = TextFormatter.create(this.textFont);\n    const start = note.getModifierStartXY(ModifierPosition.ABOVE, this.index);\n    this.setRendered();\n    ctx.save();\n    this.applyStyle();\n    ctx.openGroup('annotation', this.getAttribute('id'));\n    ctx.setFont(this.textFont);\n    const text_width = textFormatter.getWidthForTextInPx(this.text);\n    const text_height = textFormatter.getYForStringInPx(this.text).height;\n    let x;\n    let y;\n    if (this.horizontalJustification === AnnotationHorizontalJustify.LEFT) {\n      x = start.x;\n    } else if (this.horizontalJustification === AnnotationHorizontalJustify.RIGHT) {\n      x = start.x - text_width;\n    } else if (this.horizontalJustification === AnnotationHorizontalJustify.CENTER) {\n      x = start.x - text_width / 2;\n    } else {\n      x = note.getStemX() - text_width / 2;\n    }\n    let stem_ext = {};\n    let spacing = 0;\n    const has_stem = note.hasStem();\n    const stave = note.checkStave();\n    if (has_stem) {\n      stem_ext = note.checkStem().getExtents();\n      spacing = stave.getSpacingBetweenLines();\n    }\n    if (this.verticalJustification === AnnotationVerticalJustify.BOTTOM) {\n      const ys = note.getYs();\n      y = ys.reduce((a, b) => a > b ? a : b);\n      y += (this.text_line + 1) * Tables.STAVE_LINE_DISTANCE + text_height;\n      if (has_stem && stemDirection === Stem.DOWN) {\n        y = Math.max(y, stem_ext.topY + text_height + spacing * this.text_line);\n      }\n    } else if (this.verticalJustification === AnnotationVerticalJustify.CENTER) {\n      const yt = note.getYForTopText(this.text_line) - 1;\n      const yb = stave.getYForBottomText(this.text_line);\n      y = yt + (yb - yt) / 2 + text_height / 2;\n    } else if (this.verticalJustification === AnnotationVerticalJustify.TOP) {\n      const topY = Math.min(...note.getYs());\n      y = topY - (this.text_line + 1) * Tables.STAVE_LINE_DISTANCE;\n      if (has_stem && stemDirection === Stem.UP) {\n        spacing = stem_ext.topY < stave.getTopLineTopY() ? Tables.STAVE_LINE_DISTANCE : spacing;\n        y = Math.min(y, stem_ext.topY - spacing * (this.text_line + 1));\n      }\n    } else {\n      const extents = note.getStemExtents();\n      y = extents.topY + (extents.baseY - extents.topY) / 2 + text_height / 2;\n    }\n    L('Rendering annotation: ', this.text, x, y);\n    ctx.fillText(this.text, x, y);\n    ctx.closeGroup();\n    this.restoreStyle();\n    ctx.restore();\n  }\n}\nAnnotation.DEBUG = false;\nAnnotation.TEXT_FONT = Object.assign({}, Element.TEXT_FONT);\nAnnotation.HorizontalJustify = AnnotationHorizontalJustify;\nAnnotation.HorizontalJustifyString = {\n  left: AnnotationHorizontalJustify.LEFT,\n  right: AnnotationHorizontalJustify.RIGHT,\n  center: AnnotationHorizontalJustify.CENTER,\n  centerStem: AnnotationHorizontalJustify.CENTER_STEM\n};\nAnnotation.VerticalJustify = AnnotationVerticalJustify;\nAnnotation.VerticalJustifyString = {\n  above: AnnotationVerticalJustify.TOP,\n  top: AnnotationVerticalJustify.TOP,\n  below: AnnotationVerticalJustify.BOTTOM,\n  bottom: AnnotationVerticalJustify.BOTTOM,\n  center: AnnotationVerticalJustify.CENTER,\n  centerStem: AnnotationVerticalJustify.CENTER_STEM\n};\nexport { Annotation };","map":{"version":3,"names":["Element","Modifier","ModifierPosition","Stem","Tables","TextFormatter","isStemmableNote","isTabNote","log","L","_len","arguments","length","args","Array","_key","Annotation","DEBUG","AnnotationHorizontalJustify","AnnotationVerticalJustify","CATEGORY","minAnnotationPadding","musicFont","currentMusicFont","lookupMetric","format","annotations","state","leftWidth","rightWidth","maxLeftGlyphWidth","maxRightGlyphWidth","i","annotation","textFormatter","create","textFont","textLines","getYForStringInPx","text","height","STAVE_LINE_DISTANCE","verticalSpaceNeeded","note","checkAttachedNote","glyphWidth","getGlyphProps","getWidth","textWidth","getWidthForTextInPx","horizontalJustification","LEFT","Math","max","RIGHT","stave","getStave","stemDirection","hasStem","getStemDirection","UP","stemHeight","lines","render_options","draw_stem","stem","getStem","abs","getHeight","getNoteType","getNumLines","verticalJustification","VerticalJustify","TOP","noteLine","getLineNumber","leastString","curTop","top_text_line","setTextLine","BOTTOM","greatestString","DOWN","curBottom","text_line","rightOverlap","min","right_shift","leftOverlap","left_shift","constructor","CENTER","resetFont","setWidth","setVerticalJustification","just","VerticalJustifyString","getJustification","setJustification","HorizontalJustifyString","draw","ctx","checkContext","start","getModifierStartXY","ABOVE","index","setRendered","save","applyStyle","openGroup","getAttribute","setFont","text_width","text_height","x","y","getStemX","stem_ext","spacing","has_stem","checkStave","checkStem","getExtents","getSpacingBetweenLines","ys","getYs","reduce","a","b","topY","yt","getYForTopText","yb","getYForBottomText","getTopLineTopY","extents","getStemExtents","baseY","fillText","closeGroup","restoreStyle","restore","TEXT_FONT","Object","assign","HorizontalJustify","left","right","center","centerStem","CENTER_STEM","above","top","below","bottom"],"sources":["/Users/lang/Documents/code/Song2Notation/frontend/node_modules/vexflow/build/esm/src/annotation.js"],"sourcesContent":["import { Element } from './element.js';\nimport { Modifier, ModifierPosition } from './modifier.js';\nimport { Stem } from './stem.js';\nimport { Tables } from './tables.js';\nimport { TextFormatter } from './textformatter.js';\nimport { isStemmableNote, isTabNote } from './typeguard.js';\nimport { log } from './util.js';\nfunction L(...args) {\n    if (Annotation.DEBUG)\n        log('Vex.Flow.Annotation', args);\n}\nexport var AnnotationHorizontalJustify;\n(function (AnnotationHorizontalJustify) {\n    AnnotationHorizontalJustify[AnnotationHorizontalJustify[\"LEFT\"] = 1] = \"LEFT\";\n    AnnotationHorizontalJustify[AnnotationHorizontalJustify[\"CENTER\"] = 2] = \"CENTER\";\n    AnnotationHorizontalJustify[AnnotationHorizontalJustify[\"RIGHT\"] = 3] = \"RIGHT\";\n    AnnotationHorizontalJustify[AnnotationHorizontalJustify[\"CENTER_STEM\"] = 4] = \"CENTER_STEM\";\n})(AnnotationHorizontalJustify || (AnnotationHorizontalJustify = {}));\nexport var AnnotationVerticalJustify;\n(function (AnnotationVerticalJustify) {\n    AnnotationVerticalJustify[AnnotationVerticalJustify[\"TOP\"] = 1] = \"TOP\";\n    AnnotationVerticalJustify[AnnotationVerticalJustify[\"CENTER\"] = 2] = \"CENTER\";\n    AnnotationVerticalJustify[AnnotationVerticalJustify[\"BOTTOM\"] = 3] = \"BOTTOM\";\n    AnnotationVerticalJustify[AnnotationVerticalJustify[\"CENTER_STEM\"] = 4] = \"CENTER_STEM\";\n})(AnnotationVerticalJustify || (AnnotationVerticalJustify = {}));\nclass Annotation extends Modifier {\n    static get CATEGORY() {\n        return \"Annotation\";\n    }\n    static get minAnnotationPadding() {\n        const musicFont = Tables.currentMusicFont();\n        return musicFont.lookupMetric('noteHead.minPadding');\n    }\n    static format(annotations, state) {\n        if (!annotations || annotations.length === 0)\n            return false;\n        let leftWidth = 0;\n        let rightWidth = 0;\n        let maxLeftGlyphWidth = 0;\n        let maxRightGlyphWidth = 0;\n        for (let i = 0; i < annotations.length; ++i) {\n            const annotation = annotations[i];\n            const textFormatter = TextFormatter.create(annotation.textFont);\n            const textLines = (2 + textFormatter.getYForStringInPx(annotation.text).height) / Tables.STAVE_LINE_DISTANCE;\n            let verticalSpaceNeeded = textLines;\n            const note = annotation.checkAttachedNote();\n            const glyphWidth = note.getGlyphProps().getWidth();\n            const textWidth = textFormatter.getWidthForTextInPx(annotation.text);\n            if (annotation.horizontalJustification === AnnotationHorizontalJustify.LEFT) {\n                maxLeftGlyphWidth = Math.max(glyphWidth, maxLeftGlyphWidth);\n                leftWidth = Math.max(leftWidth, textWidth) + Annotation.minAnnotationPadding;\n            }\n            else if (annotation.horizontalJustification === AnnotationHorizontalJustify.RIGHT) {\n                maxRightGlyphWidth = Math.max(glyphWidth, maxRightGlyphWidth);\n                rightWidth = Math.max(rightWidth, textWidth);\n            }\n            else {\n                leftWidth = Math.max(leftWidth, textWidth / 2) + Annotation.minAnnotationPadding;\n                rightWidth = Math.max(rightWidth, textWidth / 2);\n                maxLeftGlyphWidth = Math.max(glyphWidth / 2, maxLeftGlyphWidth);\n                maxRightGlyphWidth = Math.max(glyphWidth / 2, maxRightGlyphWidth);\n            }\n            const stave = note.getStave();\n            const stemDirection = note.hasStem() ? note.getStemDirection() : Stem.UP;\n            let stemHeight = 0;\n            let lines = 5;\n            if (isTabNote(note)) {\n                if (note.render_options.draw_stem) {\n                    const stem = note.getStem();\n                    if (stem) {\n                        stemHeight = Math.abs(stem.getHeight()) / Tables.STAVE_LINE_DISTANCE;\n                    }\n                }\n                else {\n                    stemHeight = 0;\n                }\n            }\n            else if (isStemmableNote(note)) {\n                const stem = note.getStem();\n                if (stem && note.getNoteType() === 'n') {\n                    stemHeight = Math.abs(stem.getHeight()) / Tables.STAVE_LINE_DISTANCE;\n                }\n            }\n            if (stave) {\n                lines = stave.getNumLines();\n            }\n            if (annotation.verticalJustification === this.VerticalJustify.TOP) {\n                let noteLine = note.getLineNumber(true);\n                if (isTabNote(note)) {\n                    noteLine = lines - (note.leastString() - 0.5);\n                }\n                if (stemDirection === Stem.UP) {\n                    noteLine += stemHeight;\n                }\n                const curTop = noteLine + state.top_text_line + 0.5;\n                if (curTop < lines) {\n                    annotation.setTextLine(lines - noteLine);\n                    verticalSpaceNeeded += lines - noteLine;\n                    state.top_text_line = verticalSpaceNeeded;\n                }\n                else {\n                    annotation.setTextLine(state.top_text_line);\n                    state.top_text_line += verticalSpaceNeeded;\n                }\n            }\n            else if (annotation.verticalJustification === this.VerticalJustify.BOTTOM) {\n                let noteLine = lines - note.getLineNumber();\n                if (isTabNote(note)) {\n                    noteLine = note.greatestString() - 1;\n                }\n                if (stemDirection === Stem.DOWN) {\n                    noteLine += stemHeight;\n                }\n                const curBottom = noteLine + state.text_line + 1;\n                if (curBottom < lines) {\n                    annotation.setTextLine(lines - curBottom);\n                    verticalSpaceNeeded += lines - curBottom;\n                    state.text_line = verticalSpaceNeeded;\n                }\n                else {\n                    annotation.setTextLine(state.text_line);\n                    state.text_line += verticalSpaceNeeded;\n                }\n            }\n            else {\n                annotation.setTextLine(state.text_line);\n            }\n        }\n        const rightOverlap = Math.min(Math.max(rightWidth - maxRightGlyphWidth, 0), Math.max(rightWidth - state.right_shift, 0));\n        const leftOverlap = Math.min(Math.max(leftWidth - maxLeftGlyphWidth, 0), Math.max(leftWidth - state.left_shift, 0));\n        state.left_shift += leftOverlap;\n        state.right_shift += rightOverlap;\n        return true;\n    }\n    constructor(text) {\n        super();\n        this.text = text;\n        this.horizontalJustification = AnnotationHorizontalJustify.CENTER;\n        this.verticalJustification = AnnotationVerticalJustify.TOP;\n        this.resetFont();\n        this.setWidth(Tables.textWidth(text));\n    }\n    setVerticalJustification(just) {\n        this.verticalJustification = typeof just === 'string' ? Annotation.VerticalJustifyString[just] : just;\n        return this;\n    }\n    getJustification() {\n        return this.horizontalJustification;\n    }\n    setJustification(just) {\n        this.horizontalJustification = typeof just === 'string' ? Annotation.HorizontalJustifyString[just] : just;\n        return this;\n    }\n    draw() {\n        const ctx = this.checkContext();\n        const note = this.checkAttachedNote();\n        const stemDirection = note.hasStem() ? note.getStemDirection() : Stem.UP;\n        const textFormatter = TextFormatter.create(this.textFont);\n        const start = note.getModifierStartXY(ModifierPosition.ABOVE, this.index);\n        this.setRendered();\n        ctx.save();\n        this.applyStyle();\n        ctx.openGroup('annotation', this.getAttribute('id'));\n        ctx.setFont(this.textFont);\n        const text_width = textFormatter.getWidthForTextInPx(this.text);\n        const text_height = textFormatter.getYForStringInPx(this.text).height;\n        let x;\n        let y;\n        if (this.horizontalJustification === AnnotationHorizontalJustify.LEFT) {\n            x = start.x;\n        }\n        else if (this.horizontalJustification === AnnotationHorizontalJustify.RIGHT) {\n            x = start.x - text_width;\n        }\n        else if (this.horizontalJustification === AnnotationHorizontalJustify.CENTER) {\n            x = start.x - text_width / 2;\n        }\n        else {\n            x = note.getStemX() - text_width / 2;\n        }\n        let stem_ext = {};\n        let spacing = 0;\n        const has_stem = note.hasStem();\n        const stave = note.checkStave();\n        if (has_stem) {\n            stem_ext = note.checkStem().getExtents();\n            spacing = stave.getSpacingBetweenLines();\n        }\n        if (this.verticalJustification === AnnotationVerticalJustify.BOTTOM) {\n            const ys = note.getYs();\n            y = ys.reduce((a, b) => (a > b ? a : b));\n            y += (this.text_line + 1) * Tables.STAVE_LINE_DISTANCE + text_height;\n            if (has_stem && stemDirection === Stem.DOWN) {\n                y = Math.max(y, stem_ext.topY + text_height + spacing * this.text_line);\n            }\n        }\n        else if (this.verticalJustification === AnnotationVerticalJustify.CENTER) {\n            const yt = note.getYForTopText(this.text_line) - 1;\n            const yb = stave.getYForBottomText(this.text_line);\n            y = yt + (yb - yt) / 2 + text_height / 2;\n        }\n        else if (this.verticalJustification === AnnotationVerticalJustify.TOP) {\n            const topY = Math.min(...note.getYs());\n            y = topY - (this.text_line + 1) * Tables.STAVE_LINE_DISTANCE;\n            if (has_stem && stemDirection === Stem.UP) {\n                spacing = stem_ext.topY < stave.getTopLineTopY() ? Tables.STAVE_LINE_DISTANCE : spacing;\n                y = Math.min(y, stem_ext.topY - spacing * (this.text_line + 1));\n            }\n        }\n        else {\n            const extents = note.getStemExtents();\n            y = extents.topY + (extents.baseY - extents.topY) / 2 + text_height / 2;\n        }\n        L('Rendering annotation: ', this.text, x, y);\n        ctx.fillText(this.text, x, y);\n        ctx.closeGroup();\n        this.restoreStyle();\n        ctx.restore();\n    }\n}\nAnnotation.DEBUG = false;\nAnnotation.TEXT_FONT = Object.assign({}, Element.TEXT_FONT);\nAnnotation.HorizontalJustify = AnnotationHorizontalJustify;\nAnnotation.HorizontalJustifyString = {\n    left: AnnotationHorizontalJustify.LEFT,\n    right: AnnotationHorizontalJustify.RIGHT,\n    center: AnnotationHorizontalJustify.CENTER,\n    centerStem: AnnotationHorizontalJustify.CENTER_STEM,\n};\nAnnotation.VerticalJustify = AnnotationVerticalJustify;\nAnnotation.VerticalJustifyString = {\n    above: AnnotationVerticalJustify.TOP,\n    top: AnnotationVerticalJustify.TOP,\n    below: AnnotationVerticalJustify.BOTTOM,\n    bottom: AnnotationVerticalJustify.BOTTOM,\n    center: AnnotationVerticalJustify.CENTER,\n    centerStem: AnnotationVerticalJustify.CENTER_STEM,\n};\nexport { Annotation };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}