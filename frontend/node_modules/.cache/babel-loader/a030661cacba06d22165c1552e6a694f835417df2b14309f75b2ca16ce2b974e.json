{"ast":null,"code":"import { BoundingBox } from './boundingbox.js';\nimport { BoundingBoxComputation } from './boundingboxcomputation.js';\nimport { Element } from './element.js';\nimport { Tables } from './tables.js';\nimport { defined, RuntimeError } from './util.js';\nclass GlyphCacheEntry {\n  constructor(fontStack, code, category) {\n    this.point = -1;\n    this.metrics = Glyph.loadMetrics(fontStack, code, category);\n    this.bbox = Glyph.getOutlineBoundingBox(this.metrics.outline, this.metrics.scale, this.metrics.x_shift, this.metrics.y_shift);\n    if (category) {\n      this.point = Glyph.lookupFontMetric(this.metrics.font, category, code, 'point', -1);\n    }\n  }\n}\nclass GlyphCache {\n  constructor() {\n    this.cache = new Map();\n  }\n  lookup(code, category) {\n    let entries = this.cache.get(Glyph.CURRENT_CACHE_KEY);\n    if (entries === undefined) {\n      entries = {};\n      this.cache.set(Glyph.CURRENT_CACHE_KEY, entries);\n    }\n    const key = category ? `${code}%${category}` : code;\n    let entry = entries[key];\n    if (entry === undefined) {\n      entry = new GlyphCacheEntry(Glyph.MUSIC_FONT_STACK, code, category);\n      entries[key] = entry;\n    }\n    return entry;\n  }\n}\nclass GlyphOutline {\n  constructor(outline, originX, originY, scale) {\n    this.outline = outline;\n    this.originX = originX;\n    this.originY = originY;\n    this.scale = scale;\n    this.i = 0;\n    this.precision = 1;\n    this.precision = Math.pow(10, Tables.RENDER_PRECISION_PLACES);\n  }\n  done() {\n    return this.i >= this.outline.length;\n  }\n  next() {\n    return Math.round(this.outline[this.i++] * this.precision / this.precision);\n  }\n  nextX() {\n    return Math.round((this.originX + this.outline[this.i++] * this.scale) * this.precision) / this.precision;\n  }\n  nextY() {\n    return Math.round((this.originY - this.outline[this.i++] * this.scale) * this.precision) / this.precision;\n  }\n  static parse(str) {\n    const result = [];\n    const parts = str.split(' ');\n    let i = 0;\n    while (i < parts.length) {\n      switch (parts[i++]) {\n        case 'm':\n          result.push(0, parseInt(parts[i++]), parseInt(parts[i++]));\n          break;\n        case 'l':\n          result.push(1, parseInt(parts[i++]), parseInt(parts[i++]));\n          break;\n        case 'q':\n          result.push(2, parseInt(parts[i++]), parseInt(parts[i++]), parseInt(parts[i++]), parseInt(parts[i++]));\n          break;\n        case 'b':\n          result.push(3, parseInt(parts[i++]), parseInt(parts[i++]), parseInt(parts[i++]), parseInt(parts[i++]), parseInt(parts[i++]), parseInt(parts[i++]));\n          break;\n      }\n    }\n    return result;\n  }\n}\nclass Glyph extends Element {\n  static get CATEGORY() {\n    return \"Glyph\";\n  }\n  static lookupFontMetric(font, category, code, key, defaultValue) {\n    let value = font.lookupMetric(`glyphs.${category}.${code}.${key}`, undefined);\n    if (value === undefined) {\n      value = font.lookupMetric(`glyphs.${category}.${key}`, defaultValue);\n    }\n    return value;\n  }\n  static lookupGlyph(fontStack, code) {\n    defined(fontStack, 'BadFontStack', 'Font stack is misconfigured');\n    let glyph;\n    let font;\n    for (let i = 0; i < fontStack.length; i++) {\n      font = fontStack[i];\n      glyph = font.getGlyphs()[code];\n      if (glyph) return {\n        glyph,\n        font\n      };\n    }\n    throw new RuntimeError('BadGlyph', `Glyph ${code} does not exist in font.`);\n  }\n  static loadMetrics(fontStack, code, category) {\n    const {\n      glyph,\n      font\n    } = Glyph.lookupGlyph(fontStack, code);\n    if (!glyph.o) throw new RuntimeError('BadGlyph', `Glyph ${code} has no outline defined.`);\n    let x_shift = 0;\n    let y_shift = 0;\n    let scale = 1;\n    if (category && font) {\n      x_shift = Glyph.lookupFontMetric(font, category, code, 'shiftX', 0);\n      y_shift = Glyph.lookupFontMetric(font, category, code, 'shiftY', 0);\n      scale = Glyph.lookupFontMetric(font, category, code, 'scale', 1);\n    }\n    const x_min = glyph.x_min;\n    const x_max = glyph.x_max;\n    const ha = glyph.ha;\n    if (!glyph.cached_outline) {\n      glyph.cached_outline = GlyphOutline.parse(glyph.o);\n    }\n    return {\n      x_min,\n      x_max,\n      x_shift,\n      y_shift,\n      scale,\n      ha,\n      outline: glyph.cached_outline,\n      font,\n      width: x_max - x_min,\n      height: ha\n    };\n  }\n  static renderGlyph(ctx, x_pos, y_pos, point, code, options) {\n    var _a;\n    const data = Glyph.cache.lookup(code, options === null || options === void 0 ? void 0 : options.category);\n    const metrics = data.metrics;\n    if (data.point != -1) {\n      point = data.point;\n    }\n    const customScale = (_a = options === null || options === void 0 ? void 0 : options.scale) !== null && _a !== void 0 ? _a : 1;\n    const scale = point * 72.0 / (metrics.font.getResolution() * 100.0) * metrics.scale * customScale;\n    Glyph.renderOutline(ctx, metrics.outline, scale, x_pos + metrics.x_shift * customScale, y_pos + metrics.y_shift * customScale);\n    return metrics;\n  }\n  static renderOutline(ctx, outline, scale, x_pos, y_pos) {\n    const go = new GlyphOutline(outline, x_pos, y_pos, scale);\n    ctx.beginPath();\n    let x, y;\n    while (!go.done()) {\n      switch (go.next()) {\n        case 0:\n          ctx.moveTo(go.nextX(), go.nextY());\n          break;\n        case 1:\n          ctx.lineTo(go.nextX(), go.nextY());\n          break;\n        case 2:\n          x = go.nextX();\n          y = go.nextY();\n          ctx.quadraticCurveTo(go.nextX(), go.nextY(), x, y);\n          break;\n        case 3:\n          x = go.nextX();\n          y = go.nextY();\n          ctx.bezierCurveTo(go.nextX(), go.nextY(), go.nextX(), go.nextY(), x, y);\n          break;\n      }\n    }\n    ctx.fill();\n  }\n  static getOutlineBoundingBox(outline, scale, x_pos, y_pos) {\n    const go = new GlyphOutline(outline, x_pos, y_pos, scale);\n    const bboxComp = new BoundingBoxComputation();\n    let penX = x_pos;\n    let penY = y_pos;\n    let x, y;\n    while (!go.done()) {\n      switch (go.next()) {\n        case 0:\n          penX = go.nextX();\n          penY = go.nextY();\n          break;\n        case 1:\n          bboxComp.addPoint(penX, penY);\n          penX = go.nextX();\n          penY = go.nextY();\n          bboxComp.addPoint(penX, penY);\n          break;\n        case 2:\n          x = go.nextX();\n          y = go.nextY();\n          bboxComp.addQuadraticCurve(penX, penY, go.nextX(), go.nextY(), x, y);\n          penX = x;\n          penY = y;\n          break;\n        case 3:\n          x = go.nextX();\n          y = go.nextY();\n          bboxComp.addBezierCurve(penX, penY, go.nextX(), go.nextY(), go.nextX(), go.nextY(), x, y);\n          penX = x;\n          penY = y;\n          break;\n      }\n    }\n    return new BoundingBox(bboxComp.getX1(), bboxComp.getY1(), bboxComp.width(), bboxComp.height());\n  }\n  static getWidth(code, point, category) {\n    const data = Glyph.cache.lookup(code, category);\n    if (data.point != -1) {\n      point = data.point;\n    }\n    const scale = point * 72 / (data.metrics.font.getResolution() * 100);\n    return data.bbox.getW() * scale;\n  }\n  constructor(code, point, options) {\n    super();\n    this.bbox = new BoundingBox(0, 0, 0, 0);\n    this.topGlyphs = [];\n    this.botGlyphs = [];\n    this.options = {};\n    this.scale = 1;\n    this.code = code;\n    this.point = point;\n    this.originShift = {\n      x: 0,\n      y: 0\n    };\n    this.x_shift = 0;\n    this.y_shift = 0;\n    if (options) {\n      this.setOptions(options);\n    } else {\n      this.reset();\n    }\n  }\n  draw() {}\n  getCode() {\n    return this.code;\n  }\n  setOptions(options) {\n    this.options = Object.assign(Object.assign({}, this.options), options);\n    this.reset();\n  }\n  setPoint(point) {\n    this.point = point;\n    return this;\n  }\n  setStave(stave) {\n    this.stave = stave;\n    return this;\n  }\n  getXShift() {\n    return this.x_shift;\n  }\n  setXShift(x_shift) {\n    this.x_shift = x_shift;\n    return this;\n  }\n  getYshift() {\n    return this.y_shift;\n  }\n  setYShift(y_shift) {\n    this.y_shift = y_shift;\n    return this;\n  }\n  reset() {\n    const data = Glyph.cache.lookup(this.code, this.options.category);\n    this.metrics = data.metrics;\n    if (data.point != -1) {\n      this.point = data.point;\n    }\n    this.scale = this.point * 72 / (this.metrics.font.getResolution() * 100);\n    this.bbox = new BoundingBox(data.bbox.getX() * this.scale, data.bbox.getY() * this.scale, data.bbox.getW() * this.scale, data.bbox.getH() * this.scale);\n  }\n  checkMetrics() {\n    return defined(this.metrics, 'BadGlyph', `Glyph ${this.code} is not initialized.`);\n  }\n  getMetrics() {\n    const metrics = this.checkMetrics();\n    const metricsScale = metrics.scale;\n    return {\n      x_min: metrics.x_min * this.scale * metricsScale,\n      x_max: metrics.x_max * this.scale * metricsScale,\n      width: this.bbox.getW(),\n      height: this.bbox.getH(),\n      scale: this.scale * metricsScale,\n      x_shift: metrics.x_shift,\n      y_shift: metrics.y_shift,\n      outline: metrics.outline,\n      font: metrics.font,\n      ha: metrics.ha\n    };\n  }\n  setOriginX(x) {\n    const {\n      bbox\n    } = this;\n    const originX = Math.abs(bbox.getX() / bbox.getW());\n    const xShift = (x - originX) * bbox.getW();\n    this.originShift.x = -xShift;\n  }\n  setOriginY(y) {\n    const {\n      bbox\n    } = this;\n    const originY = Math.abs(bbox.getY() / bbox.getH());\n    const yShift = (y - originY) * bbox.getH();\n    this.originShift.y = -yShift;\n  }\n  setOrigin(x, y) {\n    this.setOriginX(x);\n    this.setOriginY(y);\n  }\n  render(ctx, x, y) {\n    const metrics = this.checkMetrics();\n    const outline = metrics.outline;\n    const scale = this.scale * metrics.scale;\n    this.setRendered();\n    this.applyStyle(ctx);\n    const xPos = x + this.originShift.x + metrics.x_shift;\n    const yPos = y + this.originShift.y + metrics.y_shift;\n    Glyph.renderOutline(ctx, outline, scale, xPos, yPos);\n    this.restoreStyle(ctx);\n  }\n  checkStave() {\n    return defined(this.stave, 'NoStave', 'No stave attached to instance.');\n  }\n  renderToStave(x) {\n    const context = this.checkContext();\n    const metrics = this.checkMetrics();\n    const stave = this.checkStave();\n    const outline = metrics.outline;\n    const scale = this.scale * metrics.scale;\n    this.setRendered();\n    this.applyStyle();\n    const xPos = x + this.x_shift + metrics.x_shift;\n    const yPos = stave.getYForGlyphs() + this.y_shift + metrics.y_shift;\n    Glyph.renderOutline(context, outline, scale, xPos, yPos);\n    this.restoreStyle();\n  }\n}\nGlyph.cache = new GlyphCache();\nGlyph.CURRENT_CACHE_KEY = '';\nGlyph.MUSIC_FONT_STACK = [];\nexport { Glyph };","map":{"version":3,"names":["BoundingBox","BoundingBoxComputation","Element","Tables","defined","RuntimeError","GlyphCacheEntry","constructor","fontStack","code","category","point","metrics","Glyph","loadMetrics","bbox","getOutlineBoundingBox","outline","scale","x_shift","y_shift","lookupFontMetric","font","GlyphCache","cache","Map","lookup","entries","get","CURRENT_CACHE_KEY","undefined","set","key","entry","MUSIC_FONT_STACK","GlyphOutline","originX","originY","i","precision","Math","pow","RENDER_PRECISION_PLACES","done","length","next","round","nextX","nextY","parse","str","result","parts","split","push","parseInt","CATEGORY","defaultValue","value","lookupMetric","lookupGlyph","glyph","getGlyphs","o","x_min","x_max","ha","cached_outline","width","height","renderGlyph","ctx","x_pos","y_pos","options","_a","data","customScale","getResolution","renderOutline","go","beginPath","x","y","moveTo","lineTo","quadraticCurveTo","bezierCurveTo","fill","bboxComp","penX","penY","addPoint","addQuadraticCurve","addBezierCurve","getX1","getY1","getWidth","getW","topGlyphs","botGlyphs","originShift","setOptions","reset","draw","getCode","Object","assign","setPoint","setStave","stave","getXShift","setXShift","getYshift","setYShift","getX","getY","getH","checkMetrics","getMetrics","metricsScale","setOriginX","abs","xShift","setOriginY","yShift","setOrigin","render","setRendered","applyStyle","xPos","yPos","restoreStyle","checkStave","renderToStave","context","checkContext","getYForGlyphs"],"sources":["/Users/lang/Documents/code/Song2Notation/frontend/node_modules/vexflow/build/esm/src/glyph.js"],"sourcesContent":["import { BoundingBox } from './boundingbox.js';\nimport { BoundingBoxComputation } from './boundingboxcomputation.js';\nimport { Element } from './element.js';\nimport { Tables } from './tables.js';\nimport { defined, RuntimeError } from './util.js';\nclass GlyphCacheEntry {\n    constructor(fontStack, code, category) {\n        this.point = -1;\n        this.metrics = Glyph.loadMetrics(fontStack, code, category);\n        this.bbox = Glyph.getOutlineBoundingBox(this.metrics.outline, this.metrics.scale, this.metrics.x_shift, this.metrics.y_shift);\n        if (category) {\n            this.point = Glyph.lookupFontMetric(this.metrics.font, category, code, 'point', -1);\n        }\n    }\n}\nclass GlyphCache {\n    constructor() {\n        this.cache = new Map();\n    }\n    lookup(code, category) {\n        let entries = this.cache.get(Glyph.CURRENT_CACHE_KEY);\n        if (entries === undefined) {\n            entries = {};\n            this.cache.set(Glyph.CURRENT_CACHE_KEY, entries);\n        }\n        const key = category ? `${code}%${category}` : code;\n        let entry = entries[key];\n        if (entry === undefined) {\n            entry = new GlyphCacheEntry(Glyph.MUSIC_FONT_STACK, code, category);\n            entries[key] = entry;\n        }\n        return entry;\n    }\n}\nclass GlyphOutline {\n    constructor(outline, originX, originY, scale) {\n        this.outline = outline;\n        this.originX = originX;\n        this.originY = originY;\n        this.scale = scale;\n        this.i = 0;\n        this.precision = 1;\n        this.precision = Math.pow(10, Tables.RENDER_PRECISION_PLACES);\n    }\n    done() {\n        return this.i >= this.outline.length;\n    }\n    next() {\n        return Math.round((this.outline[this.i++] * this.precision) / this.precision);\n    }\n    nextX() {\n        return Math.round((this.originX + this.outline[this.i++] * this.scale) * this.precision) / this.precision;\n    }\n    nextY() {\n        return Math.round((this.originY - this.outline[this.i++] * this.scale) * this.precision) / this.precision;\n    }\n    static parse(str) {\n        const result = [];\n        const parts = str.split(' ');\n        let i = 0;\n        while (i < parts.length) {\n            switch (parts[i++]) {\n                case 'm':\n                    result.push(0, parseInt(parts[i++]), parseInt(parts[i++]));\n                    break;\n                case 'l':\n                    result.push(1, parseInt(parts[i++]), parseInt(parts[i++]));\n                    break;\n                case 'q':\n                    result.push(2, parseInt(parts[i++]), parseInt(parts[i++]), parseInt(parts[i++]), parseInt(parts[i++]));\n                    break;\n                case 'b':\n                    result.push(3, parseInt(parts[i++]), parseInt(parts[i++]), parseInt(parts[i++]), parseInt(parts[i++]), parseInt(parts[i++]), parseInt(parts[i++]));\n                    break;\n            }\n        }\n        return result;\n    }\n}\nclass Glyph extends Element {\n    static get CATEGORY() {\n        return \"Glyph\";\n    }\n    static lookupFontMetric(font, category, code, key, defaultValue) {\n        let value = font.lookupMetric(`glyphs.${category}.${code}.${key}`, undefined);\n        if (value === undefined) {\n            value = font.lookupMetric(`glyphs.${category}.${key}`, defaultValue);\n        }\n        return value;\n    }\n    static lookupGlyph(fontStack, code) {\n        defined(fontStack, 'BadFontStack', 'Font stack is misconfigured');\n        let glyph;\n        let font;\n        for (let i = 0; i < fontStack.length; i++) {\n            font = fontStack[i];\n            glyph = font.getGlyphs()[code];\n            if (glyph)\n                return { glyph, font };\n        }\n        throw new RuntimeError('BadGlyph', `Glyph ${code} does not exist in font.`);\n    }\n    static loadMetrics(fontStack, code, category) {\n        const { glyph, font } = Glyph.lookupGlyph(fontStack, code);\n        if (!glyph.o)\n            throw new RuntimeError('BadGlyph', `Glyph ${code} has no outline defined.`);\n        let x_shift = 0;\n        let y_shift = 0;\n        let scale = 1;\n        if (category && font) {\n            x_shift = Glyph.lookupFontMetric(font, category, code, 'shiftX', 0);\n            y_shift = Glyph.lookupFontMetric(font, category, code, 'shiftY', 0);\n            scale = Glyph.lookupFontMetric(font, category, code, 'scale', 1);\n        }\n        const x_min = glyph.x_min;\n        const x_max = glyph.x_max;\n        const ha = glyph.ha;\n        if (!glyph.cached_outline) {\n            glyph.cached_outline = GlyphOutline.parse(glyph.o);\n        }\n        return {\n            x_min,\n            x_max,\n            x_shift,\n            y_shift,\n            scale,\n            ha,\n            outline: glyph.cached_outline,\n            font,\n            width: x_max - x_min,\n            height: ha,\n        };\n    }\n    static renderGlyph(ctx, x_pos, y_pos, point, code, options) {\n        var _a;\n        const data = Glyph.cache.lookup(code, options === null || options === void 0 ? void 0 : options.category);\n        const metrics = data.metrics;\n        if (data.point != -1) {\n            point = data.point;\n        }\n        const customScale = (_a = options === null || options === void 0 ? void 0 : options.scale) !== null && _a !== void 0 ? _a : 1;\n        const scale = ((point * 72.0) / (metrics.font.getResolution() * 100.0)) * metrics.scale * customScale;\n        Glyph.renderOutline(ctx, metrics.outline, scale, x_pos + metrics.x_shift * customScale, y_pos + metrics.y_shift * customScale);\n        return metrics;\n    }\n    static renderOutline(ctx, outline, scale, x_pos, y_pos) {\n        const go = new GlyphOutline(outline, x_pos, y_pos, scale);\n        ctx.beginPath();\n        let x, y;\n        while (!go.done()) {\n            switch (go.next()) {\n                case 0:\n                    ctx.moveTo(go.nextX(), go.nextY());\n                    break;\n                case 1:\n                    ctx.lineTo(go.nextX(), go.nextY());\n                    break;\n                case 2:\n                    x = go.nextX();\n                    y = go.nextY();\n                    ctx.quadraticCurveTo(go.nextX(), go.nextY(), x, y);\n                    break;\n                case 3:\n                    x = go.nextX();\n                    y = go.nextY();\n                    ctx.bezierCurveTo(go.nextX(), go.nextY(), go.nextX(), go.nextY(), x, y);\n                    break;\n            }\n        }\n        ctx.fill();\n    }\n    static getOutlineBoundingBox(outline, scale, x_pos, y_pos) {\n        const go = new GlyphOutline(outline, x_pos, y_pos, scale);\n        const bboxComp = new BoundingBoxComputation();\n        let penX = x_pos;\n        let penY = y_pos;\n        let x, y;\n        while (!go.done()) {\n            switch (go.next()) {\n                case 0:\n                    penX = go.nextX();\n                    penY = go.nextY();\n                    break;\n                case 1:\n                    bboxComp.addPoint(penX, penY);\n                    penX = go.nextX();\n                    penY = go.nextY();\n                    bboxComp.addPoint(penX, penY);\n                    break;\n                case 2:\n                    x = go.nextX();\n                    y = go.nextY();\n                    bboxComp.addQuadraticCurve(penX, penY, go.nextX(), go.nextY(), x, y);\n                    penX = x;\n                    penY = y;\n                    break;\n                case 3:\n                    x = go.nextX();\n                    y = go.nextY();\n                    bboxComp.addBezierCurve(penX, penY, go.nextX(), go.nextY(), go.nextX(), go.nextY(), x, y);\n                    penX = x;\n                    penY = y;\n                    break;\n            }\n        }\n        return new BoundingBox(bboxComp.getX1(), bboxComp.getY1(), bboxComp.width(), bboxComp.height());\n    }\n    static getWidth(code, point, category) {\n        const data = Glyph.cache.lookup(code, category);\n        if (data.point != -1) {\n            point = data.point;\n        }\n        const scale = (point * 72) / (data.metrics.font.getResolution() * 100);\n        return data.bbox.getW() * scale;\n    }\n    constructor(code, point, options) {\n        super();\n        this.bbox = new BoundingBox(0, 0, 0, 0);\n        this.topGlyphs = [];\n        this.botGlyphs = [];\n        this.options = {};\n        this.scale = 1;\n        this.code = code;\n        this.point = point;\n        this.originShift = { x: 0, y: 0 };\n        this.x_shift = 0;\n        this.y_shift = 0;\n        if (options) {\n            this.setOptions(options);\n        }\n        else {\n            this.reset();\n        }\n    }\n    draw(...args) {\n    }\n    getCode() {\n        return this.code;\n    }\n    setOptions(options) {\n        this.options = Object.assign(Object.assign({}, this.options), options);\n        this.reset();\n    }\n    setPoint(point) {\n        this.point = point;\n        return this;\n    }\n    setStave(stave) {\n        this.stave = stave;\n        return this;\n    }\n    getXShift() {\n        return this.x_shift;\n    }\n    setXShift(x_shift) {\n        this.x_shift = x_shift;\n        return this;\n    }\n    getYshift() {\n        return this.y_shift;\n    }\n    setYShift(y_shift) {\n        this.y_shift = y_shift;\n        return this;\n    }\n    reset() {\n        const data = Glyph.cache.lookup(this.code, this.options.category);\n        this.metrics = data.metrics;\n        if (data.point != -1) {\n            this.point = data.point;\n        }\n        this.scale = (this.point * 72) / (this.metrics.font.getResolution() * 100);\n        this.bbox = new BoundingBox(data.bbox.getX() * this.scale, data.bbox.getY() * this.scale, data.bbox.getW() * this.scale, data.bbox.getH() * this.scale);\n    }\n    checkMetrics() {\n        return defined(this.metrics, 'BadGlyph', `Glyph ${this.code} is not initialized.`);\n    }\n    getMetrics() {\n        const metrics = this.checkMetrics();\n        const metricsScale = metrics.scale;\n        return {\n            x_min: metrics.x_min * this.scale * metricsScale,\n            x_max: metrics.x_max * this.scale * metricsScale,\n            width: this.bbox.getW(),\n            height: this.bbox.getH(),\n            scale: this.scale * metricsScale,\n            x_shift: metrics.x_shift,\n            y_shift: metrics.y_shift,\n            outline: metrics.outline,\n            font: metrics.font,\n            ha: metrics.ha,\n        };\n    }\n    setOriginX(x) {\n        const { bbox } = this;\n        const originX = Math.abs(bbox.getX() / bbox.getW());\n        const xShift = (x - originX) * bbox.getW();\n        this.originShift.x = -xShift;\n    }\n    setOriginY(y) {\n        const { bbox } = this;\n        const originY = Math.abs(bbox.getY() / bbox.getH());\n        const yShift = (y - originY) * bbox.getH();\n        this.originShift.y = -yShift;\n    }\n    setOrigin(x, y) {\n        this.setOriginX(x);\n        this.setOriginY(y);\n    }\n    render(ctx, x, y) {\n        const metrics = this.checkMetrics();\n        const outline = metrics.outline;\n        const scale = this.scale * metrics.scale;\n        this.setRendered();\n        this.applyStyle(ctx);\n        const xPos = x + this.originShift.x + metrics.x_shift;\n        const yPos = y + this.originShift.y + metrics.y_shift;\n        Glyph.renderOutline(ctx, outline, scale, xPos, yPos);\n        this.restoreStyle(ctx);\n    }\n    checkStave() {\n        return defined(this.stave, 'NoStave', 'No stave attached to instance.');\n    }\n    renderToStave(x) {\n        const context = this.checkContext();\n        const metrics = this.checkMetrics();\n        const stave = this.checkStave();\n        const outline = metrics.outline;\n        const scale = this.scale * metrics.scale;\n        this.setRendered();\n        this.applyStyle();\n        const xPos = x + this.x_shift + metrics.x_shift;\n        const yPos = stave.getYForGlyphs() + this.y_shift + metrics.y_shift;\n        Glyph.renderOutline(context, outline, scale, xPos, yPos);\n        this.restoreStyle();\n    }\n}\nGlyph.cache = new GlyphCache();\nGlyph.CURRENT_CACHE_KEY = '';\nGlyph.MUSIC_FONT_STACK = [];\nexport { Glyph };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}