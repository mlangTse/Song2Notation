{"ast":null,"code":"import { BoundingBox } from './boundingbox.js';\nimport { Modifier } from './modifier.js';\nimport { NoteHead } from './notehead.js';\nimport { Stem } from './stem.js';\nimport { StemmableNote } from './stemmablenote.js';\nimport { Tables } from './tables.js';\nimport { defined, log, midLine, RuntimeError } from './util.js';\nfunction showDeprecationWarningForNoteHeads() {\n  console.warn('StaveNote.note_heads is deprecated. Use StaveNote.noteHeads instead.', 'This accessor will be removed in VexFlow 5.0.');\n}\nfunction L() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  if (StaveNote.DEBUG) log('Vex.Flow.StaveNote', args);\n}\nconst isInnerNoteIndex = (note, index) => index === (note.getStemDirection() === Stem.UP ? note.keyProps.length - 1 : 0);\nfunction shiftRestVertical(rest, note, dir) {\n  const delta = dir;\n  rest.line += delta;\n  rest.maxLine += delta;\n  rest.minLine += delta;\n  rest.note.setKeyLine(0, rest.note.getKeyLine(0) + delta);\n}\nfunction centerRest(rest, noteU, noteL) {\n  const delta = rest.line - midLine(noteU.minLine, noteL.maxLine);\n  rest.note.setKeyLine(0, rest.note.getKeyLine(0) - delta);\n  rest.line -= delta;\n  rest.maxLine -= delta;\n  rest.minLine -= delta;\n}\nclass StaveNote extends StemmableNote {\n  static get CATEGORY() {\n    return \"StaveNote\";\n  }\n  static get STEM_UP() {\n    return Stem.UP;\n  }\n  static get STEM_DOWN() {\n    return Stem.DOWN;\n  }\n  static get LEDGER_LINE_OFFSET() {\n    return 3;\n  }\n  static get minNoteheadPadding() {\n    const musicFont = Tables.currentMusicFont();\n    return musicFont.lookupMetric('noteHead.minPadding');\n  }\n  static format(notes, state) {\n    var _a, _b;\n    if (!notes || notes.length < 2) return false;\n    const notesList = [];\n    for (let i = 0; i < notes.length; i++) {\n      const props = notes[i].sortedKeyProps;\n      const line = props[0].keyProps.line;\n      let minL = props[props.length - 1].keyProps.line;\n      const stemDirection = notes[i].getStemDirection();\n      const stemMax = notes[i].getStemLength() / 10;\n      const stemMin = notes[i].getStemMinimumLength() / 10;\n      let maxL;\n      if (notes[i].isRest()) {\n        maxL = line + notes[i].glyphProps.line_above;\n        minL = line - notes[i].glyphProps.line_below;\n      } else {\n        maxL = stemDirection === 1 ? props[props.length - 1].keyProps.line + stemMax : props[props.length - 1].keyProps.line;\n        minL = stemDirection === 1 ? props[0].keyProps.line : props[0].keyProps.line - stemMax;\n      }\n      notesList.push({\n        line: props[0].keyProps.line,\n        maxLine: maxL,\n        minLine: minL,\n        isrest: notes[i].isRest(),\n        stemDirection: stemDirection,\n        stemMax,\n        stemMin,\n        voice_shift: notes[i].getVoiceShiftWidth(),\n        is_displaced: notes[i].isDisplaced(),\n        note: notes[i]\n      });\n    }\n    let voices = 0;\n    let noteU = undefined;\n    let noteM = undefined;\n    let noteL = undefined;\n    const draw = [false, false, false];\n    for (let i = 0; i < notesList.length; i++) {\n      draw[i] = notesList[i].note.render_options.draw == false ? false : true;\n    }\n    if (draw[0] && draw[1] && draw[2]) {\n      voices = 3;\n      noteU = notesList[0];\n      noteM = notesList[1];\n      noteL = notesList[2];\n    } else if (draw[0] && draw[1]) {\n      voices = 2;\n      noteU = notesList[0];\n      noteL = notesList[1];\n    } else if (draw[0] && draw[2]) {\n      voices = 2;\n      noteU = notesList[0];\n      noteL = notesList[2];\n    } else if (draw[1] && draw[2]) {\n      voices = 2;\n      noteU = notesList[1];\n      noteL = notesList[2];\n    } else {\n      return true;\n    }\n    if (voices === 2 && noteU.stemDirection === -1 && noteL.stemDirection === 1) {\n      noteU = notesList[1];\n      noteL = notesList[0];\n    }\n    const voiceXShift = Math.max(noteU.voice_shift, noteL.voice_shift);\n    let xShift = 0;\n    if (voices === 2) {\n      const lineSpacing = noteU.note.hasStem() && noteL.note.hasStem() && noteU.stemDirection === noteL.stemDirection ? 0.0 : 0.5;\n      if (noteL.isrest && noteU.isrest && noteU.note.duration === noteL.note.duration) {\n        noteL.note.render_options.draw = false;\n      } else if (noteU.minLine <= noteL.maxLine + lineSpacing) {\n        if (noteU.isrest) {\n          shiftRestVertical(noteU, noteL, 1);\n        } else if (noteL.isrest) {\n          shiftRestVertical(noteL, noteU, -1);\n        } else {\n          const lineDiff = Math.abs(noteU.line - noteL.line);\n          if (noteU.note.hasStem() && noteL.note.hasStem()) {\n            const noteUHead = Tables.codeNoteHead((_a = noteU.note.sortedKeyProps[0].keyProps.code) !== null && _a !== void 0 ? _a : 'N', noteU.note.duration);\n            const noteLHead = Tables.codeNoteHead((_b = noteL.note.sortedKeyProps[noteL.note.sortedKeyProps.length - 1].keyProps.code) !== null && _b !== void 0 ? _b : 'N', noteL.note.duration);\n            if (!Tables.UNISON || noteUHead !== noteLHead || noteU.note.getModifiers().filter(item => item.getCategory() === \"Dot\" && item.getIndex() === 0).length !== noteL.note.getModifiers().filter(item => item.getCategory() === \"Dot\" && item.getIndex() === 0).length || lineDiff < 1 && lineDiff > 0 || JSON.stringify(noteU.note.getStyle()) !== JSON.stringify(noteL.note.getStyle())) {\n              xShift = voiceXShift + 2;\n              if (noteU.stemDirection === noteL.stemDirection) {\n                noteU.note.setXShift(xShift);\n              } else {\n                noteL.note.setXShift(xShift);\n              }\n            } else if (noteU.note.voice !== noteL.note.voice) {\n              if (noteU.stemDirection === noteL.stemDirection) {\n                if (noteU.line != noteL.line) {\n                  xShift = voiceXShift + 2;\n                  noteU.note.setXShift(xShift);\n                } else {\n                  if (noteL.stemDirection === 1) {\n                    noteL.stemDirection = -1;\n                    noteL.note.setStemDirection(-1);\n                  }\n                }\n              }\n            }\n          } else if (lineDiff < 1) {\n            xShift = voiceXShift + 2;\n            if (noteU.note.duration < noteL.note.duration) {\n              noteU.note.setXShift(xShift);\n            } else {\n              noteL.note.setXShift(xShift);\n            }\n          } else if (noteU.note.hasStem()) {\n            noteU.stemDirection = -noteU.note.getStemDirection();\n            noteU.note.setStemDirection(noteU.stemDirection);\n          } else if (noteL.note.hasStem()) {\n            noteL.stemDirection = -noteL.note.getStemDirection();\n            noteL.note.setStemDirection(noteL.stemDirection);\n          }\n        }\n      }\n      state.right_shift += xShift;\n      return true;\n    }\n    if (!noteM) throw new RuntimeError('InvalidState', 'noteM not defined.');\n    if (noteM.isrest && !noteU.isrest && !noteL.isrest) {\n      if (noteU.minLine <= noteM.maxLine || noteM.minLine <= noteL.maxLine) {\n        const restHeight = noteM.maxLine - noteM.minLine;\n        const space = noteU.minLine - noteL.maxLine;\n        if (restHeight < space) {\n          centerRest(noteM, noteU, noteL);\n        } else {\n          xShift = voiceXShift + 2;\n          noteM.note.setXShift(xShift);\n          if (noteL.note.hasBeam() === false) {\n            noteL.stemDirection = -1;\n            noteL.note.setStemDirection(-1);\n          }\n          if (noteU.minLine <= noteL.maxLine && noteU.note.hasBeam() === false) {\n            noteU.stemDirection = 1;\n            noteU.note.setStemDirection(1);\n          }\n        }\n        state.right_shift += xShift;\n        return true;\n      }\n    }\n    if (noteU.isrest && noteM.isrest && noteL.isrest) {\n      noteU.note.render_options.draw = false;\n      noteL.note.render_options.draw = false;\n      state.right_shift += xShift;\n      return true;\n    }\n    if (noteM.isrest && noteU.isrest && noteM.minLine <= noteL.maxLine) {\n      noteM.note.render_options.draw = false;\n    }\n    if (noteM.isrest && noteL.isrest && noteU.minLine <= noteM.maxLine) {\n      noteM.note.render_options.draw = false;\n    }\n    if (noteU.isrest && noteU.minLine <= noteM.maxLine) {\n      shiftRestVertical(noteU, noteM, 1);\n    }\n    if (noteL.isrest && noteM.minLine <= noteL.maxLine) {\n      shiftRestVertical(noteL, noteM, -1);\n    }\n    if (noteU.minLine <= noteM.maxLine + 0.5 || noteM.minLine <= noteL.maxLine) {\n      xShift = voiceXShift + 2;\n      noteM.note.setXShift(xShift);\n      if (noteL.note.hasBeam() === false) {\n        noteL.stemDirection = -1;\n        noteL.note.setStemDirection(-1);\n      }\n      if (noteU.minLine <= noteL.maxLine && noteU.note.hasBeam() === false) {\n        noteU.stemDirection = 1;\n        noteU.note.setStemDirection(1);\n      }\n    }\n    state.right_shift += xShift;\n    return true;\n  }\n  static postFormat(notes) {\n    if (!notes) return false;\n    notes.forEach(note => note.postFormat());\n    return true;\n  }\n  constructor(noteStruct) {\n    var _a, _b, _c;\n    super(noteStruct);\n    this.minLine = 0;\n    this.maxLine = 0;\n    this.sortedKeyProps = [];\n    this.ledgerLineStyle = {};\n    this.clef = (_a = noteStruct.clef) !== null && _a !== void 0 ? _a : 'treble';\n    this.octave_shift = (_b = noteStruct.octave_shift) !== null && _b !== void 0 ? _b : 0;\n    this.glyphProps = Tables.getGlyphProps(this.duration, this.noteType);\n    defined(this.glyphProps, 'BadArguments', `No glyph found for duration '${this.duration}' and type '${this.noteType}'`);\n    this.displaced = false;\n    this.dot_shiftY = 0;\n    this.use_default_head_x = false;\n    this._noteHeads = [];\n    this.modifiers = [];\n    this.render_options = Object.assign(Object.assign({}, this.render_options), {\n      glyph_font_scale: noteStruct.glyph_font_scale || Tables.NOTATION_FONT_SCALE,\n      stroke_px: noteStruct.stroke_px || StaveNote.LEDGER_LINE_OFFSET\n    });\n    this.calculateKeyProps();\n    this.buildStem();\n    if (noteStruct.auto_stem) {\n      this.autoStem();\n    } else {\n      this.setStemDirection((_c = noteStruct.stem_direction) !== null && _c !== void 0 ? _c : Stem.UP);\n    }\n    this.reset();\n    this.buildFlag();\n  }\n  reset() {\n    super.reset();\n    const noteHeadStyles = this._noteHeads.map(noteHead => noteHead.getStyle());\n    this.buildNoteHeads();\n    this._noteHeads.forEach((noteHead, index) => {\n      const noteHeadStyle = noteHeadStyles[index];\n      if (noteHeadStyle) noteHead.setStyle(noteHeadStyle);\n    });\n    const stave = this.stave;\n    if (stave) {\n      this.setStave(stave);\n    }\n    this.calcNoteDisplacements();\n    return this;\n  }\n  setBeam(beam) {\n    this.beam = beam;\n    this.calcNoteDisplacements();\n    if (this.stem) {\n      this.stem.setExtension(this.getStemExtension());\n    }\n    return this;\n  }\n  buildStem() {\n    this.setStem(new Stem({\n      hide: !!this.isRest()\n    }));\n    return this;\n  }\n  buildNoteHeads() {\n    this._noteHeads = [];\n    const stemDirection = this.getStemDirection();\n    const keys = this.getKeys();\n    let lastLine = undefined;\n    let lineDiff = undefined;\n    let displaced = false;\n    let start;\n    let end;\n    let step;\n    if (stemDirection === Stem.UP) {\n      start = 0;\n      end = keys.length;\n      step = 1;\n    } else {\n      start = keys.length - 1;\n      end = -1;\n      step = -1;\n    }\n    for (let i = start; i !== end; i += step) {\n      const noteProps = this.sortedKeyProps[i].keyProps;\n      const line = noteProps.line;\n      if (lastLine === undefined) {\n        lastLine = line;\n      } else {\n        lineDiff = Math.abs(lastLine - line);\n        if (lineDiff === 0 || lineDiff === 0.5) {\n          displaced = !displaced;\n        } else {\n          displaced = false;\n          this.use_default_head_x = true;\n        }\n      }\n      lastLine = line;\n      const notehead = new NoteHead({\n        duration: this.duration,\n        note_type: this.noteType,\n        displaced,\n        stem_direction: stemDirection,\n        custom_glyph_code: noteProps.code,\n        glyph_font_scale: this.render_options.glyph_font_scale,\n        x_shift: noteProps.shift_right,\n        stem_up_x_offset: noteProps.stem_up_x_offset,\n        stem_down_x_offset: noteProps.stem_down_x_offset,\n        line: noteProps.line\n      });\n      this.addChildElement(notehead);\n      this._noteHeads[this.sortedKeyProps[i].index] = notehead;\n    }\n    return this._noteHeads;\n  }\n  autoStem() {\n    this.setStemDirection(this.calculateOptimalStemDirection());\n  }\n  calculateOptimalStemDirection() {\n    this.minLine = this.sortedKeyProps[0].keyProps.line;\n    this.maxLine = this.sortedKeyProps[this.keyProps.length - 1].keyProps.line;\n    const MIDDLE_LINE = 3;\n    const decider = (this.minLine + this.maxLine) / 2;\n    const stemDirection = decider < MIDDLE_LINE ? Stem.UP : Stem.DOWN;\n    return stemDirection;\n  }\n  calculateKeyProps() {\n    let lastLine;\n    for (let i = 0; i < this.keys.length; ++i) {\n      const key = this.keys[i];\n      if (this.glyphProps.rest) this.glyphProps.position = key;\n      const options = {\n        octave_shift: this.octave_shift || 0,\n        duration: this.duration\n      };\n      const props = Tables.keyProperties(key, this.clef, options);\n      if (!props) {\n        throw new RuntimeError('BadArguments', `Invalid key for note properties: ${key}`);\n      }\n      if (props.key === 'R') {\n        if (this.duration === '1' || this.duration === 'w') {\n          props.line = 4;\n        } else {\n          props.line = 3;\n        }\n      }\n      const line = props.line;\n      if (lastLine == undefined) {\n        lastLine = line;\n      } else {\n        if (Math.abs(lastLine - line) === 0.5) {\n          this.displaced = true;\n          props.displaced = true;\n          if (this.keyProps.length > 0) {\n            this.keyProps[i - 1].displaced = true;\n          }\n        }\n      }\n      lastLine = line;\n      this.keyProps.push(props);\n    }\n    this.keyProps.forEach((keyProps, index) => {\n      this.sortedKeyProps.push({\n        keyProps,\n        index\n      });\n    });\n    this.sortedKeyProps.sort((a, b) => a.keyProps.line - b.keyProps.line);\n  }\n  getBoundingBox() {\n    var _a, _b;\n    if (!this.preFormatted) {\n      throw new RuntimeError('UnformattedNote', \"Can't call getBoundingBox on an unformatted note.\");\n    }\n    const {\n      width: w,\n      modLeftPx,\n      leftDisplacedHeadPx\n    } = this.getMetrics();\n    const x = this.getAbsoluteX() - modLeftPx - leftDisplacedHeadPx;\n    let minY = 0;\n    let maxY = 0;\n    const halfLineSpacing = ((_b = (_a = this.getStave()) === null || _a === void 0 ? void 0 : _a.getSpacingBetweenLines()) !== null && _b !== void 0 ? _b : 0) / 2;\n    const lineSpacing = halfLineSpacing * 2;\n    if (this.isRest()) {\n      const y = this.ys[0];\n      const frac = Tables.durationToFraction(this.duration);\n      if (frac.equals(1) || frac.equals(2)) {\n        minY = y - halfLineSpacing;\n        maxY = y + halfLineSpacing;\n      } else {\n        minY = y - this.glyphProps.line_above * lineSpacing;\n        maxY = y + this.glyphProps.line_below * lineSpacing;\n      }\n    } else if (this.glyphProps.stem) {\n      const ys = this.getStemExtents();\n      ys.baseY += halfLineSpacing * this.getStemDirection();\n      minY = Math.min(ys.topY, ys.baseY);\n      maxY = Math.max(ys.topY, ys.baseY);\n    } else {\n      minY = 0;\n      maxY = 0;\n      for (let i = 0; i < this.ys.length; ++i) {\n        const yy = this.ys[i];\n        if (i === 0) {\n          minY = yy;\n          maxY = yy;\n        } else {\n          minY = Math.min(yy, minY);\n          maxY = Math.max(yy, maxY);\n        }\n      }\n      minY -= halfLineSpacing;\n      maxY += halfLineSpacing;\n    }\n    return new BoundingBox(x, minY, w, maxY - minY);\n  }\n  getLineNumber(isTopNote) {\n    if (!this.keyProps.length) {\n      throw new RuntimeError('NoKeyProps', \"Can't get bottom note line, because note is not initialized properly.\");\n    }\n    let resultLine = this.keyProps[0].line;\n    for (let i = 0; i < this.keyProps.length; i++) {\n      const thisLine = this.keyProps[i].line;\n      if (isTopNote) {\n        if (thisLine > resultLine) resultLine = thisLine;\n      } else {\n        if (thisLine < resultLine) resultLine = thisLine;\n      }\n    }\n    return resultLine;\n  }\n  isRest() {\n    return this.glyphProps.rest;\n  }\n  isChord() {\n    return !this.isRest() && this.keys.length > 1;\n  }\n  hasStem() {\n    return this.glyphProps.stem;\n  }\n  hasFlag() {\n    return super.hasFlag() && !this.isRest();\n  }\n  getStemX() {\n    if (this.noteType === 'r') {\n      return this.getCenterGlyphX();\n    } else {\n      return super.getStemX() + (this.stem_direction ? Stem.WIDTH / (2 * -this.stem_direction) : 0);\n    }\n  }\n  getYForTopText(textLine) {\n    const extents = this.getStemExtents();\n    return Math.min(this.checkStave().getYForTopText(textLine), extents.topY - this.render_options.annotation_spacing * (textLine + 1));\n  }\n  getYForBottomText(textLine) {\n    const extents = this.getStemExtents();\n    return Math.max(this.checkStave().getYForTopText(textLine), extents.baseY + this.render_options.annotation_spacing * textLine);\n  }\n  setStave(stave) {\n    super.setStave(stave);\n    const ys = this._noteHeads.map(notehead => {\n      notehead.setStave(stave);\n      return notehead.getY();\n    });\n    this.setYs(ys);\n    if (this.stem) {\n      const {\n        y_top,\n        y_bottom\n      } = this.getNoteHeadBounds();\n      this.stem.setYBounds(y_top, y_bottom);\n    }\n    return this;\n  }\n  isDisplaced() {\n    return this.displaced;\n  }\n  setNoteDisplaced(displaced) {\n    this.displaced = displaced;\n    return this;\n  }\n  getTieRightX() {\n    let tieStartX = this.getAbsoluteX();\n    tieStartX += this.getGlyphWidth() + this.x_shift + this.rightDisplacedHeadPx;\n    if (this.modifierContext) tieStartX += this.modifierContext.getRightShift();\n    return tieStartX;\n  }\n  getTieLeftX() {\n    let tieEndX = this.getAbsoluteX();\n    tieEndX += this.x_shift - this.leftDisplacedHeadPx;\n    return tieEndX;\n  }\n  getLineForRest() {\n    let restLine = this.keyProps[0].line;\n    if (this.keyProps.length > 1) {\n      const lastLine = this.keyProps[this.keyProps.length - 1].line;\n      const top = Math.max(restLine, lastLine);\n      const bot = Math.min(restLine, lastLine);\n      restLine = midLine(top, bot);\n    }\n    return restLine;\n  }\n  getModifierStartXY(position, index) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _a, _b;\n    if (!this.preFormatted) {\n      throw new RuntimeError('UnformattedNote', \"Can't call GetModifierStartXY on an unformatted note\");\n    }\n    if (this.ys.length === 0) {\n      throw new RuntimeError('NoYValues', 'No Y-Values calculated for this note.');\n    }\n    const {\n      ABOVE,\n      BELOW,\n      LEFT,\n      RIGHT\n    } = Modifier.Position;\n    let x = 0;\n    if (position === LEFT) {\n      x = -1 * 2;\n    } else if (position === RIGHT) {\n      x = this.getGlyphWidth() + this.x_shift + 2;\n      if (this.stem_direction === Stem.UP && this.hasFlag() && (options.forceFlagRight || isInnerNoteIndex(this, index))) {\n        x += (_b = (_a = this === null || this === void 0 ? void 0 : this.flag) === null || _a === void 0 ? void 0 : _a.getMetrics().width) !== null && _b !== void 0 ? _b : 0;\n      }\n    } else if (position === BELOW || position === ABOVE) {\n      x = this.getGlyphWidth() / 2;\n    }\n    return {\n      x: this.getAbsoluteX() + x,\n      y: this.ys[index]\n    };\n  }\n  setStyle(style) {\n    return super.setGroupStyle(style);\n  }\n  setStemStyle(style) {\n    const stem = this.getStem();\n    if (stem) stem.setStyle(style);\n    return this;\n  }\n  getStemStyle() {\n    var _a;\n    return (_a = this.stem) === null || _a === void 0 ? void 0 : _a.getStyle();\n  }\n  setLedgerLineStyle(style) {\n    this.ledgerLineStyle = style;\n  }\n  getLedgerLineStyle() {\n    return this.ledgerLineStyle;\n  }\n  setFlagStyle(style) {\n    var _a;\n    (_a = this.flag) === null || _a === void 0 ? void 0 : _a.setStyle(style);\n  }\n  getFlagStyle() {\n    var _a;\n    return (_a = this.flag) === null || _a === void 0 ? void 0 : _a.getStyle();\n  }\n  setKeyStyle(index, style) {\n    this._noteHeads[index].setStyle(style);\n    return this;\n  }\n  setKeyLine(index, line) {\n    this.keyProps[index].line = line;\n    this.reset();\n    return this;\n  }\n  getKeyLine(index) {\n    return this.keyProps[index].line;\n  }\n  getVoiceShiftWidth() {\n    return this.getGlyphWidth() * (this.displaced ? 2 : 1);\n  }\n  calcNoteDisplacements() {\n    this.setLeftDisplacedHeadPx(this.displaced && this.stem_direction === Stem.DOWN ? this.getGlyphWidth() : 0);\n    this.setRightDisplacedHeadPx(!this.hasFlag() && this.displaced && this.stem_direction === Stem.UP ? this.getGlyphWidth() : 0);\n  }\n  preFormat() {\n    if (this.preFormatted) return;\n    let noteHeadPadding = 0;\n    if (this.modifierContext) {\n      this.modifierContext.preFormat();\n      if (this.modifierContext.getWidth() === 0) {\n        noteHeadPadding = StaveNote.minNoteheadPadding;\n      }\n    }\n    let width = this.getGlyphWidth() + this.leftDisplacedHeadPx + this.rightDisplacedHeadPx + noteHeadPadding;\n    if (this.shouldDrawFlag() && this.stem_direction === Stem.UP) {\n      width += this.getGlyphWidth();\n    }\n    this.setWidth(width);\n    this.preFormatted = true;\n  }\n  getNoteHeadBounds() {\n    let yTop = +Infinity;\n    let yBottom = -Infinity;\n    let nonDisplacedX;\n    let displacedX;\n    let highestLine = this.checkStave().getNumLines();\n    let lowestLine = 1;\n    let highestDisplacedLine;\n    let lowestDisplacedLine;\n    let highestNonDisplacedLine = highestLine;\n    let lowestNonDisplacedLine = lowestLine;\n    this._noteHeads.forEach(notehead => {\n      const line = notehead.getLine();\n      const y = notehead.getY();\n      yTop = Math.min(y, yTop);\n      yBottom = Math.max(y, yBottom);\n      if (displacedX === undefined && notehead.isDisplaced()) {\n        displacedX = notehead.getAbsoluteX();\n      }\n      if (nonDisplacedX === undefined && !notehead.isDisplaced()) {\n        nonDisplacedX = notehead.getAbsoluteX();\n      }\n      highestLine = Math.max(line, highestLine);\n      lowestLine = Math.min(line, lowestLine);\n      if (notehead.isDisplaced()) {\n        highestDisplacedLine = highestDisplacedLine === undefined ? line : Math.max(line, highestDisplacedLine);\n        lowestDisplacedLine = lowestDisplacedLine === undefined ? line : Math.min(line, lowestDisplacedLine);\n      } else {\n        highestNonDisplacedLine = Math.max(line, highestNonDisplacedLine);\n        lowestNonDisplacedLine = Math.min(line, lowestNonDisplacedLine);\n      }\n    }, this);\n    return {\n      y_top: yTop,\n      y_bottom: yBottom,\n      displaced_x: displacedX,\n      non_displaced_x: nonDisplacedX,\n      highest_line: highestLine,\n      lowest_line: lowestLine,\n      highest_displaced_line: highestDisplacedLine,\n      lowest_displaced_line: lowestDisplacedLine,\n      highest_non_displaced_line: highestNonDisplacedLine,\n      lowest_non_displaced_line: lowestNonDisplacedLine\n    };\n  }\n  getNoteHeadBeginX() {\n    return this.getAbsoluteX() + this.x_shift;\n  }\n  getNoteHeadEndX() {\n    const xBegin = this.getNoteHeadBeginX();\n    return xBegin + this.getGlyphWidth();\n  }\n  get noteHeads() {\n    return this._noteHeads.slice();\n  }\n  get note_heads() {\n    showDeprecationWarningForNoteHeads();\n    return this.noteHeads;\n  }\n  drawLedgerLines() {\n    const stave = this.checkStave();\n    const {\n      glyphProps,\n      render_options: {\n        stroke_px\n      }\n    } = this;\n    const ctx = this.checkContext();\n    const width = glyphProps.getWidth() + stroke_px * 2;\n    const doubleWidth = 2 * (glyphProps.getWidth() + stroke_px) - Stem.WIDTH / 2;\n    if (this.isRest()) return;\n    if (!ctx) {\n      throw new RuntimeError('NoCanvasContext', \"Can't draw without a canvas context.\");\n    }\n    const {\n      highest_line,\n      lowest_line,\n      highest_displaced_line,\n      highest_non_displaced_line,\n      lowest_displaced_line,\n      lowest_non_displaced_line,\n      displaced_x,\n      non_displaced_x\n    } = this.getNoteHeadBounds();\n    if (highest_line < 6 && lowest_line > 0) return;\n    const min_x = Math.min(displaced_x !== null && displaced_x !== void 0 ? displaced_x : 0, non_displaced_x !== null && non_displaced_x !== void 0 ? non_displaced_x : 0);\n    const drawLedgerLine = (y, normal, displaced) => {\n      let x;\n      if (displaced && normal) x = min_x - stroke_px;else if (normal) x = (non_displaced_x !== null && non_displaced_x !== void 0 ? non_displaced_x : 0) - stroke_px;else x = (displaced_x !== null && displaced_x !== void 0 ? displaced_x : 0) - stroke_px;\n      const ledgerWidth = normal && displaced ? doubleWidth : width;\n      ctx.beginPath();\n      ctx.moveTo(x, y);\n      ctx.lineTo(x + ledgerWidth, y);\n      ctx.stroke();\n    };\n    const style = Object.assign(Object.assign({}, stave.getDefaultLedgerLineStyle()), this.getLedgerLineStyle());\n    this.applyStyle(ctx, style);\n    for (let line = 6; line <= highest_line; ++line) {\n      const normal = non_displaced_x !== undefined && line <= highest_non_displaced_line;\n      const displaced = highest_displaced_line !== undefined && line <= highest_displaced_line;\n      drawLedgerLine(stave.getYForNote(line), normal, displaced);\n    }\n    for (let line = 0; line >= lowest_line; --line) {\n      const normal = non_displaced_x !== undefined && line >= lowest_non_displaced_line;\n      const displaced = lowest_displaced_line !== undefined && line >= lowest_displaced_line;\n      drawLedgerLine(stave.getYForNote(line), normal, displaced);\n    }\n    this.restoreStyle(ctx, style);\n  }\n  drawModifiers(noteheadParam) {\n    const ctx = this.checkContext();\n    for (let i = 0; i < this.modifiers.length; i++) {\n      const modifier = this.modifiers[i];\n      const index = modifier.checkIndex();\n      const notehead = this._noteHeads[index];\n      if (notehead == noteheadParam) {\n        const noteheadStyle = notehead.getStyle();\n        notehead.applyStyle(ctx, noteheadStyle);\n        modifier.setContext(ctx);\n        modifier.drawWithStyle();\n        notehead.restoreStyle(ctx, noteheadStyle);\n      }\n    }\n  }\n  shouldDrawFlag() {\n    const hasStem = this.stem !== undefined;\n    const hasFlag = this.glyphProps.flag == true;\n    const hasNoBeam = this.beam === undefined;\n    return hasStem && hasFlag && hasNoBeam;\n  }\n  drawFlag() {\n    var _a, _b, _c, _d, _e;\n    const ctx = this.checkContext();\n    if (!ctx) {\n      throw new RuntimeError('NoCanvasContext', \"Can't draw without a canvas context.\");\n    }\n    if (this.shouldDrawFlag()) {\n      const {\n        y_top,\n        y_bottom\n      } = this.getNoteHeadBounds();\n      const noteStemHeight = this.stem.getHeight();\n      const flagX = this.getStemX();\n      const flagY = this.getStemDirection() === Stem.DOWN ? y_top - noteStemHeight + 2 - (this.glyphProps ? this.glyphProps.stem_down_extension : 0) * this.getStaveNoteScale() - ((_b = (_a = this.flag) === null || _a === void 0 ? void 0 : _a.getMetrics().y_shift) !== null && _b !== void 0 ? _b : 0) * (1 - this.getStaveNoteScale()) : y_bottom - noteStemHeight - 2 + (this.glyphProps ? this.glyphProps.stem_up_extension : 0) * this.getStaveNoteScale() - ((_d = (_c = this.flag) === null || _c === void 0 ? void 0 : _c.getMetrics().y_shift) !== null && _d !== void 0 ? _d : 0) * (1 - this.getStaveNoteScale());\n      (_e = this.flag) === null || _e === void 0 ? void 0 : _e.render(ctx, flagX, flagY);\n    }\n  }\n  drawNoteHeads() {\n    const ctx = this.checkContext();\n    this._noteHeads.forEach(notehead => {\n      notehead.applyStyle(ctx);\n      ctx.openGroup('notehead', notehead.getAttribute('id'), {\n        pointerBBox: true\n      });\n      notehead.setContext(ctx).draw();\n      this.drawModifiers(notehead);\n      ctx.closeGroup();\n      notehead.restoreStyle(ctx);\n    });\n  }\n  drawStem(stemOptions) {\n    const ctx = this.checkContext();\n    if (stemOptions) {\n      this.setStem(new Stem(stemOptions));\n    }\n    if (this.shouldDrawFlag() && this.stem) {\n      this.stem.adjustHeightForFlag();\n    }\n    if (this.stem) {\n      this.stem.setContext(ctx).draw();\n    }\n  }\n  getStaveNoteScale() {\n    return 1.0;\n  }\n  getStemExtension() {\n    const super_stem_extension = super.getStemExtension();\n    if (!this.glyphProps.stem) {\n      return super_stem_extension;\n    }\n    const stem_direction = this.getStemDirection();\n    if (stem_direction !== this.calculateOptimalStemDirection()) {\n      return super_stem_extension;\n    }\n    let mid_line_distance;\n    const MIDDLE_LINE = 3;\n    if (stem_direction === Stem.UP) {\n      mid_line_distance = MIDDLE_LINE - this.maxLine;\n    } else {\n      mid_line_distance = this.minLine - MIDDLE_LINE;\n    }\n    const lines_over_octave_from_mid_line = mid_line_distance - 3.5;\n    if (lines_over_octave_from_mid_line <= 0) {\n      return super_stem_extension;\n    }\n    const stave = this.getStave();\n    let spacing_between_lines = 10;\n    if (stave != undefined) {\n      spacing_between_lines = stave.getSpacingBetweenLines();\n    }\n    return super_stem_extension + lines_over_octave_from_mid_line * spacing_between_lines;\n  }\n  draw() {\n    if (this.render_options.draw === false) return;\n    if (this.ys.length === 0) {\n      throw new RuntimeError('NoYValues', \"Can't draw note without Y values.\");\n    }\n    const ctx = this.checkContext();\n    const xBegin = this.getNoteHeadBeginX();\n    const shouldRenderStem = this.hasStem() && !this.beam;\n    this._noteHeads.forEach(notehead => notehead.setX(xBegin));\n    if (this.stem) {\n      const stemX = this.getStemX();\n      this.stem.setNoteHeadXBounds(stemX, stemX);\n    }\n    L('Rendering ', this.isChord() ? 'chord :' : 'note :', this.keys);\n    this.applyStyle();\n    ctx.openGroup('stavenote', this.getAttribute('id'));\n    this.drawLedgerLines();\n    if (shouldRenderStem) this.drawStem();\n    this.drawNoteHeads();\n    this.drawFlag();\n    ctx.closeGroup();\n    this.restoreStyle();\n    this.setRendered();\n  }\n}\nStaveNote.DEBUG = false;\nexport { StaveNote };","map":{"version":3,"names":["BoundingBox","Modifier","NoteHead","Stem","StemmableNote","Tables","defined","log","midLine","RuntimeError","showDeprecationWarningForNoteHeads","console","warn","L","_len","arguments","length","args","Array","_key","StaveNote","DEBUG","isInnerNoteIndex","note","index","getStemDirection","UP","keyProps","shiftRestVertical","rest","dir","delta","line","maxLine","minLine","setKeyLine","getKeyLine","centerRest","noteU","noteL","CATEGORY","STEM_UP","STEM_DOWN","DOWN","LEDGER_LINE_OFFSET","minNoteheadPadding","musicFont","currentMusicFont","lookupMetric","format","notes","state","_a","_b","notesList","i","props","sortedKeyProps","minL","stemDirection","stemMax","getStemLength","stemMin","getStemMinimumLength","maxL","isRest","glyphProps","line_above","line_below","push","isrest","voice_shift","getVoiceShiftWidth","is_displaced","isDisplaced","voices","undefined","noteM","draw","render_options","voiceXShift","Math","max","xShift","lineSpacing","hasStem","duration","lineDiff","abs","noteUHead","codeNoteHead","code","noteLHead","UNISON","getModifiers","filter","item","getCategory","getIndex","JSON","stringify","getStyle","setXShift","voice","setStemDirection","right_shift","restHeight","space","hasBeam","postFormat","forEach","constructor","noteStruct","_c","ledgerLineStyle","clef","octave_shift","getGlyphProps","noteType","displaced","dot_shiftY","use_default_head_x","_noteHeads","modifiers","Object","assign","glyph_font_scale","NOTATION_FONT_SCALE","stroke_px","calculateKeyProps","buildStem","auto_stem","autoStem","stem_direction","reset","buildFlag","noteHeadStyles","map","noteHead","buildNoteHeads","noteHeadStyle","setStyle","stave","setStave","calcNoteDisplacements","setBeam","beam","stem","setExtension","getStemExtension","setStem","hide","keys","getKeys","lastLine","start","end","step","noteProps","notehead","note_type","custom_glyph_code","x_shift","shift_right","stem_up_x_offset","stem_down_x_offset","addChildElement","calculateOptimalStemDirection","MIDDLE_LINE","decider","key","position","options","keyProperties","sort","a","b","getBoundingBox","preFormatted","width","w","modLeftPx","leftDisplacedHeadPx","getMetrics","x","getAbsoluteX","minY","maxY","halfLineSpacing","getStave","getSpacingBetweenLines","y","ys","frac","durationToFraction","equals","getStemExtents","baseY","min","topY","yy","getLineNumber","isTopNote","resultLine","thisLine","isChord","hasFlag","getStemX","getCenterGlyphX","WIDTH","getYForTopText","textLine","extents","checkStave","annotation_spacing","getYForBottomText","getY","setYs","y_top","y_bottom","getNoteHeadBounds","setYBounds","setNoteDisplaced","getTieRightX","tieStartX","getGlyphWidth","rightDisplacedHeadPx","modifierContext","getRightShift","getTieLeftX","tieEndX","getLineForRest","restLine","top","bot","getModifierStartXY","ABOVE","BELOW","LEFT","RIGHT","Position","forceFlagRight","flag","style","setGroupStyle","setStemStyle","getStem","getStemStyle","setLedgerLineStyle","getLedgerLineStyle","setFlagStyle","getFlagStyle","setKeyStyle","setLeftDisplacedHeadPx","setRightDisplacedHeadPx","preFormat","noteHeadPadding","getWidth","shouldDrawFlag","setWidth","yTop","Infinity","yBottom","nonDisplacedX","displacedX","highestLine","getNumLines","lowestLine","highestDisplacedLine","lowestDisplacedLine","highestNonDisplacedLine","lowestNonDisplacedLine","getLine","displaced_x","non_displaced_x","highest_line","lowest_line","highest_displaced_line","lowest_displaced_line","highest_non_displaced_line","lowest_non_displaced_line","getNoteHeadBeginX","getNoteHeadEndX","xBegin","noteHeads","slice","note_heads","drawLedgerLines","ctx","checkContext","doubleWidth","min_x","drawLedgerLine","normal","ledgerWidth","beginPath","moveTo","lineTo","stroke","getDefaultLedgerLineStyle","applyStyle","getYForNote","restoreStyle","drawModifiers","noteheadParam","modifier","checkIndex","noteheadStyle","setContext","drawWithStyle","hasNoBeam","drawFlag","_d","_e","noteStemHeight","getHeight","flagX","flagY","stem_down_extension","getStaveNoteScale","y_shift","stem_up_extension","render","drawNoteHeads","openGroup","getAttribute","pointerBBox","closeGroup","drawStem","stemOptions","adjustHeightForFlag","super_stem_extension","mid_line_distance","lines_over_octave_from_mid_line","spacing_between_lines","shouldRenderStem","setX","stemX","setNoteHeadXBounds","setRendered"],"sources":["/Users/lang/Documents/code/Song2Notation/frontend/node_modules/vexflow/build/esm/src/stavenote.js"],"sourcesContent":["import { BoundingBox } from './boundingbox.js';\nimport { Modifier } from './modifier.js';\nimport { NoteHead } from './notehead.js';\nimport { Stem } from './stem.js';\nimport { StemmableNote } from './stemmablenote.js';\nimport { Tables } from './tables.js';\nimport { defined, log, midLine, RuntimeError } from './util.js';\nfunction showDeprecationWarningForNoteHeads() {\n    console.warn('StaveNote.note_heads is deprecated. Use StaveNote.noteHeads instead.', 'This accessor will be removed in VexFlow 5.0.');\n}\nfunction L(...args) {\n    if (StaveNote.DEBUG)\n        log('Vex.Flow.StaveNote', args);\n}\nconst isInnerNoteIndex = (note, index) => index === (note.getStemDirection() === Stem.UP ? note.keyProps.length - 1 : 0);\nfunction shiftRestVertical(rest, note, dir) {\n    const delta = dir;\n    rest.line += delta;\n    rest.maxLine += delta;\n    rest.minLine += delta;\n    rest.note.setKeyLine(0, rest.note.getKeyLine(0) + delta);\n}\nfunction centerRest(rest, noteU, noteL) {\n    const delta = rest.line - midLine(noteU.minLine, noteL.maxLine);\n    rest.note.setKeyLine(0, rest.note.getKeyLine(0) - delta);\n    rest.line -= delta;\n    rest.maxLine -= delta;\n    rest.minLine -= delta;\n}\nclass StaveNote extends StemmableNote {\n    static get CATEGORY() {\n        return \"StaveNote\";\n    }\n    static get STEM_UP() {\n        return Stem.UP;\n    }\n    static get STEM_DOWN() {\n        return Stem.DOWN;\n    }\n    static get LEDGER_LINE_OFFSET() {\n        return 3;\n    }\n    static get minNoteheadPadding() {\n        const musicFont = Tables.currentMusicFont();\n        return musicFont.lookupMetric('noteHead.minPadding');\n    }\n    static format(notes, state) {\n        var _a, _b;\n        if (!notes || notes.length < 2)\n            return false;\n        const notesList = [];\n        for (let i = 0; i < notes.length; i++) {\n            const props = notes[i].sortedKeyProps;\n            const line = props[0].keyProps.line;\n            let minL = props[props.length - 1].keyProps.line;\n            const stemDirection = notes[i].getStemDirection();\n            const stemMax = notes[i].getStemLength() / 10;\n            const stemMin = notes[i].getStemMinimumLength() / 10;\n            let maxL;\n            if (notes[i].isRest()) {\n                maxL = line + notes[i].glyphProps.line_above;\n                minL = line - notes[i].glyphProps.line_below;\n            }\n            else {\n                maxL =\n                    stemDirection === 1 ? props[props.length - 1].keyProps.line + stemMax : props[props.length - 1].keyProps.line;\n                minL = stemDirection === 1 ? props[0].keyProps.line : props[0].keyProps.line - stemMax;\n            }\n            notesList.push({\n                line: props[0].keyProps.line,\n                maxLine: maxL,\n                minLine: minL,\n                isrest: notes[i].isRest(),\n                stemDirection: stemDirection,\n                stemMax,\n                stemMin,\n                voice_shift: notes[i].getVoiceShiftWidth(),\n                is_displaced: notes[i].isDisplaced(),\n                note: notes[i],\n            });\n        }\n        let voices = 0;\n        let noteU = undefined;\n        let noteM = undefined;\n        let noteL = undefined;\n        const draw = [false, false, false];\n        for (let i = 0; i < notesList.length; i++) {\n            draw[i] = notesList[i].note.render_options.draw == false ? false : true;\n        }\n        if (draw[0] && draw[1] && draw[2]) {\n            voices = 3;\n            noteU = notesList[0];\n            noteM = notesList[1];\n            noteL = notesList[2];\n        }\n        else if (draw[0] && draw[1]) {\n            voices = 2;\n            noteU = notesList[0];\n            noteL = notesList[1];\n        }\n        else if (draw[0] && draw[2]) {\n            voices = 2;\n            noteU = notesList[0];\n            noteL = notesList[2];\n        }\n        else if (draw[1] && draw[2]) {\n            voices = 2;\n            noteU = notesList[1];\n            noteL = notesList[2];\n        }\n        else {\n            return true;\n        }\n        if (voices === 2 && noteU.stemDirection === -1 && noteL.stemDirection === 1) {\n            noteU = notesList[1];\n            noteL = notesList[0];\n        }\n        const voiceXShift = Math.max(noteU.voice_shift, noteL.voice_shift);\n        let xShift = 0;\n        if (voices === 2) {\n            const lineSpacing = noteU.note.hasStem() && noteL.note.hasStem() && noteU.stemDirection === noteL.stemDirection ? 0.0 : 0.5;\n            if (noteL.isrest && noteU.isrest && noteU.note.duration === noteL.note.duration) {\n                noteL.note.render_options.draw = false;\n            }\n            else if (noteU.minLine <= noteL.maxLine + lineSpacing) {\n                if (noteU.isrest) {\n                    shiftRestVertical(noteU, noteL, 1);\n                }\n                else if (noteL.isrest) {\n                    shiftRestVertical(noteL, noteU, -1);\n                }\n                else {\n                    const lineDiff = Math.abs(noteU.line - noteL.line);\n                    if (noteU.note.hasStem() && noteL.note.hasStem()) {\n                        const noteUHead = Tables.codeNoteHead((_a = noteU.note.sortedKeyProps[0].keyProps.code) !== null && _a !== void 0 ? _a : 'N', noteU.note.duration);\n                        const noteLHead = Tables.codeNoteHead((_b = noteL.note.sortedKeyProps[noteL.note.sortedKeyProps.length - 1].keyProps.code) !== null && _b !== void 0 ? _b : 'N', noteL.note.duration);\n                        if (!Tables.UNISON ||\n                            noteUHead !== noteLHead ||\n                            noteU.note.getModifiers().filter((item) => item.getCategory() === \"Dot\" && item.getIndex() === 0)\n                                .length !==\n                                noteL.note.getModifiers().filter((item) => item.getCategory() === \"Dot\" && item.getIndex() === 0)\n                                    .length ||\n                            (lineDiff < 1 && lineDiff > 0) ||\n                            JSON.stringify(noteU.note.getStyle()) !== JSON.stringify(noteL.note.getStyle())) {\n                            xShift = voiceXShift + 2;\n                            if (noteU.stemDirection === noteL.stemDirection) {\n                                noteU.note.setXShift(xShift);\n                            }\n                            else {\n                                noteL.note.setXShift(xShift);\n                            }\n                        }\n                        else if (noteU.note.voice !== noteL.note.voice) {\n                            if (noteU.stemDirection === noteL.stemDirection) {\n                                if (noteU.line != noteL.line) {\n                                    xShift = voiceXShift + 2;\n                                    noteU.note.setXShift(xShift);\n                                }\n                                else {\n                                    if (noteL.stemDirection === 1) {\n                                        noteL.stemDirection = -1;\n                                        noteL.note.setStemDirection(-1);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    else if (lineDiff < 1) {\n                        xShift = voiceXShift + 2;\n                        if (noteU.note.duration < noteL.note.duration) {\n                            noteU.note.setXShift(xShift);\n                        }\n                        else {\n                            noteL.note.setXShift(xShift);\n                        }\n                    }\n                    else if (noteU.note.hasStem()) {\n                        noteU.stemDirection = -noteU.note.getStemDirection();\n                        noteU.note.setStemDirection(noteU.stemDirection);\n                    }\n                    else if (noteL.note.hasStem()) {\n                        noteL.stemDirection = -noteL.note.getStemDirection();\n                        noteL.note.setStemDirection(noteL.stemDirection);\n                    }\n                }\n            }\n            state.right_shift += xShift;\n            return true;\n        }\n        if (!noteM)\n            throw new RuntimeError('InvalidState', 'noteM not defined.');\n        if (noteM.isrest && !noteU.isrest && !noteL.isrest) {\n            if (noteU.minLine <= noteM.maxLine || noteM.minLine <= noteL.maxLine) {\n                const restHeight = noteM.maxLine - noteM.minLine;\n                const space = noteU.minLine - noteL.maxLine;\n                if (restHeight < space) {\n                    centerRest(noteM, noteU, noteL);\n                }\n                else {\n                    xShift = voiceXShift + 2;\n                    noteM.note.setXShift(xShift);\n                    if (noteL.note.hasBeam() === false) {\n                        noteL.stemDirection = -1;\n                        noteL.note.setStemDirection(-1);\n                    }\n                    if (noteU.minLine <= noteL.maxLine && noteU.note.hasBeam() === false) {\n                        noteU.stemDirection = 1;\n                        noteU.note.setStemDirection(1);\n                    }\n                }\n                state.right_shift += xShift;\n                return true;\n            }\n        }\n        if (noteU.isrest && noteM.isrest && noteL.isrest) {\n            noteU.note.render_options.draw = false;\n            noteL.note.render_options.draw = false;\n            state.right_shift += xShift;\n            return true;\n        }\n        if (noteM.isrest && noteU.isrest && noteM.minLine <= noteL.maxLine) {\n            noteM.note.render_options.draw = false;\n        }\n        if (noteM.isrest && noteL.isrest && noteU.minLine <= noteM.maxLine) {\n            noteM.note.render_options.draw = false;\n        }\n        if (noteU.isrest && noteU.minLine <= noteM.maxLine) {\n            shiftRestVertical(noteU, noteM, 1);\n        }\n        if (noteL.isrest && noteM.minLine <= noteL.maxLine) {\n            shiftRestVertical(noteL, noteM, -1);\n        }\n        if (noteU.minLine <= noteM.maxLine + 0.5 || noteM.minLine <= noteL.maxLine) {\n            xShift = voiceXShift + 2;\n            noteM.note.setXShift(xShift);\n            if (noteL.note.hasBeam() === false) {\n                noteL.stemDirection = -1;\n                noteL.note.setStemDirection(-1);\n            }\n            if (noteU.minLine <= noteL.maxLine && noteU.note.hasBeam() === false) {\n                noteU.stemDirection = 1;\n                noteU.note.setStemDirection(1);\n            }\n        }\n        state.right_shift += xShift;\n        return true;\n    }\n    static postFormat(notes) {\n        if (!notes)\n            return false;\n        notes.forEach((note) => note.postFormat());\n        return true;\n    }\n    constructor(noteStruct) {\n        var _a, _b, _c;\n        super(noteStruct);\n        this.minLine = 0;\n        this.maxLine = 0;\n        this.sortedKeyProps = [];\n        this.ledgerLineStyle = {};\n        this.clef = (_a = noteStruct.clef) !== null && _a !== void 0 ? _a : 'treble';\n        this.octave_shift = (_b = noteStruct.octave_shift) !== null && _b !== void 0 ? _b : 0;\n        this.glyphProps = Tables.getGlyphProps(this.duration, this.noteType);\n        defined(this.glyphProps, 'BadArguments', `No glyph found for duration '${this.duration}' and type '${this.noteType}'`);\n        this.displaced = false;\n        this.dot_shiftY = 0;\n        this.use_default_head_x = false;\n        this._noteHeads = [];\n        this.modifiers = [];\n        this.render_options = Object.assign(Object.assign({}, this.render_options), { glyph_font_scale: noteStruct.glyph_font_scale || Tables.NOTATION_FONT_SCALE, stroke_px: noteStruct.stroke_px || StaveNote.LEDGER_LINE_OFFSET });\n        this.calculateKeyProps();\n        this.buildStem();\n        if (noteStruct.auto_stem) {\n            this.autoStem();\n        }\n        else {\n            this.setStemDirection((_c = noteStruct.stem_direction) !== null && _c !== void 0 ? _c : Stem.UP);\n        }\n        this.reset();\n        this.buildFlag();\n    }\n    reset() {\n        super.reset();\n        const noteHeadStyles = this._noteHeads.map((noteHead) => noteHead.getStyle());\n        this.buildNoteHeads();\n        this._noteHeads.forEach((noteHead, index) => {\n            const noteHeadStyle = noteHeadStyles[index];\n            if (noteHeadStyle)\n                noteHead.setStyle(noteHeadStyle);\n        });\n        const stave = this.stave;\n        if (stave) {\n            this.setStave(stave);\n        }\n        this.calcNoteDisplacements();\n        return this;\n    }\n    setBeam(beam) {\n        this.beam = beam;\n        this.calcNoteDisplacements();\n        if (this.stem) {\n            this.stem.setExtension(this.getStemExtension());\n        }\n        return this;\n    }\n    buildStem() {\n        this.setStem(new Stem({ hide: !!this.isRest() }));\n        return this;\n    }\n    buildNoteHeads() {\n        this._noteHeads = [];\n        const stemDirection = this.getStemDirection();\n        const keys = this.getKeys();\n        let lastLine = undefined;\n        let lineDiff = undefined;\n        let displaced = false;\n        let start;\n        let end;\n        let step;\n        if (stemDirection === Stem.UP) {\n            start = 0;\n            end = keys.length;\n            step = 1;\n        }\n        else {\n            start = keys.length - 1;\n            end = -1;\n            step = -1;\n        }\n        for (let i = start; i !== end; i += step) {\n            const noteProps = this.sortedKeyProps[i].keyProps;\n            const line = noteProps.line;\n            if (lastLine === undefined) {\n                lastLine = line;\n            }\n            else {\n                lineDiff = Math.abs(lastLine - line);\n                if (lineDiff === 0 || lineDiff === 0.5) {\n                    displaced = !displaced;\n                }\n                else {\n                    displaced = false;\n                    this.use_default_head_x = true;\n                }\n            }\n            lastLine = line;\n            const notehead = new NoteHead({\n                duration: this.duration,\n                note_type: this.noteType,\n                displaced,\n                stem_direction: stemDirection,\n                custom_glyph_code: noteProps.code,\n                glyph_font_scale: this.render_options.glyph_font_scale,\n                x_shift: noteProps.shift_right,\n                stem_up_x_offset: noteProps.stem_up_x_offset,\n                stem_down_x_offset: noteProps.stem_down_x_offset,\n                line: noteProps.line,\n            });\n            this.addChildElement(notehead);\n            this._noteHeads[this.sortedKeyProps[i].index] = notehead;\n        }\n        return this._noteHeads;\n    }\n    autoStem() {\n        this.setStemDirection(this.calculateOptimalStemDirection());\n    }\n    calculateOptimalStemDirection() {\n        this.minLine = this.sortedKeyProps[0].keyProps.line;\n        this.maxLine = this.sortedKeyProps[this.keyProps.length - 1].keyProps.line;\n        const MIDDLE_LINE = 3;\n        const decider = (this.minLine + this.maxLine) / 2;\n        const stemDirection = decider < MIDDLE_LINE ? Stem.UP : Stem.DOWN;\n        return stemDirection;\n    }\n    calculateKeyProps() {\n        let lastLine;\n        for (let i = 0; i < this.keys.length; ++i) {\n            const key = this.keys[i];\n            if (this.glyphProps.rest)\n                this.glyphProps.position = key;\n            const options = { octave_shift: this.octave_shift || 0, duration: this.duration };\n            const props = Tables.keyProperties(key, this.clef, options);\n            if (!props) {\n                throw new RuntimeError('BadArguments', `Invalid key for note properties: ${key}`);\n            }\n            if (props.key === 'R') {\n                if (this.duration === '1' || this.duration === 'w') {\n                    props.line = 4;\n                }\n                else {\n                    props.line = 3;\n                }\n            }\n            const line = props.line;\n            if (lastLine == undefined) {\n                lastLine = line;\n            }\n            else {\n                if (Math.abs(lastLine - line) === 0.5) {\n                    this.displaced = true;\n                    props.displaced = true;\n                    if (this.keyProps.length > 0) {\n                        this.keyProps[i - 1].displaced = true;\n                    }\n                }\n            }\n            lastLine = line;\n            this.keyProps.push(props);\n        }\n        this.keyProps.forEach((keyProps, index) => {\n            this.sortedKeyProps.push({ keyProps, index });\n        });\n        this.sortedKeyProps.sort((a, b) => a.keyProps.line - b.keyProps.line);\n    }\n    getBoundingBox() {\n        var _a, _b;\n        if (!this.preFormatted) {\n            throw new RuntimeError('UnformattedNote', \"Can't call getBoundingBox on an unformatted note.\");\n        }\n        const { width: w, modLeftPx, leftDisplacedHeadPx } = this.getMetrics();\n        const x = this.getAbsoluteX() - modLeftPx - leftDisplacedHeadPx;\n        let minY = 0;\n        let maxY = 0;\n        const halfLineSpacing = ((_b = (_a = this.getStave()) === null || _a === void 0 ? void 0 : _a.getSpacingBetweenLines()) !== null && _b !== void 0 ? _b : 0) / 2;\n        const lineSpacing = halfLineSpacing * 2;\n        if (this.isRest()) {\n            const y = this.ys[0];\n            const frac = Tables.durationToFraction(this.duration);\n            if (frac.equals(1) || frac.equals(2)) {\n                minY = y - halfLineSpacing;\n                maxY = y + halfLineSpacing;\n            }\n            else {\n                minY = y - this.glyphProps.line_above * lineSpacing;\n                maxY = y + this.glyphProps.line_below * lineSpacing;\n            }\n        }\n        else if (this.glyphProps.stem) {\n            const ys = this.getStemExtents();\n            ys.baseY += halfLineSpacing * this.getStemDirection();\n            minY = Math.min(ys.topY, ys.baseY);\n            maxY = Math.max(ys.topY, ys.baseY);\n        }\n        else {\n            minY = 0;\n            maxY = 0;\n            for (let i = 0; i < this.ys.length; ++i) {\n                const yy = this.ys[i];\n                if (i === 0) {\n                    minY = yy;\n                    maxY = yy;\n                }\n                else {\n                    minY = Math.min(yy, minY);\n                    maxY = Math.max(yy, maxY);\n                }\n            }\n            minY -= halfLineSpacing;\n            maxY += halfLineSpacing;\n        }\n        return new BoundingBox(x, minY, w, maxY - minY);\n    }\n    getLineNumber(isTopNote) {\n        if (!this.keyProps.length) {\n            throw new RuntimeError('NoKeyProps', \"Can't get bottom note line, because note is not initialized properly.\");\n        }\n        let resultLine = this.keyProps[0].line;\n        for (let i = 0; i < this.keyProps.length; i++) {\n            const thisLine = this.keyProps[i].line;\n            if (isTopNote) {\n                if (thisLine > resultLine)\n                    resultLine = thisLine;\n            }\n            else {\n                if (thisLine < resultLine)\n                    resultLine = thisLine;\n            }\n        }\n        return resultLine;\n    }\n    isRest() {\n        return this.glyphProps.rest;\n    }\n    isChord() {\n        return !this.isRest() && this.keys.length > 1;\n    }\n    hasStem() {\n        return this.glyphProps.stem;\n    }\n    hasFlag() {\n        return super.hasFlag() && !this.isRest();\n    }\n    getStemX() {\n        if (this.noteType === 'r') {\n            return this.getCenterGlyphX();\n        }\n        else {\n            return super.getStemX() + (this.stem_direction ? Stem.WIDTH / (2 * -this.stem_direction) : 0);\n        }\n    }\n    getYForTopText(textLine) {\n        const extents = this.getStemExtents();\n        return Math.min(this.checkStave().getYForTopText(textLine), extents.topY - this.render_options.annotation_spacing * (textLine + 1));\n    }\n    getYForBottomText(textLine) {\n        const extents = this.getStemExtents();\n        return Math.max(this.checkStave().getYForTopText(textLine), extents.baseY + this.render_options.annotation_spacing * textLine);\n    }\n    setStave(stave) {\n        super.setStave(stave);\n        const ys = this._noteHeads.map((notehead) => {\n            notehead.setStave(stave);\n            return notehead.getY();\n        });\n        this.setYs(ys);\n        if (this.stem) {\n            const { y_top, y_bottom } = this.getNoteHeadBounds();\n            this.stem.setYBounds(y_top, y_bottom);\n        }\n        return this;\n    }\n    isDisplaced() {\n        return this.displaced;\n    }\n    setNoteDisplaced(displaced) {\n        this.displaced = displaced;\n        return this;\n    }\n    getTieRightX() {\n        let tieStartX = this.getAbsoluteX();\n        tieStartX += this.getGlyphWidth() + this.x_shift + this.rightDisplacedHeadPx;\n        if (this.modifierContext)\n            tieStartX += this.modifierContext.getRightShift();\n        return tieStartX;\n    }\n    getTieLeftX() {\n        let tieEndX = this.getAbsoluteX();\n        tieEndX += this.x_shift - this.leftDisplacedHeadPx;\n        return tieEndX;\n    }\n    getLineForRest() {\n        let restLine = this.keyProps[0].line;\n        if (this.keyProps.length > 1) {\n            const lastLine = this.keyProps[this.keyProps.length - 1].line;\n            const top = Math.max(restLine, lastLine);\n            const bot = Math.min(restLine, lastLine);\n            restLine = midLine(top, bot);\n        }\n        return restLine;\n    }\n    getModifierStartXY(position, index, options = {}) {\n        var _a, _b;\n        if (!this.preFormatted) {\n            throw new RuntimeError('UnformattedNote', \"Can't call GetModifierStartXY on an unformatted note\");\n        }\n        if (this.ys.length === 0) {\n            throw new RuntimeError('NoYValues', 'No Y-Values calculated for this note.');\n        }\n        const { ABOVE, BELOW, LEFT, RIGHT } = Modifier.Position;\n        let x = 0;\n        if (position === LEFT) {\n            x = -1 * 2;\n        }\n        else if (position === RIGHT) {\n            x = this.getGlyphWidth() + this.x_shift + 2;\n            if (this.stem_direction === Stem.UP &&\n                this.hasFlag() &&\n                (options.forceFlagRight || isInnerNoteIndex(this, index))) {\n                x += (_b = (_a = this === null || this === void 0 ? void 0 : this.flag) === null || _a === void 0 ? void 0 : _a.getMetrics().width) !== null && _b !== void 0 ? _b : 0;\n            }\n        }\n        else if (position === BELOW || position === ABOVE) {\n            x = this.getGlyphWidth() / 2;\n        }\n        return {\n            x: this.getAbsoluteX() + x,\n            y: this.ys[index],\n        };\n    }\n    setStyle(style) {\n        return super.setGroupStyle(style);\n    }\n    setStemStyle(style) {\n        const stem = this.getStem();\n        if (stem)\n            stem.setStyle(style);\n        return this;\n    }\n    getStemStyle() {\n        var _a;\n        return (_a = this.stem) === null || _a === void 0 ? void 0 : _a.getStyle();\n    }\n    setLedgerLineStyle(style) {\n        this.ledgerLineStyle = style;\n    }\n    getLedgerLineStyle() {\n        return this.ledgerLineStyle;\n    }\n    setFlagStyle(style) {\n        var _a;\n        (_a = this.flag) === null || _a === void 0 ? void 0 : _a.setStyle(style);\n    }\n    getFlagStyle() {\n        var _a;\n        return (_a = this.flag) === null || _a === void 0 ? void 0 : _a.getStyle();\n    }\n    setKeyStyle(index, style) {\n        this._noteHeads[index].setStyle(style);\n        return this;\n    }\n    setKeyLine(index, line) {\n        this.keyProps[index].line = line;\n        this.reset();\n        return this;\n    }\n    getKeyLine(index) {\n        return this.keyProps[index].line;\n    }\n    getVoiceShiftWidth() {\n        return this.getGlyphWidth() * (this.displaced ? 2 : 1);\n    }\n    calcNoteDisplacements() {\n        this.setLeftDisplacedHeadPx(this.displaced && this.stem_direction === Stem.DOWN ? this.getGlyphWidth() : 0);\n        this.setRightDisplacedHeadPx(!this.hasFlag() && this.displaced && this.stem_direction === Stem.UP ? this.getGlyphWidth() : 0);\n    }\n    preFormat() {\n        if (this.preFormatted)\n            return;\n        let noteHeadPadding = 0;\n        if (this.modifierContext) {\n            this.modifierContext.preFormat();\n            if (this.modifierContext.getWidth() === 0) {\n                noteHeadPadding = StaveNote.minNoteheadPadding;\n            }\n        }\n        let width = this.getGlyphWidth() + this.leftDisplacedHeadPx + this.rightDisplacedHeadPx + noteHeadPadding;\n        if (this.shouldDrawFlag() && this.stem_direction === Stem.UP) {\n            width += this.getGlyphWidth();\n        }\n        this.setWidth(width);\n        this.preFormatted = true;\n    }\n    getNoteHeadBounds() {\n        let yTop = +Infinity;\n        let yBottom = -Infinity;\n        let nonDisplacedX;\n        let displacedX;\n        let highestLine = this.checkStave().getNumLines();\n        let lowestLine = 1;\n        let highestDisplacedLine;\n        let lowestDisplacedLine;\n        let highestNonDisplacedLine = highestLine;\n        let lowestNonDisplacedLine = lowestLine;\n        this._noteHeads.forEach((notehead) => {\n            const line = notehead.getLine();\n            const y = notehead.getY();\n            yTop = Math.min(y, yTop);\n            yBottom = Math.max(y, yBottom);\n            if (displacedX === undefined && notehead.isDisplaced()) {\n                displacedX = notehead.getAbsoluteX();\n            }\n            if (nonDisplacedX === undefined && !notehead.isDisplaced()) {\n                nonDisplacedX = notehead.getAbsoluteX();\n            }\n            highestLine = Math.max(line, highestLine);\n            lowestLine = Math.min(line, lowestLine);\n            if (notehead.isDisplaced()) {\n                highestDisplacedLine = highestDisplacedLine === undefined ? line : Math.max(line, highestDisplacedLine);\n                lowestDisplacedLine = lowestDisplacedLine === undefined ? line : Math.min(line, lowestDisplacedLine);\n            }\n            else {\n                highestNonDisplacedLine = Math.max(line, highestNonDisplacedLine);\n                lowestNonDisplacedLine = Math.min(line, lowestNonDisplacedLine);\n            }\n        }, this);\n        return {\n            y_top: yTop,\n            y_bottom: yBottom,\n            displaced_x: displacedX,\n            non_displaced_x: nonDisplacedX,\n            highest_line: highestLine,\n            lowest_line: lowestLine,\n            highest_displaced_line: highestDisplacedLine,\n            lowest_displaced_line: lowestDisplacedLine,\n            highest_non_displaced_line: highestNonDisplacedLine,\n            lowest_non_displaced_line: lowestNonDisplacedLine,\n        };\n    }\n    getNoteHeadBeginX() {\n        return this.getAbsoluteX() + this.x_shift;\n    }\n    getNoteHeadEndX() {\n        const xBegin = this.getNoteHeadBeginX();\n        return xBegin + this.getGlyphWidth();\n    }\n    get noteHeads() {\n        return this._noteHeads.slice();\n    }\n    get note_heads() {\n        showDeprecationWarningForNoteHeads();\n        return this.noteHeads;\n    }\n    drawLedgerLines() {\n        const stave = this.checkStave();\n        const { glyphProps, render_options: { stroke_px }, } = this;\n        const ctx = this.checkContext();\n        const width = glyphProps.getWidth() + stroke_px * 2;\n        const doubleWidth = 2 * (glyphProps.getWidth() + stroke_px) - Stem.WIDTH / 2;\n        if (this.isRest())\n            return;\n        if (!ctx) {\n            throw new RuntimeError('NoCanvasContext', \"Can't draw without a canvas context.\");\n        }\n        const { highest_line, lowest_line, highest_displaced_line, highest_non_displaced_line, lowest_displaced_line, lowest_non_displaced_line, displaced_x, non_displaced_x, } = this.getNoteHeadBounds();\n        if (highest_line < 6 && lowest_line > 0)\n            return;\n        const min_x = Math.min(displaced_x !== null && displaced_x !== void 0 ? displaced_x : 0, non_displaced_x !== null && non_displaced_x !== void 0 ? non_displaced_x : 0);\n        const drawLedgerLine = (y, normal, displaced) => {\n            let x;\n            if (displaced && normal)\n                x = min_x - stroke_px;\n            else if (normal)\n                x = (non_displaced_x !== null && non_displaced_x !== void 0 ? non_displaced_x : 0) - stroke_px;\n            else\n                x = (displaced_x !== null && displaced_x !== void 0 ? displaced_x : 0) - stroke_px;\n            const ledgerWidth = normal && displaced ? doubleWidth : width;\n            ctx.beginPath();\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + ledgerWidth, y);\n            ctx.stroke();\n        };\n        const style = Object.assign(Object.assign({}, stave.getDefaultLedgerLineStyle()), this.getLedgerLineStyle());\n        this.applyStyle(ctx, style);\n        for (let line = 6; line <= highest_line; ++line) {\n            const normal = non_displaced_x !== undefined && line <= highest_non_displaced_line;\n            const displaced = highest_displaced_line !== undefined && line <= highest_displaced_line;\n            drawLedgerLine(stave.getYForNote(line), normal, displaced);\n        }\n        for (let line = 0; line >= lowest_line; --line) {\n            const normal = non_displaced_x !== undefined && line >= lowest_non_displaced_line;\n            const displaced = lowest_displaced_line !== undefined && line >= lowest_displaced_line;\n            drawLedgerLine(stave.getYForNote(line), normal, displaced);\n        }\n        this.restoreStyle(ctx, style);\n    }\n    drawModifiers(noteheadParam) {\n        const ctx = this.checkContext();\n        for (let i = 0; i < this.modifiers.length; i++) {\n            const modifier = this.modifiers[i];\n            const index = modifier.checkIndex();\n            const notehead = this._noteHeads[index];\n            if (notehead == noteheadParam) {\n                const noteheadStyle = notehead.getStyle();\n                notehead.applyStyle(ctx, noteheadStyle);\n                modifier.setContext(ctx);\n                modifier.drawWithStyle();\n                notehead.restoreStyle(ctx, noteheadStyle);\n            }\n        }\n    }\n    shouldDrawFlag() {\n        const hasStem = this.stem !== undefined;\n        const hasFlag = this.glyphProps.flag == true;\n        const hasNoBeam = this.beam === undefined;\n        return hasStem && hasFlag && hasNoBeam;\n    }\n    drawFlag() {\n        var _a, _b, _c, _d, _e;\n        const ctx = this.checkContext();\n        if (!ctx) {\n            throw new RuntimeError('NoCanvasContext', \"Can't draw without a canvas context.\");\n        }\n        if (this.shouldDrawFlag()) {\n            const { y_top, y_bottom } = this.getNoteHeadBounds();\n            const noteStemHeight = this.stem.getHeight();\n            const flagX = this.getStemX();\n            const flagY = this.getStemDirection() === Stem.DOWN\n                ?\n                    y_top -\n                        noteStemHeight +\n                        2 -\n                        (this.glyphProps ? this.glyphProps.stem_down_extension : 0) * this.getStaveNoteScale() -\n                        ((_b = (_a = this.flag) === null || _a === void 0 ? void 0 : _a.getMetrics().y_shift) !== null && _b !== void 0 ? _b : 0) * (1 - this.getStaveNoteScale())\n                :\n                    y_bottom -\n                        noteStemHeight -\n                        2 +\n                        (this.glyphProps ? this.glyphProps.stem_up_extension : 0) * this.getStaveNoteScale() -\n                        ((_d = (_c = this.flag) === null || _c === void 0 ? void 0 : _c.getMetrics().y_shift) !== null && _d !== void 0 ? _d : 0) * (1 - this.getStaveNoteScale());\n            (_e = this.flag) === null || _e === void 0 ? void 0 : _e.render(ctx, flagX, flagY);\n        }\n    }\n    drawNoteHeads() {\n        const ctx = this.checkContext();\n        this._noteHeads.forEach((notehead) => {\n            notehead.applyStyle(ctx);\n            ctx.openGroup('notehead', notehead.getAttribute('id'), { pointerBBox: true });\n            notehead.setContext(ctx).draw();\n            this.drawModifiers(notehead);\n            ctx.closeGroup();\n            notehead.restoreStyle(ctx);\n        });\n    }\n    drawStem(stemOptions) {\n        const ctx = this.checkContext();\n        if (stemOptions) {\n            this.setStem(new Stem(stemOptions));\n        }\n        if (this.shouldDrawFlag() && this.stem) {\n            this.stem.adjustHeightForFlag();\n        }\n        if (this.stem) {\n            this.stem.setContext(ctx).draw();\n        }\n    }\n    getStaveNoteScale() {\n        return 1.0;\n    }\n    getStemExtension() {\n        const super_stem_extension = super.getStemExtension();\n        if (!this.glyphProps.stem) {\n            return super_stem_extension;\n        }\n        const stem_direction = this.getStemDirection();\n        if (stem_direction !== this.calculateOptimalStemDirection()) {\n            return super_stem_extension;\n        }\n        let mid_line_distance;\n        const MIDDLE_LINE = 3;\n        if (stem_direction === Stem.UP) {\n            mid_line_distance = MIDDLE_LINE - this.maxLine;\n        }\n        else {\n            mid_line_distance = this.minLine - MIDDLE_LINE;\n        }\n        const lines_over_octave_from_mid_line = mid_line_distance - 3.5;\n        if (lines_over_octave_from_mid_line <= 0) {\n            return super_stem_extension;\n        }\n        const stave = this.getStave();\n        let spacing_between_lines = 10;\n        if (stave != undefined) {\n            spacing_between_lines = stave.getSpacingBetweenLines();\n        }\n        return super_stem_extension + lines_over_octave_from_mid_line * spacing_between_lines;\n    }\n    draw() {\n        if (this.render_options.draw === false)\n            return;\n        if (this.ys.length === 0) {\n            throw new RuntimeError('NoYValues', \"Can't draw note without Y values.\");\n        }\n        const ctx = this.checkContext();\n        const xBegin = this.getNoteHeadBeginX();\n        const shouldRenderStem = this.hasStem() && !this.beam;\n        this._noteHeads.forEach((notehead) => notehead.setX(xBegin));\n        if (this.stem) {\n            const stemX = this.getStemX();\n            this.stem.setNoteHeadXBounds(stemX, stemX);\n        }\n        L('Rendering ', this.isChord() ? 'chord :' : 'note :', this.keys);\n        this.applyStyle();\n        ctx.openGroup('stavenote', this.getAttribute('id'));\n        this.drawLedgerLines();\n        if (shouldRenderStem)\n            this.drawStem();\n        this.drawNoteHeads();\n        this.drawFlag();\n        ctx.closeGroup();\n        this.restoreStyle();\n        this.setRendered();\n    }\n}\nStaveNote.DEBUG = false;\nexport { StaveNote };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}