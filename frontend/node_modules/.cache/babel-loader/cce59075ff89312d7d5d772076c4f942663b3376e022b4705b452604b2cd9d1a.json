{"ast":null,"code":"import { Element } from './element.js';\nimport { Modifier } from './modifier.js';\nimport { RuntimeError } from './util.js';\nclass StaveHairpin extends Element {\n  static get CATEGORY() {\n    return \"StaveHairpin\";\n  }\n  static FormatByTicksAndDraw(ctx, formatter, notes, type, position, options) {\n    var _a, _b;\n    const ppt = formatter.pixelsPerTick;\n    if (ppt == null) {\n      throw new RuntimeError('BadArguments', 'A valid Formatter must be provide to draw offsets by ticks.');\n    }\n    const l_shift_px = ppt * ((_a = options.left_shift_ticks) !== null && _a !== void 0 ? _a : 0);\n    const r_shift_px = ppt * ((_b = options.right_shift_ticks) !== null && _b !== void 0 ? _b : 0);\n    const hairpin_options = {\n      height: options.height,\n      y_shift: options.y_shift,\n      left_shift_px: l_shift_px,\n      right_shift_px: r_shift_px,\n      right_shift_ticks: 0,\n      left_shift_ticks: 0\n    };\n    new StaveHairpin({\n      first_note: notes.first_note,\n      last_note: notes.last_note\n    }, type).setContext(ctx).setRenderOptions(hairpin_options).setPosition(position).draw();\n  }\n  constructor(notes, type) {\n    super();\n    this.setNotes(notes);\n    this.hairpin = type;\n    this.position = Modifier.Position.BELOW;\n    this.render_options = {\n      height: 10,\n      y_shift: 0,\n      left_shift_px: 0,\n      right_shift_px: 0,\n      right_shift_ticks: 0,\n      left_shift_ticks: 0\n    };\n  }\n  setPosition(position) {\n    if (position === Modifier.Position.ABOVE || position === Modifier.Position.BELOW) {\n      this.position = position;\n    }\n    return this;\n  }\n  setRenderOptions(options) {\n    if (options.height != null && options.y_shift != null && options.left_shift_px != null && options.right_shift_px != null) {\n      this.render_options = options;\n    }\n    return this;\n  }\n  setNotes(notes) {\n    if (!notes.first_note && !notes.last_note) {\n      throw new RuntimeError('BadArguments', 'Hairpin needs to have either first_note or last_note set.');\n    }\n    this.notes = notes;\n    this.first_note = notes.first_note;\n    this.last_note = notes.last_note;\n    return this;\n  }\n  renderHairpin(params) {\n    const ctx = this.checkContext();\n    let dis = this.render_options.y_shift + 20;\n    let y_shift = params.first_y;\n    if (this.position === Modifier.Position.ABOVE) {\n      dis = -dis + 30;\n      y_shift = params.first_y - params.staff_height;\n    }\n    const l_shift = this.render_options.left_shift_px;\n    const r_shift = this.render_options.right_shift_px;\n    ctx.beginPath();\n    switch (this.hairpin) {\n      case StaveHairpin.type.CRESC:\n        ctx.moveTo(params.last_x + r_shift, y_shift + dis);\n        ctx.lineTo(params.first_x + l_shift, y_shift + this.render_options.height / 2 + dis);\n        ctx.lineTo(params.last_x + r_shift, y_shift + this.render_options.height + dis);\n        break;\n      case StaveHairpin.type.DECRESC:\n        ctx.moveTo(params.first_x + l_shift, y_shift + dis);\n        ctx.lineTo(params.last_x + r_shift, y_shift + this.render_options.height / 2 + dis);\n        ctx.lineTo(params.first_x + l_shift, y_shift + this.render_options.height + dis);\n        break;\n      default:\n        break;\n    }\n    ctx.stroke();\n    ctx.closePath();\n  }\n  draw() {\n    this.checkContext();\n    this.setRendered();\n    const firstNote = this.first_note;\n    const lastNote = this.last_note;\n    if (!firstNote || !lastNote) throw new RuntimeError('NoNote', 'Notes required to draw');\n    const start = firstNote.getModifierStartXY(this.position, 0);\n    const end = lastNote.getModifierStartXY(this.position, 0);\n    this.renderHairpin({\n      first_x: start.x,\n      last_x: end.x,\n      first_y: firstNote.checkStave().getY() + firstNote.checkStave().getHeight(),\n      last_y: lastNote.checkStave().getY() + lastNote.checkStave().getHeight(),\n      staff_height: firstNote.checkStave().getHeight()\n    });\n  }\n}\nStaveHairpin.type = {\n  CRESC: 1,\n  DECRESC: 2\n};\nexport { StaveHairpin };","map":{"version":3,"names":["Element","Modifier","RuntimeError","StaveHairpin","CATEGORY","FormatByTicksAndDraw","ctx","formatter","notes","type","position","options","_a","_b","ppt","pixelsPerTick","l_shift_px","left_shift_ticks","r_shift_px","right_shift_ticks","hairpin_options","height","y_shift","left_shift_px","right_shift_px","first_note","last_note","setContext","setRenderOptions","setPosition","draw","constructor","setNotes","hairpin","Position","BELOW","render_options","ABOVE","renderHairpin","params","checkContext","dis","first_y","staff_height","l_shift","r_shift","beginPath","CRESC","moveTo","last_x","lineTo","first_x","DECRESC","stroke","closePath","setRendered","firstNote","lastNote","start","getModifierStartXY","end","x","checkStave","getY","getHeight","last_y"],"sources":["/Users/lang/Documents/code/Song2Notation/frontend/node_modules/vexflow/build/esm/src/stavehairpin.js"],"sourcesContent":["import { Element } from './element.js';\nimport { Modifier } from './modifier.js';\nimport { RuntimeError } from './util.js';\nclass StaveHairpin extends Element {\n    static get CATEGORY() {\n        return \"StaveHairpin\";\n    }\n    static FormatByTicksAndDraw(ctx, formatter, notes, type, position, options) {\n        var _a, _b;\n        const ppt = formatter.pixelsPerTick;\n        if (ppt == null) {\n            throw new RuntimeError('BadArguments', 'A valid Formatter must be provide to draw offsets by ticks.');\n        }\n        const l_shift_px = ppt * ((_a = options.left_shift_ticks) !== null && _a !== void 0 ? _a : 0);\n        const r_shift_px = ppt * ((_b = options.right_shift_ticks) !== null && _b !== void 0 ? _b : 0);\n        const hairpin_options = {\n            height: options.height,\n            y_shift: options.y_shift,\n            left_shift_px: l_shift_px,\n            right_shift_px: r_shift_px,\n            right_shift_ticks: 0,\n            left_shift_ticks: 0,\n        };\n        new StaveHairpin({\n            first_note: notes.first_note,\n            last_note: notes.last_note,\n        }, type)\n            .setContext(ctx)\n            .setRenderOptions(hairpin_options)\n            .setPosition(position)\n            .draw();\n    }\n    constructor(notes, type) {\n        super();\n        this.setNotes(notes);\n        this.hairpin = type;\n        this.position = Modifier.Position.BELOW;\n        this.render_options = {\n            height: 10,\n            y_shift: 0,\n            left_shift_px: 0,\n            right_shift_px: 0,\n            right_shift_ticks: 0,\n            left_shift_ticks: 0,\n        };\n    }\n    setPosition(position) {\n        if (position === Modifier.Position.ABOVE || position === Modifier.Position.BELOW) {\n            this.position = position;\n        }\n        return this;\n    }\n    setRenderOptions(options) {\n        if (options.height != null &&\n            options.y_shift != null &&\n            options.left_shift_px != null &&\n            options.right_shift_px != null) {\n            this.render_options = options;\n        }\n        return this;\n    }\n    setNotes(notes) {\n        if (!notes.first_note && !notes.last_note) {\n            throw new RuntimeError('BadArguments', 'Hairpin needs to have either first_note or last_note set.');\n        }\n        this.notes = notes;\n        this.first_note = notes.first_note;\n        this.last_note = notes.last_note;\n        return this;\n    }\n    renderHairpin(params) {\n        const ctx = this.checkContext();\n        let dis = this.render_options.y_shift + 20;\n        let y_shift = params.first_y;\n        if (this.position === Modifier.Position.ABOVE) {\n            dis = -dis + 30;\n            y_shift = params.first_y - params.staff_height;\n        }\n        const l_shift = this.render_options.left_shift_px;\n        const r_shift = this.render_options.right_shift_px;\n        ctx.beginPath();\n        switch (this.hairpin) {\n            case StaveHairpin.type.CRESC:\n                ctx.moveTo(params.last_x + r_shift, y_shift + dis);\n                ctx.lineTo(params.first_x + l_shift, y_shift + this.render_options.height / 2 + dis);\n                ctx.lineTo(params.last_x + r_shift, y_shift + this.render_options.height + dis);\n                break;\n            case StaveHairpin.type.DECRESC:\n                ctx.moveTo(params.first_x + l_shift, y_shift + dis);\n                ctx.lineTo(params.last_x + r_shift, y_shift + this.render_options.height / 2 + dis);\n                ctx.lineTo(params.first_x + l_shift, y_shift + this.render_options.height + dis);\n                break;\n            default:\n                break;\n        }\n        ctx.stroke();\n        ctx.closePath();\n    }\n    draw() {\n        this.checkContext();\n        this.setRendered();\n        const firstNote = this.first_note;\n        const lastNote = this.last_note;\n        if (!firstNote || !lastNote)\n            throw new RuntimeError('NoNote', 'Notes required to draw');\n        const start = firstNote.getModifierStartXY(this.position, 0);\n        const end = lastNote.getModifierStartXY(this.position, 0);\n        this.renderHairpin({\n            first_x: start.x,\n            last_x: end.x,\n            first_y: firstNote.checkStave().getY() + firstNote.checkStave().getHeight(),\n            last_y: lastNote.checkStave().getY() + lastNote.checkStave().getHeight(),\n            staff_height: firstNote.checkStave().getHeight(),\n        });\n    }\n}\nStaveHairpin.type = {\n    CRESC: 1,\n    DECRESC: 2,\n};\nexport { StaveHairpin };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}