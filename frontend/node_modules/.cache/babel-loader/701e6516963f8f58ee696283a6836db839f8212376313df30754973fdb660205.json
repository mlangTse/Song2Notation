{"ast":null,"code":"import { Element } from './element.js';\nimport { Font, FontStyle, FontWeight } from './font.js';\nimport { Glyph } from './glyph.js';\nimport { Tables } from './tables.js';\nimport { RuntimeError } from './util.js';\nfunction drawBoldDoubleLine(ctx, type, topX, topY, botY) {\n  if (type !== StaveConnector.type.BOLD_DOUBLE_LEFT && type !== StaveConnector.type.BOLD_DOUBLE_RIGHT) {\n    throw new RuntimeError('InvalidConnector', 'A REPEAT_BEGIN or REPEAT_END type must be provided.');\n  }\n  let x_shift = 3;\n  let variableWidth = 3.5;\n  const thickLineOffset = 2;\n  if (type === StaveConnector.type.BOLD_DOUBLE_RIGHT) {\n    x_shift = -5;\n    variableWidth = 3;\n  }\n  ctx.fillRect(topX + x_shift, topY, 1, botY - topY);\n  ctx.fillRect(topX - thickLineOffset, topY, variableWidth, botY - topY);\n}\nclass StaveConnector extends Element {\n  static get CATEGORY() {\n    return \"StaveConnector\";\n  }\n  constructor(top_stave, bottom_stave) {\n    super();\n    this.thickness = Tables.STAVE_LINE_THICKNESS;\n    this.width = 3;\n    this.top_stave = top_stave;\n    this.bottom_stave = bottom_stave;\n    this.type = StaveConnector.type.DOUBLE;\n    this.resetFont();\n    this.x_shift = 0;\n    this.texts = [];\n  }\n  setType(type) {\n    const newType = typeof type === 'string' ? StaveConnector.typeString[type] : type;\n    if (Object.values(StaveConnector.type).includes(newType)) {\n      this.type = newType;\n    }\n    return this;\n  }\n  getType() {\n    return this.type;\n  }\n  setText(text) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.texts.push({\n      content: text,\n      options: Object.assign({\n        shift_x: 0,\n        shift_y: 0\n      }, options)\n    });\n    return this;\n  }\n  setXShift(x_shift) {\n    if (typeof x_shift !== 'number') {\n      throw new RuntimeError('InvalidType', 'x_shift must be a Number');\n    }\n    this.x_shift = x_shift;\n    return this;\n  }\n  getXShift() {\n    return this.x_shift;\n  }\n  draw() {\n    const ctx = this.checkContext();\n    this.setRendered();\n    let topY = this.top_stave.getYForLine(0);\n    let botY = this.bottom_stave.getYForLine(this.bottom_stave.getNumLines() - 1) + this.thickness;\n    let width = this.width;\n    let topX = this.top_stave.getX();\n    const isRightSidedConnector = this.type === StaveConnector.type.SINGLE_RIGHT || this.type === StaveConnector.type.BOLD_DOUBLE_RIGHT || this.type === StaveConnector.type.THIN_DOUBLE;\n    if (isRightSidedConnector) {\n      topX = this.top_stave.getX() + this.top_stave.getWidth();\n    }\n    let attachment_height = botY - topY;\n    switch (this.type) {\n      case StaveConnector.type.SINGLE:\n        width = 1;\n        break;\n      case StaveConnector.type.SINGLE_LEFT:\n        width = 1;\n        break;\n      case StaveConnector.type.SINGLE_RIGHT:\n        width = 1;\n        break;\n      case StaveConnector.type.DOUBLE:\n        topX -= this.width + 2;\n        topY -= this.thickness;\n        attachment_height += 0.5;\n        break;\n      case StaveConnector.type.BRACE:\n        {\n          width = 12;\n          const x1 = this.top_stave.getX() - 2 + this.x_shift;\n          const y1 = topY;\n          const x3 = x1;\n          const y3 = botY;\n          const x2 = x1 - width;\n          const y2 = y1 + attachment_height / 2.0;\n          const cpx1 = x2 - 0.9 * width;\n          const cpy1 = y1 + 0.2 * attachment_height;\n          const cpx2 = x1 + 1.1 * width;\n          const cpy2 = y2 - 0.135 * attachment_height;\n          const cpx3 = cpx2;\n          const cpy3 = y2 + 0.135 * attachment_height;\n          const cpx4 = cpx1;\n          const cpy4 = y3 - 0.2 * attachment_height;\n          const cpx5 = x2 - width;\n          const cpy5 = cpy4;\n          const cpx6 = x1 + 0.4 * width;\n          const cpy6 = y2 + 0.135 * attachment_height;\n          const cpx7 = cpx6;\n          const cpy7 = y2 - 0.135 * attachment_height;\n          const cpx8 = cpx5;\n          const cpy8 = cpy1;\n          ctx.beginPath();\n          ctx.moveTo(x1, y1);\n          ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);\n          ctx.bezierCurveTo(cpx3, cpy3, cpx4, cpy4, x3, y3);\n          ctx.bezierCurveTo(cpx5, cpy5, cpx6, cpy6, x2, y2);\n          ctx.bezierCurveTo(cpx7, cpy7, cpx8, cpy8, x1, y1);\n          ctx.fill();\n          ctx.stroke();\n          break;\n        }\n      case StaveConnector.type.BRACKET:\n        topY -= 6;\n        botY += 6;\n        attachment_height = botY - topY;\n        Glyph.renderGlyph(ctx, topX - 5, topY, 40, 'bracketTop');\n        Glyph.renderGlyph(ctx, topX - 5, botY, 40, 'bracketBottom');\n        topX -= this.width + 2;\n        break;\n      case StaveConnector.type.BOLD_DOUBLE_LEFT:\n        drawBoldDoubleLine(ctx, this.type, topX + this.x_shift, topY, botY - this.thickness);\n        break;\n      case StaveConnector.type.BOLD_DOUBLE_RIGHT:\n        drawBoldDoubleLine(ctx, this.type, topX, topY, botY - this.thickness);\n        break;\n      case StaveConnector.type.THIN_DOUBLE:\n        width = 1;\n        attachment_height -= this.thickness;\n        break;\n      case StaveConnector.type.NONE:\n        break;\n      default:\n        throw new RuntimeError('InvalidType', `The provided StaveConnector.type (${this.type}) is invalid.`);\n    }\n    if (this.type !== StaveConnector.type.BRACE && this.type !== StaveConnector.type.BOLD_DOUBLE_LEFT && this.type !== StaveConnector.type.BOLD_DOUBLE_RIGHT && this.type !== StaveConnector.type.NONE) {\n      ctx.fillRect(topX, topY, width, attachment_height);\n    }\n    if (this.type === StaveConnector.type.THIN_DOUBLE) {\n      ctx.fillRect(topX - 3, topY, width, attachment_height);\n    }\n    ctx.save();\n    ctx.setLineWidth(2);\n    ctx.setFont(this.textFont);\n    for (let i = 0; i < this.texts.length; i++) {\n      const text = this.texts[i];\n      const text_width = ctx.measureText('' + text.content).width;\n      const x = this.top_stave.getX() - text_width - 24 + text.options.shift_x;\n      const y = (this.top_stave.getYForLine(0) + this.bottom_stave.getBottomLineY()) / 2 + text.options.shift_y;\n      ctx.fillText('' + text.content, x, y + 4);\n    }\n    ctx.restore();\n  }\n}\nStaveConnector.TEXT_FONT = {\n  family: Font.SERIF,\n  size: 16,\n  weight: FontWeight.NORMAL,\n  style: FontStyle.NORMAL\n};\nStaveConnector.type = {\n  SINGLE_RIGHT: 0,\n  SINGLE_LEFT: 1,\n  SINGLE: 1,\n  DOUBLE: 2,\n  BRACE: 3,\n  BRACKET: 4,\n  BOLD_DOUBLE_LEFT: 5,\n  BOLD_DOUBLE_RIGHT: 6,\n  THIN_DOUBLE: 7,\n  NONE: 8\n};\nStaveConnector.typeString = {\n  singleRight: StaveConnector.type.SINGLE_RIGHT,\n  singleLeft: StaveConnector.type.SINGLE_LEFT,\n  single: StaveConnector.type.SINGLE,\n  double: StaveConnector.type.DOUBLE,\n  brace: StaveConnector.type.BRACE,\n  bracket: StaveConnector.type.BRACKET,\n  boldDoubleLeft: StaveConnector.type.BOLD_DOUBLE_LEFT,\n  boldDoubleRight: StaveConnector.type.BOLD_DOUBLE_RIGHT,\n  thinDouble: StaveConnector.type.THIN_DOUBLE,\n  none: StaveConnector.type.NONE\n};\nexport { StaveConnector };","map":{"version":3,"names":["Element","Font","FontStyle","FontWeight","Glyph","Tables","RuntimeError","drawBoldDoubleLine","ctx","type","topX","topY","botY","StaveConnector","BOLD_DOUBLE_LEFT","BOLD_DOUBLE_RIGHT","x_shift","variableWidth","thickLineOffset","fillRect","CATEGORY","constructor","top_stave","bottom_stave","thickness","STAVE_LINE_THICKNESS","width","DOUBLE","resetFont","texts","setType","newType","typeString","Object","values","includes","getType","setText","text","options","arguments","length","undefined","push","content","assign","shift_x","shift_y","setXShift","getXShift","draw","checkContext","setRendered","getYForLine","getNumLines","getX","isRightSidedConnector","SINGLE_RIGHT","THIN_DOUBLE","getWidth","attachment_height","SINGLE","SINGLE_LEFT","BRACE","x1","y1","x3","y3","x2","y2","cpx1","cpy1","cpx2","cpy2","cpx3","cpy3","cpx4","cpy4","cpx5","cpy5","cpx6","cpy6","cpx7","cpy7","cpx8","cpy8","beginPath","moveTo","bezierCurveTo","fill","stroke","BRACKET","renderGlyph","NONE","save","setLineWidth","setFont","textFont","i","text_width","measureText","x","y","getBottomLineY","fillText","restore","TEXT_FONT","family","SERIF","size","weight","NORMAL","style","singleRight","singleLeft","single","double","brace","bracket","boldDoubleLeft","boldDoubleRight","thinDouble","none"],"sources":["/Users/lang/Documents/code/Song2Notation/frontend/node_modules/vexflow/build/esm/src/staveconnector.js"],"sourcesContent":["import { Element } from './element.js';\nimport { Font, FontStyle, FontWeight } from './font.js';\nimport { Glyph } from './glyph.js';\nimport { Tables } from './tables.js';\nimport { RuntimeError } from './util.js';\nfunction drawBoldDoubleLine(ctx, type, topX, topY, botY) {\n    if (type !== StaveConnector.type.BOLD_DOUBLE_LEFT && type !== StaveConnector.type.BOLD_DOUBLE_RIGHT) {\n        throw new RuntimeError('InvalidConnector', 'A REPEAT_BEGIN or REPEAT_END type must be provided.');\n    }\n    let x_shift = 3;\n    let variableWidth = 3.5;\n    const thickLineOffset = 2;\n    if (type === StaveConnector.type.BOLD_DOUBLE_RIGHT) {\n        x_shift = -5;\n        variableWidth = 3;\n    }\n    ctx.fillRect(topX + x_shift, topY, 1, botY - topY);\n    ctx.fillRect(topX - thickLineOffset, topY, variableWidth, botY - topY);\n}\nclass StaveConnector extends Element {\n    static get CATEGORY() {\n        return \"StaveConnector\";\n    }\n    constructor(top_stave, bottom_stave) {\n        super();\n        this.thickness = Tables.STAVE_LINE_THICKNESS;\n        this.width = 3;\n        this.top_stave = top_stave;\n        this.bottom_stave = bottom_stave;\n        this.type = StaveConnector.type.DOUBLE;\n        this.resetFont();\n        this.x_shift = 0;\n        this.texts = [];\n    }\n    setType(type) {\n        const newType = typeof type === 'string' ? StaveConnector.typeString[type] : type;\n        if (Object.values(StaveConnector.type).includes(newType)) {\n            this.type = newType;\n        }\n        return this;\n    }\n    getType() {\n        return this.type;\n    }\n    setText(text, options = {}) {\n        this.texts.push({\n            content: text,\n            options: Object.assign({ shift_x: 0, shift_y: 0 }, options),\n        });\n        return this;\n    }\n    setXShift(x_shift) {\n        if (typeof x_shift !== 'number') {\n            throw new RuntimeError('InvalidType', 'x_shift must be a Number');\n        }\n        this.x_shift = x_shift;\n        return this;\n    }\n    getXShift() {\n        return this.x_shift;\n    }\n    draw() {\n        const ctx = this.checkContext();\n        this.setRendered();\n        let topY = this.top_stave.getYForLine(0);\n        let botY = this.bottom_stave.getYForLine(this.bottom_stave.getNumLines() - 1) + this.thickness;\n        let width = this.width;\n        let topX = this.top_stave.getX();\n        const isRightSidedConnector = this.type === StaveConnector.type.SINGLE_RIGHT ||\n            this.type === StaveConnector.type.BOLD_DOUBLE_RIGHT ||\n            this.type === StaveConnector.type.THIN_DOUBLE;\n        if (isRightSidedConnector) {\n            topX = this.top_stave.getX() + this.top_stave.getWidth();\n        }\n        let attachment_height = botY - topY;\n        switch (this.type) {\n            case StaveConnector.type.SINGLE:\n                width = 1;\n                break;\n            case StaveConnector.type.SINGLE_LEFT:\n                width = 1;\n                break;\n            case StaveConnector.type.SINGLE_RIGHT:\n                width = 1;\n                break;\n            case StaveConnector.type.DOUBLE:\n                topX -= this.width + 2;\n                topY -= this.thickness;\n                attachment_height += 0.5;\n                break;\n            case StaveConnector.type.BRACE: {\n                width = 12;\n                const x1 = this.top_stave.getX() - 2 + this.x_shift;\n                const y1 = topY;\n                const x3 = x1;\n                const y3 = botY;\n                const x2 = x1 - width;\n                const y2 = y1 + attachment_height / 2.0;\n                const cpx1 = x2 - 0.9 * width;\n                const cpy1 = y1 + 0.2 * attachment_height;\n                const cpx2 = x1 + 1.1 * width;\n                const cpy2 = y2 - 0.135 * attachment_height;\n                const cpx3 = cpx2;\n                const cpy3 = y2 + 0.135 * attachment_height;\n                const cpx4 = cpx1;\n                const cpy4 = y3 - 0.2 * attachment_height;\n                const cpx5 = x2 - width;\n                const cpy5 = cpy4;\n                const cpx6 = x1 + 0.4 * width;\n                const cpy6 = y2 + 0.135 * attachment_height;\n                const cpx7 = cpx6;\n                const cpy7 = y2 - 0.135 * attachment_height;\n                const cpx8 = cpx5;\n                const cpy8 = cpy1;\n                ctx.beginPath();\n                ctx.moveTo(x1, y1);\n                ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);\n                ctx.bezierCurveTo(cpx3, cpy3, cpx4, cpy4, x3, y3);\n                ctx.bezierCurveTo(cpx5, cpy5, cpx6, cpy6, x2, y2);\n                ctx.bezierCurveTo(cpx7, cpy7, cpx8, cpy8, x1, y1);\n                ctx.fill();\n                ctx.stroke();\n                break;\n            }\n            case StaveConnector.type.BRACKET:\n                topY -= 6;\n                botY += 6;\n                attachment_height = botY - topY;\n                Glyph.renderGlyph(ctx, topX - 5, topY, 40, 'bracketTop');\n                Glyph.renderGlyph(ctx, topX - 5, botY, 40, 'bracketBottom');\n                topX -= this.width + 2;\n                break;\n            case StaveConnector.type.BOLD_DOUBLE_LEFT:\n                drawBoldDoubleLine(ctx, this.type, topX + this.x_shift, topY, botY - this.thickness);\n                break;\n            case StaveConnector.type.BOLD_DOUBLE_RIGHT:\n                drawBoldDoubleLine(ctx, this.type, topX, topY, botY - this.thickness);\n                break;\n            case StaveConnector.type.THIN_DOUBLE:\n                width = 1;\n                attachment_height -= this.thickness;\n                break;\n            case StaveConnector.type.NONE:\n                break;\n            default:\n                throw new RuntimeError('InvalidType', `The provided StaveConnector.type (${this.type}) is invalid.`);\n        }\n        if (this.type !== StaveConnector.type.BRACE &&\n            this.type !== StaveConnector.type.BOLD_DOUBLE_LEFT &&\n            this.type !== StaveConnector.type.BOLD_DOUBLE_RIGHT &&\n            this.type !== StaveConnector.type.NONE) {\n            ctx.fillRect(topX, topY, width, attachment_height);\n        }\n        if (this.type === StaveConnector.type.THIN_DOUBLE) {\n            ctx.fillRect(topX - 3, topY, width, attachment_height);\n        }\n        ctx.save();\n        ctx.setLineWidth(2);\n        ctx.setFont(this.textFont);\n        for (let i = 0; i < this.texts.length; i++) {\n            const text = this.texts[i];\n            const text_width = ctx.measureText('' + text.content).width;\n            const x = this.top_stave.getX() - text_width - 24 + text.options.shift_x;\n            const y = (this.top_stave.getYForLine(0) + this.bottom_stave.getBottomLineY()) / 2 + text.options.shift_y;\n            ctx.fillText('' + text.content, x, y + 4);\n        }\n        ctx.restore();\n    }\n}\nStaveConnector.TEXT_FONT = {\n    family: Font.SERIF,\n    size: 16,\n    weight: FontWeight.NORMAL,\n    style: FontStyle.NORMAL,\n};\nStaveConnector.type = {\n    SINGLE_RIGHT: 0,\n    SINGLE_LEFT: 1,\n    SINGLE: 1,\n    DOUBLE: 2,\n    BRACE: 3,\n    BRACKET: 4,\n    BOLD_DOUBLE_LEFT: 5,\n    BOLD_DOUBLE_RIGHT: 6,\n    THIN_DOUBLE: 7,\n    NONE: 8,\n};\nStaveConnector.typeString = {\n    singleRight: StaveConnector.type.SINGLE_RIGHT,\n    singleLeft: StaveConnector.type.SINGLE_LEFT,\n    single: StaveConnector.type.SINGLE,\n    double: StaveConnector.type.DOUBLE,\n    brace: StaveConnector.type.BRACE,\n    bracket: StaveConnector.type.BRACKET,\n    boldDoubleLeft: StaveConnector.type.BOLD_DOUBLE_LEFT,\n    boldDoubleRight: StaveConnector.type.BOLD_DOUBLE_RIGHT,\n    thinDouble: StaveConnector.type.THIN_DOUBLE,\n    none: StaveConnector.type.NONE,\n};\nexport { StaveConnector };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}